package server

import (
	"bytes"
	crypto_rand "crypto/rand"
	"encoding/binary"
	"encoding/hex"
	"fmt"
	"log"
	"net"
	"samp-server-go/source/protocol"
	"sync"
	"time"
)

var serverGUID uint64

var streamingPacket0x04 = []byte{
	0x04, 0x00, 0x48, 0x80, 0x00, 0x11, 0xe0, 0x14, 0x3c, 0xe2, 0x07, 0xf3, 0x58, 0x30, 0x00, 0x09,
	0x00, 0x91, 0x00, 0x80, 0x22, 0xc0, 0x14, 0x1d, 0xe1, 0x01, 0x00, 0x50, 0x0a, 0x00, 0x91, 0x01,
	0x00, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x83, 0x16, 0x6a, 0x64, 0xd4, 0x49, 0xac, 0x9c, 0x6c, 0x40,
	0x00, 0x05, 0x84, 0x10, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x91, 0x01, 0x80, 0x2b,
	0x40, 0x14, 0x38, 0xe9, 0x83, 0x29, 0xaa, 0x12, 0x0c, 0x56, 0x66, 0x67, 0x54, 0x3c, 0xdc, 0xc2,
	0x44, 0x10, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x91, 0x02, 0x00, 0x2b, 0x40, 0x14,
	0x38, 0xe9, 0x83, 0x39, 0xa6, 0x92, 0xa4, 0x5c, 0xd4, 0xcf, 0xdc, 0x40, 0x00, 0x08, 0xc4, 0x10,
	0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x91, 0x02, 0x80, 0x2b, 0x40, 0x14, 0x38, 0xe9,
	0x83, 0x4c, 0xd0, 0x40, 0x24, 0x50, 0x07, 0x00, 0x44, 0x5c, 0xdc, 0xc2, 0xc4, 0x10, 0x70, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x91, 0x03, 0x00, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x83, 0x5c,
	0xde, 0xc2, 0x84, 0x4c, 0xd4, 0xcf, 0x8c, 0x36, 0x66, 0x68, 0x64, 0x10, 0x70, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x0f, 0x00, 0x91, 0x03, 0x80, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x83, 0x66, 0x6b, 0x6e,
	0x1c, 0x4c, 0xdc, 0xc6, 0xb4, 0x46, 0x66, 0x6c, 0x64, 0x11, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x10, 0x00, 0x91, 0x04, 0x00, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x83, 0x76, 0x6e, 0xe2, 0xb4, 0x56,
	0x66, 0xe1, 0xa4, 0x50, 0x00, 0x03, 0x04, 0x11, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00,
	0x91, 0x04, 0x80, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x83, 0x8c, 0xdf, 0xc1, 0x24, 0x50, 0x01, 0x01,
	0xe4, 0x5c, 0xdc, 0xc2, 0xc4, 0x11, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0x91, 0x05,
	0x00, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x83, 0x90, 0x0b, 0x82, 0x44, 0x5c, 0xde, 0xce, 0x64, 0x40,
	0x00, 0x03, 0x04, 0x11, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x91, 0x05, 0x80, 0x2b,
	0x40, 0x14, 0x38, 0xe9, 0x83, 0xa6, 0x63, 0x60, 0x24, 0x50, 0x0d, 0x00, 0xa4, 0x50, 0x00, 0x03,
	0x04, 0x11, 0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x00, 0x91, 0x06, 0x00, 0x2b, 0x40, 0x14,
	0x38, 0xe9, 0x83, 0xb3, 0x3e, 0x3d, 0x6c, 0x4c, 0xde, 0xca, 0x94, 0x49, 0xa9, 0x90, 0x94, 0x11,
	0xd0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x00, 0x91, 0x06, 0x80, 0x2b, 0x40, 0x14, 0x38, 0xe9,
	0x83, 0xc3, 0x3a, 0x31, 0x14, 0x56, 0x66, 0x69, 0x64, 0x20, 0x00, 0x0f, 0x84, 0x11, 0xd0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x16, 0x00, 0x91, 0x07, 0x00, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x83, 0xd3,
	0x33, 0x34, 0xb4, 0x36, 0x66, 0x64, 0x8c, 0x30, 0x00, 0x0d, 0x04, 0x01, 0xd0, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x17, 0x00, 0x91, 0x07, 0x80, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x83, 0xe9, 0xa3, 0x94,
	0xb4, 0x43, 0x30, 0x3c, 0xac, 0x49, 0xa9, 0x95, 0x94, 0x10, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x18, 0x00, 0x91, 0x08, 0x00, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x83, 0xf3, 0x3e, 0x39, 0x54, 0x40,
	0x00, 0x06, 0x7c, 0x43, 0x33, 0x32, 0xd4, 0x20, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x00,
	0x91, 0x08, 0x80, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x84, 0x03, 0x3a, 0x31, 0x34, 0x56, 0x65, 0xe0,
	0x14, 0x5c, 0xdc, 0xc2, 0xc4, 0x10, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x00, 0x91, 0x09,
	0x00, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x84, 0x10, 0x05, 0x81, 0xa4, 0x59, 0xa3, 0x9f, 0xe4, 0x4c,
	0xdc, 0xc2, 0xc4, 0x10, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00,
}

var streamingPacket54 = []byte{
   0x0d, 0x80, 0x48, 0x84, 0xc0, 0x15, 0xa0, 0x14, 0x38, 0xe9, 0x84, 0x26, 0x6c, 0xe0, 0x74, 0x53,
    0x3b, 0xb2, 0xe4, 0x5c, 0xdc, 0xc2, 0xc4, 0x10, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00,
    0x91, 0x0a, 0x00, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x84, 0x39, 0xa6, 0x9e, 0xa4, 0x40, 0x08, 0x00,
    0x14, 0x5c, 0xdc, 0xc2, 0xc4, 0x10, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x91, 0x0a,
    0x80, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x84, 0x40, 0x03, 0x09, 0x14, 0x40, 0x08, 0x00, 0x14, 0x5c,
    0xdc, 0xc2, 0xc4, 0x10, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x91, 0x0b, 0x00, 0x2b,
    0x40, 0x14, 0x38, 0xe9, 0x84, 0x50, 0x04, 0x01, 0x3c, 0x50, 0x04, 0x07, 0xc4, 0x40, 0x00, 0x04,
    0x44, 0x20, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x91, 0x0b, 0x80, 0x2b, 0x40, 0x14,
    0x38, 0xe9, 0x84, 0x69, 0xa2, 0x9e, 0xfc, 0x4c, 0xd8, 0xc4, 0xe4, 0x49, 0xa9, 0x91, 0x34, 0x20,
    0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x91, 0x0c, 0x00, 0x2b, 0x40, 0x14, 0x38, 0xe9,
    0x84, 0x79, 0xaf, 0x91, 0x1c, 0x59, 0xa9, 0x92, 0x5c, 0x30, 0x00, 0x01, 0xe4, 0x20, 0xa0, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x21, 0x00, 0x91, 0x0c, 0x80, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x84, 0x8c,
    0xdd, 0xc1, 0x54, 0x53, 0x3f, 0x3e, 0xcc, 0x43, 0x33, 0x35, 0xb4, 0x10, 0xe0, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x22, 0x00, 0x91, 0x0d, 0x00, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x84, 0x99, 0xa5, 0x91,
    0x74, 0x53, 0x3b, 0x3b, 0xcc, 0x4c, 0xdc, 0xcc, 0x04, 0x10, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x23, 0x00, 0x91, 0x0d, 0x80, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x84, 0xa9, 0xaf, 0x92, 0x6c, 0x53,
    0x3b, 0x38, 0x04, 0x33, 0x33, 0x39, 0x34, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x00,
    0x91, 0x0e, 0x00, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x84, 0xb6, 0x68, 0x61, 0x54, 0x50, 0x0d, 0x0f,
    0xf4, 0x4c, 0xdc, 0xc2, 0xc4, 0x10, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x00, 0x91, 0x0e,
    0x80, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x84, 0xc0, 0x0c, 0x83, 0x14, 0x59, 0xa1, 0x11, 0x64, 0x50,
    0x00, 0x03, 0x04, 0x10, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x00, 0x91, 0x0f, 0x00, 0x2b,
    0x40, 0x14, 0x38, 0xe9, 0x84, 0xd0, 0x0b, 0x82, 0x44, 0x59, 0xa4, 0x9d, 0x14, 0x40, 0x00, 0x03,
    0x04, 0x10, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 0x00, 0x91, 0x0f, 0x80, 0x2b, 0x40, 0x14,
    0x38, 0xe9, 0x84, 0xe3, 0x39, 0xb0, 0x34, 0x53, 0x34, 0xb0, 0xb4, 0x50, 0x00, 0x03, 0x04, 0x10,
    0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x91, 0x10, 0x00, 0x2b, 0x40, 0x14, 0x38, 0xe9,
    0x84, 0xf0, 0x0a, 0x00, 0x6c, 0x53, 0x3d, 0x31, 0x9c, 0x56, 0x66, 0x6f, 0x64, 0x10, 0xe0, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x29, 0x00, 0x91, 0x10, 0x80, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x85, 0x06,
    0x60, 0x6e, 0x3c, 0x43, 0x33, 0x31, 0xb4, 0x40, 0x00, 0x01, 0x64, 0x20, 0xe0, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x2a, 0x00, 0x91, 0x11, 0x00, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x85, 0x10, 0x00, 0x09,
    0x8c, 0x4c, 0xde, 0xce, 0x44, 0x43, 0x33, 0x33, 0x54, 0x20, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x2b, 0x00, 0x91, 0x11, 0x80, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x85, 0x2e, 0x1b, 0xa2, 0xc4, 0x35,
    0x21, 0x89, 0x34, 0x43, 0x33, 0x35, 0xb4, 0x10, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x00,
    0x91, 0x12, 0x00, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x85, 0x30, 0x00, 0x06, 0x94, 0x40, 0x02, 0x0a,
    0x9c, 0x40, 0x00, 0x06, 0x04, 0x10, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00,
}

var streamingPacket56 = []byte{
    0x16, 0x80, 0x48, 0x89, 0x40, 0x15, 0xa0, 0x14, 0x38, 0xe9, 0x85, 0x46, 0x67, 0x6f, 0x64, 0x43,
    0x39, 0x3f, 0xec, 0x40, 0x00, 0x05, 0x84, 0x12, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x00,
    0x91, 0x13, 0x00, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x85, 0x59, 0xa7, 0x90, 0x14, 0x5c, 0xd7, 0xcd,
    0xec, 0x40, 0x00, 0x05, 0x84, 0x12, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2f, 0x00, 0x91, 0x13,
    0x80, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x85, 0x69, 0xae, 0x90, 0x24, 0x50, 0x07, 0x00, 0x44, 0x5c,
    0xdc, 0xc2, 0xc4, 0x12, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x91, 0x14, 0x00, 0x2b,
    0x40, 0x14, 0x38, 0xe9, 0x85, 0x70, 0x0a, 0x81, 0xbc, 0x56, 0x66, 0x62, 0x0c, 0x23, 0x33, 0x31,
    0xd4, 0x22, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x00, 0x91, 0x14, 0x80, 0x2b, 0x40, 0x14,
    0x38, 0xe9, 0x85, 0x8c, 0xd9, 0xca, 0xb4, 0x49, 0xad, 0x99, 0xfc, 0x40, 0x00, 0x04, 0x84, 0x10,
    0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x91, 0x15, 0x00, 0x2b, 0x40, 0x14, 0x38, 0xe9,
    0x85, 0x90, 0x00, 0x81, 0x64, 0x5c, 0xd4, 0xcf, 0x7c, 0x40, 0x00, 0x05, 0x84, 0x10, 0x60, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x33, 0x00, 0x91, 0x15, 0x80, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x85, 0xa9,
    0xa2, 0x92, 0x4c, 0x56, 0x66, 0x65, 0x14, 0x3c, 0xdc, 0xc9, 0xc4, 0x00, 0x60, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x34, 0x00, 0x91, 0x16, 0x00, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x85, 0xb6, 0x67, 0xe1,
    0xe4, 0x50, 0x03, 0x80, 0x24, 0x5c, 0xdc, 0xc2, 0xc4, 0x10, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x35, 0x00, 0x91, 0x16, 0x80, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x85, 0xc0, 0x0c, 0x80, 0x64, 0x5c,
    0xdc, 0xc6, 0xb4, 0x4c, 0xdc, 0xc2, 0xc4, 0x10, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x00,
    0x91, 0x17, 0x00, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x85, 0xdc, 0xde, 0xc4, 0x24, 0x49, 0xa4, 0x9e,
    0xa4, 0x4c, 0xdc, 0xc9, 0xc4, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0x00, 0x91, 0x17,
    0x80, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x85, 0xe3, 0x3c, 0xb0, 0x2c, 0x5c, 0xdf, 0xc1, 0x9c, 0x5c,
    0xdc, 0xcf, 0x44, 0x10, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x91, 0x18, 0x00, 0x2b,
    0x40, 0x14, 0x38, 0xe9, 0x85, 0xf0, 0x00, 0x07, 0x04, 0x33, 0x33, 0x33, 0x2c, 0x30, 0x00, 0x00,
    0x04, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x39, 0x00, 0x91, 0x18, 0x80, 0x2b, 0x40, 0x14,
    0x38, 0xe9, 0x86, 0x0c, 0xda, 0xcb, 0xcc, 0x4c, 0xd3, 0xc2, 0x34, 0x50, 0x00, 0x06, 0xa4, 0x20,
    0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3a, 0x00, 0x91, 0x19, 0x00, 0x2b, 0x40, 0x14, 0x38, 0xe9,
    0x86, 0x1c, 0x3d, 0x59, 0xdc, 0x3a, 0xe7, 0x74, 0xf4, 0x44, 0x8e, 0x15, 0x64, 0x10, 0x60, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x91, 0x19, 0x80, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x86, 0x26,
    0x6c, 0xe1, 0x14, 0x56, 0x66, 0x67, 0xe4, 0x20, 0x00, 0x0f, 0x84, 0x10, 0x60, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x3c, 0x00, 0x91, 0x1a, 0x00, 0x2b, 0xc0, 0x14, 0x2b, 0xea, 0x0f, 0x21, 0x70, 0x00,
    0x0c, 0x0b, 0x28, 0xb4, 0x44, 0x04, 0x0b, 0xac, 0x40, 0xde, 0x00, 0x24, 0x20, 0x00, 0x02, 0x04,
    0x10, 0x3d, 0x00, 0x91, 0x1a, 0x80, 0x2b, 0xc0, 0x14, 0x2b, 0xea, 0x06, 0xf1, 0x80, 0x00, 0x0c,
    0x0b, 0x28, 0xb4, 0x44, 0x04, 0x0b, 0xac, 0x40, 0xde, 0x00, 0x24, 0x20, 0x00, 0x02, 0x04, 0x10,
    0x3e, 0x00, 0x91, 0x1b, 0x00, 0x2b, 0xc0, 0x14, 0x2b, 0xea, 0x0f, 0xa0, 0x20, 0x00, 0x08, 0x0e,
    0xb9, 0x24, 0x40, 0x08, 0x6b, 0x1c, 0x4f, 0x90, 0xf9, 0xf4, 0x10, 0x00, 0x08, 0x03, 0xe0,
}

var streamingPacket58 = []byte{
    0x1f, 0x80, 0x48, 0x8d, 0xc0, 0x15, 0xe0, 0x14, 0x2b, 0xea, 0x06, 0x70, 0x20, 0x00, 0x04, 0x0c,
    0xb9, 0x14, 0x44, 0x03, 0x6b, 0x1c, 0x4e, 0x63, 0xf5, 0xf4, 0x10, 0x00, 0x08, 0x03, 0xe0, 0x40,
    0x00, 0x91, 0x1c, 0x00, 0x2b, 0xc0, 0x14, 0x2b, 0xea, 0x0c, 0xa0, 0x40, 0x00, 0x09, 0x1b, 0xd8,
    0x44, 0x33, 0x3a, 0x3c, 0x5c, 0x47, 0x2b, 0x90, 0x34, 0x20, 0x00, 0x0a, 0x04, 0x00, 0x41, 0x00,
    0x91, 0x1c, 0x80, 0x2b, 0xc0, 0x14, 0x2b, 0xea, 0x07, 0x61, 0x90, 0x00, 0x00, 0x42, 0x68, 0xc4,
    0x36, 0x6c, 0x6c, 0x8c, 0x4f, 0xbc, 0xb9, 0x04, 0x20, 0x00, 0x07, 0xa4, 0x30, 0x42, 0x00, 0x85,
    0xf8, 0x14, 0x49, 0xee, 0x00, 0x40, 0x00, 0x00, 0x0b, 0x80, 0xb0, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x07, 0xe7, 0x77, 0xe4, 0x77, 0x26, 0x16, 0xe6, 0x42, 0x04, 0xc6, 0x17, 0x26, 0x36, 0x56, 0xe7,
    0x90, 0x43, 0x00, 0x80, 0x8c, 0x08, 0x14, 0x5d, 0xc0, 0x00, 0x5f, 0xff, 0xff, 0xff, 0xe7, 0x00,
    0x00, 0x00, 0x0a, 0xec, 0xad, 0x8c, 0x6d, 0xed, 0xac, 0xa4, 0x0e, 0x8d, 0xe4, 0x0f, 0x67, 0x07,
    0x08, 0x28, 0x27, 0x07, 0x0f, 0xa8, 0xef, 0x68, 0xc8, 0xc8, 0xc8, 0xc8, 0xc8, 0xcf, 0xae, 0x4c,
    0x2d, 0xcc, 0x84, 0x0f, 0x67, 0x07, 0x08, 0x28, 0x27, 0x07, 0x0f, 0xa9, 0x8f, 0x68, 0xc8, 0xc8,
    0xc8, 0xc8, 0xc8, 0xcf, 0xac, 0x2e, 0x4c, 0x6c, 0xad, 0xcf, 0x20, 0x44, 0x00, 0x91, 0x1d, 0x00,
    0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x20, 0x20, 0x08, 0x69, 0x20, 0x00, 0x16, 0x6a, 0xbb,
    0xe8, 0x96, 0x9d, 0xd4, 0x58, 0x99, 0xe4, 0x4d, 0x28, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x10, 0xe8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00,
    0x45, 0x00, 0x91, 0x1d, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x20, 0x40, 0x08, 0xa9,
    0x20, 0x00, 0x09, 0x30, 0xfb, 0xe8, 0x96, 0x9d, 0xd4, 0x58, 0x80, 0x25, 0xed, 0x08, 0x20, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xe8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1f,
    0xff, 0xff, 0xff, 0xe0, 0x00, 0x46, 0x00, 0x91, 0x1e, 0x00, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8,
    0x00, 0x20, 0x60, 0x08, 0x89, 0x20, 0x00, 0x1c, 0x64, 0x1b, 0xe8, 0x96, 0x9d, 0xd4, 0x58, 0x80,
    0x25, 0xed, 0x08, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xe8, 0x60,
    0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x47, 0x00, 0x91, 0x1e, 0x80, 0x0c,
    0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x20, 0x80, 0x08, 0xa9, 0x20, 0x00, 0x09, 0x30, 0xfb, 0xe8,
    0x8f, 0x5c, 0xb4, 0x58, 0x80, 0x25, 0xed, 0x08, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x10, 0xe8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x48,
    0x00, 0x91, 0x1f, 0x00, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x20, 0xa0, 0x08, 0x89, 0x20,
    0x00, 0x1c, 0x64, 0x1b, 0xe8, 0x8f, 0x5c, 0xb4, 0x58, 0x80, 0x25, 0xed, 0x08, 0x20, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xe8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff,
    0xff, 0xff, 0xe0, 0x00, 0x49, 0x00, 0x91, 0x1f, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00,
    0x20, 0xc0, 0x08, 0xa9, 0x20, 0x00, 0x02, 0xca, 0x9b, 0xe8, 0x8f, 0x5c, 0xb4, 0x58, 0x93, 0x4f,
    0x37, 0x08, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xe8, 0x60, 0x00,
    0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00,
}

var streamingPacket60 = []byte{
    0x25, 0x00, 0x48, 0x90, 0x00, 0x06, 0x30, 0x10, 0x14, 0x2c, 0xc8, 0x00, 0x20, 0xe0, 0x08, 0x89,
    0x20, 0x00, 0x02, 0xca, 0x9b, 0xe8, 0x8f, 0x5c, 0xb4, 0x58, 0x93, 0x4f, 0x37, 0x08, 0x20, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xe8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1f,
    0xff, 0xff, 0xff, 0xe0, 0x00, 0x4b, 0x00, 0x91, 0x20, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8,
    0x00, 0x21, 0x00, 0x08, 0xa9, 0x20, 0x00, 0x02, 0xca, 0x9b, 0xe8, 0x8f, 0x5c, 0xb4, 0x58, 0x8c,
    0x02, 0xdc, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xe8, 0x60,
    0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x4c, 0x00, 0x91, 0x21, 0x00, 0x0c,
    0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x21, 0x20, 0x08, 0x89, 0x20, 0x00, 0x02, 0xca, 0x9b, 0xe8,
    0x8f, 0x5c, 0xb4, 0x58, 0x8c, 0x02, 0xdc, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x10, 0xe8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x4d,
    0x00, 0x91, 0x21, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x21, 0x40, 0x08, 0xa9, 0x20,
    0x00, 0x02, 0xca, 0x9b, 0xe8, 0x8f, 0x5c, 0xb4, 0x58, 0x92, 0x7b, 0x20, 0xe8, 0x40, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xe8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff,
    0xff, 0xff, 0xe0, 0x00, 0x4e, 0x00, 0x91, 0x22, 0x00, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00,
    0x21, 0x60, 0x08, 0x89, 0x20, 0x00, 0x02, 0xca, 0x9b, 0xe8, 0x8f, 0x5c, 0xb4, 0x58, 0x92, 0x7b,
    0x20, 0xe8, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xe8, 0x60, 0x00,
    0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x4f, 0x00, 0x91, 0x22, 0x80, 0x0c, 0x60,
    0x20, 0x14, 0x2c, 0xc8, 0x00, 0x21, 0x80, 0x08, 0xa9, 0x20, 0x00, 0x02, 0xca, 0x9b, 0xe8, 0x8f,
    0x5c, 0xb4, 0x58, 0x9e, 0xd4, 0xe3, 0xa8, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x10, 0xe8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x50, 0x00,
    0x91, 0x23, 0x00, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x21, 0xa0, 0x08, 0x89, 0x20, 0x00,
    0x02, 0xca, 0x9b, 0xe8, 0x8f, 0x5c, 0xb4, 0x58, 0x9e, 0xd4, 0xe3, 0xa8, 0x40, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xe8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff,
    0xff, 0xe0, 0x00, 0x51, 0x00, 0x91, 0x23, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x21,
    0xc0, 0x08, 0xa9, 0x20, 0x00, 0x02, 0xca, 0x9b, 0xe8, 0x8f, 0x5c, 0xb4, 0x58, 0x8b, 0x2e, 0xc6,
    0x68, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xe8, 0x60, 0x00, 0x00,
    0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x52, 0x00, 0x91, 0x24, 0x00, 0x0c, 0x60, 0x20,
    0x14, 0x2c, 0xc8, 0x00, 0x21, 0xe0, 0x08, 0x89, 0x20, 0x00, 0x02, 0xca, 0x9b, 0xe8, 0x8f, 0x5c,
    0xb4, 0x58, 0x8b, 0x2e, 0xc6, 0x68, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x10, 0xe8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x53, 0x00, 0x91,
    0x24, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x22, 0x00, 0x08, 0xa9, 0x20, 0x00, 0x02,
    0xca, 0x9b, 0xe8, 0x8f, 0x5c, 0xb4, 0x58, 0x97, 0x88, 0x89, 0x28, 0x40, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xe8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff,
    0xe0, 0x00,
}

var streamingPacket55 = []byte{
	0x0d, 0x80, 0x48, 0x84, 0xc0, 0x15, 0xa0, 0x14, 0x38, 0xe9, 0x84, 0x26, 0x6c, 0xe0, 0x74, 0x53,
	0x3b, 0xb2, 0xe4, 0x5c, 0xdc, 0xc2, 0xc4, 0x10, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00,
	0x91, 0x0a, 0x00, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x84, 0x39, 0xa6, 0x9e, 0xa4, 0x40, 0x08, 0x00,
	0x14, 0x5c, 0xdc, 0xc2, 0xc4, 0x10, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x91, 0x0a,
	0x80, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x84, 0x40, 0x03, 0x09, 0x14, 0x40, 0x08, 0x00, 0x14, 0x5c,
	0xdc, 0xc2, 0xc4, 0x10, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x91, 0x0b, 0x00, 0x2b,
	0x40, 0x14, 0x38, 0xe9, 0x84, 0x50, 0x04, 0x01, 0x3c, 0x50, 0x04, 0x07, 0xc4, 0x40, 0x00, 0x04,
	0x44, 0x20, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x91, 0x0b, 0x80, 0x2b, 0x40, 0x14,
	0x38, 0xe9, 0x84, 0x69, 0xa2, 0x9e, 0xfc, 0x4c, 0xd8, 0xc4, 0xe4, 0x49, 0xa9, 0x91, 0x34, 0x20,
	0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x91, 0x0c, 0x00, 0x2b, 0x40, 0x14, 0x38, 0xe9,
	0x84, 0x79, 0xaf, 0x91, 0x1c, 0x59, 0xa9, 0x92, 0x5c, 0x30, 0x00, 0x01, 0xe4, 0x20, 0xa0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x21, 0x00, 0x91, 0x0c, 0x80, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x84, 0x8c,
	0xdd, 0xc1, 0x54, 0x53, 0x3f, 0x3e, 0xcc, 0x43, 0x33, 0x35, 0xb4, 0x10, 0xe0, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x22, 0x00, 0x91, 0x0d, 0x00, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x84, 0x99, 0xa5, 0x91,
	0x74, 0x53, 0x3b, 0x3b, 0xcc, 0x4c, 0xdc, 0xcc, 0x04, 0x10, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x23, 0x00, 0x91, 0x0d, 0x80, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x84, 0xa9, 0xaf, 0x92, 0x6c, 0x53,
	0x3b, 0x38, 0x04, 0x33, 0x33, 0x39, 0x34, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x00,
	0x91, 0x0e, 0x00, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x84, 0xb6, 0x68, 0x61, 0x54, 0x50, 0x0d, 0x0f,
	0xf4, 0x4c, 0xdc, 0xc2, 0xc4, 0x10, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x00, 0x91, 0x0e,
	0x80, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x84, 0xc0, 0x0c, 0x83, 0x14, 0x59, 0xa1, 0x11, 0x64, 0x50,
	0x00, 0x03, 0x04, 0x10, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x00, 0x91, 0x0f, 0x00, 0x2b,
	0x40, 0x14, 0x38, 0xe9, 0x84, 0xd0, 0x0b, 0x82, 0x44, 0x59, 0xa4, 0x9d, 0x14, 0x40, 0x00, 0x03,
	0x04, 0x10, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27, 0x00, 0x91, 0x0f, 0x80, 0x2b, 0x40, 0x14,
	0x38, 0xe9, 0x84, 0xe3, 0x39, 0xb0, 0x34, 0x53, 0x34, 0xb0, 0xb4, 0x50, 0x00, 0x03, 0x04, 0x10,
	0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x91, 0x10, 0x00, 0x2b, 0x40, 0x14, 0x38, 0xe9,
	0x84, 0xf0, 0x0a, 0x00, 0x6c, 0x53, 0x3d, 0x31, 0x9c, 0x56, 0x66, 0x6f, 0x64, 0x10, 0xe0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x29, 0x00, 0x91, 0x10, 0x80, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x85, 0x06,
	0x60, 0x6e, 0x3c, 0x43, 0x33, 0x31, 0xb4, 0x40, 0x00, 0x01, 0x64, 0x20, 0xe0, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x2a, 0x00, 0x91, 0x11, 0x00, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x85, 0x10, 0x00, 0x09,
	0x8c, 0x4c, 0xde, 0xce, 0x44, 0x43, 0x33, 0x33, 0x54, 0x20, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x2b, 0x00, 0x91, 0x11, 0x80, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x85, 0x2e, 0x1b, 0xa2, 0xc4, 0x35,
	0x21, 0x89, 0x34, 0x43, 0x33, 0x35, 0xb4, 0x10, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x00,
	0x91, 0x12, 0x00, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x85, 0x30, 0x00, 0x06, 0x94, 0x40, 0x02, 0x0a,
	0x9c, 0x40, 0x00, 0x06, 0x04, 0x10, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00,
}

// Packet [57] opcode=0x16 len=543b
var streamingPacket57 = []byte{
	0x16, 0x80, 0x48, 0x89, 0x40, 0x15, 0xa0, 0x14, 0x38, 0xe9, 0x85, 0x46, 0x67, 0x6f, 0x64, 0x43,
	0x39, 0x3f, 0xec, 0x40, 0x00, 0x05, 0x84, 0x12, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x00,
	0x91, 0x13, 0x00, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x85, 0x59, 0xa7, 0x90, 0x14, 0x5c, 0xd7, 0xcd,
	0xec, 0x40, 0x00, 0x05, 0x84, 0x12, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2f, 0x00, 0x91, 0x13,
	0x80, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x85, 0x69, 0xae, 0x90, 0x24, 0x50, 0x07, 0x00, 0x44, 0x5c,
	0xdc, 0xc2, 0xc4, 0x12, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x91, 0x14, 0x00, 0x2b,
	0x40, 0x14, 0x38, 0xe9, 0x85, 0x70, 0x0a, 0x81, 0xbc, 0x56, 0x66, 0x62, 0x0c, 0x23, 0x33, 0x31,
	0xd4, 0x22, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x00, 0x91, 0x14, 0x80, 0x2b, 0x40, 0x14,
	0x38, 0xe9, 0x85, 0x8c, 0xd9, 0xca, 0xb4, 0x49, 0xad, 0x99, 0xfc, 0x40, 0x00, 0x04, 0x84, 0x10,
	0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x91, 0x15, 0x00, 0x2b, 0x40, 0x14, 0x38, 0xe9,
	0x85, 0x90, 0x00, 0x81, 0x64, 0x5c, 0xd4, 0xcf, 0x7c, 0x40, 0x00, 0x05, 0x84, 0x10, 0x60, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x33, 0x00, 0x91, 0x15, 0x80, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x85, 0xa9,
	0xa2, 0x92, 0x4c, 0x56, 0x66, 0x65, 0x14, 0x3c, 0xdc, 0xc9, 0xc4, 0x00, 0x60, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x34, 0x00, 0x91, 0x16, 0x00, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x85, 0xb6, 0x67, 0xe1,
	0xe4, 0x50, 0x03, 0x80, 0x24, 0x5c, 0xdc, 0xc2, 0xc4, 0x10, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x35, 0x00, 0x91, 0x16, 0x80, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x85, 0xc0, 0x0c, 0x80, 0x64, 0x5c,
	0xdc, 0xc6, 0xb4, 0x4c, 0xdc, 0xc2, 0xc4, 0x10, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x00,
	0x91, 0x17, 0x00, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x85, 0xdc, 0xde, 0xc4, 0x24, 0x49, 0xa4, 0x9e,
	0xa4, 0x4c, 0xdc, 0xc9, 0xc4, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0x00, 0x91, 0x17,
	0x80, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x85, 0xe3, 0x3c, 0xb0, 0x2c, 0x5c, 0xdf, 0xc1, 0x9c, 0x5c,
	0xdc, 0xcf, 0x44, 0x10, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x91, 0x18, 0x00, 0x2b,
	0x40, 0x14, 0x38, 0xe9, 0x85, 0xf0, 0x00, 0x07, 0x04, 0x33, 0x33, 0x33, 0x2c, 0x30, 0x00, 0x00,
	0x04, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x39, 0x00, 0x91, 0x18, 0x80, 0x2b, 0x40, 0x14,
	0x38, 0xe9, 0x86, 0x0c, 0xda, 0xcb, 0xcc, 0x4c, 0xd3, 0xc2, 0x34, 0x50, 0x00, 0x06, 0xa4, 0x20,
	0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3a, 0x00, 0x91, 0x19, 0x00, 0x2b, 0x40, 0x14, 0x38, 0xe9,
	0x86, 0x1c, 0x3d, 0x59, 0xdc, 0x3a, 0xe7, 0x74, 0xf4, 0x44, 0x8e, 0x15, 0x64, 0x10, 0x60, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x91, 0x19, 0x80, 0x2b, 0x40, 0x14, 0x38, 0xe9, 0x86, 0x26,
	0x6c, 0xe1, 0x14, 0x56, 0x66, 0x67, 0xe4, 0x20, 0x00, 0x0f, 0x84, 0x10, 0x60, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x3c, 0x00, 0x91, 0x1a, 0x00, 0x2b, 0xc0, 0x14, 0x2b, 0xea, 0x0f, 0x21, 0x70, 0x00,
	0x0c, 0x0b, 0x28, 0xb4, 0x44, 0x04, 0x0b, 0xac, 0x40, 0xde, 0x00, 0x24, 0x20, 0x00, 0x02, 0x04,
	0x10, 0x3d, 0x00, 0x91, 0x1a, 0x80, 0x2b, 0xc0, 0x14, 0x2b, 0xea, 0x06, 0xf1, 0x80, 0x00, 0x0c,
	0x0b, 0x28, 0xb4, 0x44, 0x04, 0x0b, 0xac, 0x40, 0xde, 0x00, 0x24, 0x20, 0x00, 0x02, 0x04, 0x10,
	0x3e, 0x00, 0x91, 0x1b, 0x00, 0x2b, 0xc0, 0x14, 0x2b, 0xea, 0x0f, 0xa0, 0x20, 0x00, 0x08, 0x0e,
	0xb9, 0x24, 0x40, 0x08, 0x6b, 0x1c, 0x4f, 0x90, 0xf9, 0xf4, 0x10, 0x00, 0x08, 0x03, 0xe0,
}

// Packet [59] opcode=0x1f len=521b
var streamingPacket59 = []byte{
	0x1f, 0x80, 0x48, 0x8d, 0xc0, 0x15, 0xe0, 0x14, 0x2b, 0xea, 0x06, 0x70, 0x20, 0x00, 0x04, 0x0c,
	0xb9, 0x14, 0x44, 0x03, 0x6b, 0x1c, 0x4e, 0x63, 0xf5, 0xf4, 0x10, 0x00, 0x08, 0x03, 0xe0, 0x40,
	0x00, 0x91, 0x1c, 0x00, 0x2b, 0xc0, 0x14, 0x2b, 0xea, 0x0c, 0xa0, 0x40, 0x00, 0x09, 0x1b, 0xd8,
	0x44, 0x33, 0x3a, 0x3c, 0x5c, 0x47, 0x2b, 0x90, 0x34, 0x20, 0x00, 0x0a, 0x04, 0x00, 0x41, 0x00,
	0x91, 0x1c, 0x80, 0x2b, 0xc0, 0x14, 0x2b, 0xea, 0x07, 0x61, 0x90, 0x00, 0x00, 0x42, 0x68, 0xc4,
	0x36, 0x6c, 0x6c, 0x8c, 0x4f, 0xbc, 0xb9, 0x04, 0x20, 0x00, 0x07, 0xa4, 0x30, 0x42, 0x00, 0x85,
	0xf8, 0x14, 0x49, 0xee, 0x00, 0x40, 0x00, 0x00, 0x0b, 0x80, 0xb0, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x07, 0xe7, 0x77, 0xe4, 0x77, 0x26, 0x16, 0xe6, 0x42, 0x04, 0xc6, 0x17, 0x26, 0x36, 0x56, 0xe7,
	0x90, 0x43, 0x00, 0x80, 0x8c, 0x08, 0x14, 0x5d, 0xc0, 0x00, 0x5f, 0xff, 0xff, 0xff, 0xe7, 0x00,
	0x00, 0x00, 0x0a, 0xec, 0xad, 0x8c, 0x6d, 0xed, 0xac, 0xa4, 0x0e, 0x8d, 0xe4, 0x0f, 0x67, 0x07,
	0x08, 0x28, 0x27, 0x07, 0x0f, 0xa8, 0xef, 0x68, 0xc8, 0xc8, 0xc8, 0xc8, 0xc8, 0xcf, 0xae, 0x4c,
	0x2d, 0xcc, 0x84, 0x0f, 0x67, 0x07, 0x08, 0x28, 0x27, 0x07, 0x0f, 0xa9, 0x8f, 0x68, 0xc8, 0xc8,
	0xc8, 0xc8, 0xc8, 0xcf, 0xac, 0x2e, 0x4c, 0x6c, 0xad, 0xcf, 0x20, 0x44, 0x00, 0x91, 0x1d, 0x00,
	0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x20, 0x20, 0x08, 0x69, 0x20, 0x00, 0x16, 0x6a, 0xbb,
	0xe8, 0x96, 0x9d, 0xd4, 0x58, 0x99, 0xe4, 0x4d, 0x28, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x10, 0xe8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00,
	0x45, 0x00, 0x91, 0x1d, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x20, 0x40, 0x08, 0xa9,
	0x20, 0x00, 0x09, 0x30, 0xfb, 0xe8, 0x96, 0x9d, 0xd4, 0x58, 0x80, 0x25, 0xed, 0x08, 0x20, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xe8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1f,
	0xff, 0xff, 0xff, 0xe0, 0x00, 0x46, 0x00, 0x91, 0x1e, 0x00, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8,
	0x00, 0x20, 0x60, 0x08, 0x89, 0x20, 0x00, 0x1c, 0x64, 0x1b, 0xe8, 0x96, 0x9d, 0xd4, 0x58, 0x80,
	0x25, 0xed, 0x08, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xe8, 0x60,
	0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x47, 0x00, 0x91, 0x1e, 0x80, 0x0c,
	0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x20, 0x80, 0x08, 0xa9, 0x20, 0x00, 0x09, 0x30, 0xfb, 0xe8,
	0x8f, 0x5c, 0xb4, 0x58, 0x80, 0x25, 0xed, 0x08, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x10, 0xe8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x48,
	0x00, 0x91, 0x1f, 0x00, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x20, 0xa0, 0x08, 0x89, 0x20,
	0x00, 0x1c, 0x64, 0x1b, 0xe8, 0x8f, 0x5c, 0xb4, 0x58, 0x80, 0x25, 0xed, 0x08, 0x20, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xe8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff,
	0xff, 0xff, 0xe0, 0x00, 0x49, 0x00, 0x91, 0x1f, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00,
	0x20, 0xc0, 0x08, 0xa9, 0x20, 0x00, 0x02, 0xca, 0x9b, 0xe8, 0x8f, 0x5c, 0xb4, 0x58, 0x93, 0x4f,
	0x37, 0x08, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xe8, 0x60, 0x00,
	0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00,
}

// Packet [61] opcode=0x25 len=530b
var streamingPacket61 = []byte{
	0x25, 0x00, 0x48, 0x90, 0x00, 0x06, 0x30, 0x10, 0x14, 0x2c, 0xc8, 0x00, 0x20, 0xe0, 0x08, 0x89,
	0x20, 0x00, 0x02, 0xca, 0x9b, 0xe8, 0x8f, 0x5c, 0xb4, 0x58, 0x93, 0x4f, 0x37, 0x08, 0x20, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xe8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1f,
	0xff, 0xff, 0xff, 0xe0, 0x00, 0x4b, 0x00, 0x91, 0x20, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8,
	0x00, 0x21, 0x00, 0x08, 0xa9, 0x20, 0x00, 0x02, 0xca, 0x9b, 0xe8, 0x8f, 0x5c, 0xb4, 0x58, 0x8c,
	0x02, 0xdc, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xe8, 0x60,
	0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x4c, 0x00, 0x91, 0x21, 0x00, 0x0c,
	0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x21, 0x20, 0x08, 0x89, 0x20, 0x00, 0x02, 0xca, 0x9b, 0xe8,
	0x8f, 0x5c, 0xb4, 0x58, 0x8c, 0x02, 0xdc, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x10, 0xe8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x4d,
	0x00, 0x91, 0x21, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x21, 0x40, 0x08, 0xa9, 0x20,
	0x00, 0x02, 0xca, 0x9b, 0xe8, 0x8f, 0x5c, 0xb4, 0x58, 0x92, 0x7b, 0x20, 0xe8, 0x40, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xe8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff,
	0xff, 0xff, 0xe0, 0x00, 0x4e, 0x00, 0x91, 0x22, 0x00, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00,
	0x21, 0x60, 0x08, 0x89, 0x20, 0x00, 0x02, 0xca, 0x9b, 0xe8, 0x8f, 0x5c, 0xb4, 0x58, 0x92, 0x7b,
	0x20, 0xe8, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xe8, 0x60, 0x00,
	0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x4f, 0x00, 0x91, 0x22, 0x80, 0x0c, 0x60,
	0x20, 0x14, 0x2c, 0xc8, 0x00, 0x21, 0x80, 0x08, 0xa9, 0x20, 0x00, 0x02, 0xca, 0x9b, 0xe8, 0x8f,
	0x5c, 0xb4, 0x58, 0x9e, 0xd4, 0xe3, 0xa8, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x10, 0xe8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x50, 0x00,
	0x91, 0x23, 0x00, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x21, 0xa0, 0x08, 0x89, 0x20, 0x00,
	0x02, 0xca, 0x9b, 0xe8, 0x8f, 0x5c, 0xb4, 0x58, 0x9e, 0xd4, 0xe3, 0xa8, 0x40, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xe8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff,
	0xff, 0xe0, 0x00, 0x51, 0x00, 0x91, 0x23, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x21,
	0xc0, 0x08, 0xa9, 0x20, 0x00, 0x02, 0xca, 0x9b, 0xe8, 0x8f, 0x5c, 0xb4, 0x58, 0x8b, 0x2e, 0xc6,
	0x68, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xe8, 0x60, 0x00, 0x00,
	0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x52, 0x00, 0x91, 0x24, 0x00, 0x0c, 0x60, 0x20,
	0x14, 0x2c, 0xc8, 0x00, 0x21, 0xe0, 0x08, 0x89, 0x20, 0x00, 0x02, 0xca, 0x9b, 0xe8, 0x8f, 0x5c,
	0xb4, 0x58, 0x8b, 0x2e, 0xc6, 0x68, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x10, 0xe8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x53, 0x00, 0x91,
	0x24, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x22, 0x00, 0x08, 0xa9, 0x20, 0x00, 0x02,
	0xca, 0x9b, 0xe8, 0x8f, 0x5c, 0xb4, 0x58, 0x97, 0x88, 0x89, 0x28, 0x40, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xe8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff,
	0xe0, 0x00,
}

// Packet [63] opcode=0x2a len=530b
var streamingPacket63 = []byte{
	0x2a, 0x00, 0x48, 0x92, 0x80, 0x06, 0x30, 0x10, 0x14, 0x2c, 0xc8, 0x00, 0x22, 0x20, 0x08, 0x89,
	0x20, 0x00, 0x02, 0xca, 0x9b, 0xe8, 0x8f, 0x5c, 0xb4, 0x58, 0x97, 0x88, 0x89, 0x28, 0x40, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xe8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1f,
	0xff, 0xff, 0xff, 0xe0, 0x00, 0x55, 0x00, 0x91, 0x25, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8,
	0x00, 0x22, 0x40, 0x08, 0xa9, 0x20, 0x00, 0x02, 0xca, 0x9b, 0xe8, 0x8f, 0x5c, 0xb4, 0x58, 0x83,
	0xe2, 0x6b, 0xe8, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xe8, 0x60,
	0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x56, 0x00, 0x91, 0x26, 0x00, 0x0c,
	0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x22, 0x60, 0x08, 0x89, 0x20, 0x00, 0x02, 0xca, 0x9b, 0xe8,
	0x8f, 0x5c, 0xb4, 0x58, 0x83, 0xe2, 0x6b, 0xe8, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x10, 0xe8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x57,
	0x00, 0x91, 0x26, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x22, 0x80, 0x08, 0xa9, 0x20,
	0x00, 0x02, 0xca, 0x9b, 0xe8, 0x8f, 0x5c, 0xb4, 0x58, 0x90, 0x7c, 0x2e, 0x88, 0x40, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xe8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff,
	0xff, 0xff, 0xe0, 0x00, 0x58, 0x00, 0x91, 0x27, 0x00, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00,
	0x22, 0xa0, 0x08, 0x89, 0x20, 0x00, 0x02, 0xca, 0x9b, 0xe8, 0x8f, 0x5c, 0xb4, 0x58, 0x90, 0x7c,
	0x2e, 0x88, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xe8, 0x60, 0x00,
	0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x59, 0x00, 0x91, 0x27, 0x80, 0x0c, 0x60,
	0x20, 0x14, 0x2c, 0xc8, 0x00, 0x22, 0xc0, 0x08, 0xa9, 0x20, 0x00, 0x02, 0xca, 0x9b, 0xe8, 0x8f,
	0x5c, 0xb4, 0x58, 0x9e, 0x6a, 0xf0, 0xa8, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x10, 0xe8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x5a, 0x00,
	0x91, 0x28, 0x00, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x22, 0xe0, 0x08, 0x89, 0x20, 0x00,
	0x02, 0xca, 0x9b, 0xe8, 0x8f, 0x5c, 0xb4, 0x58, 0x9e, 0x6a, 0xf0, 0xa8, 0x40, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xe8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff,
	0xff, 0xe0, 0x00, 0x5b, 0x00, 0x91, 0x28, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x23,
	0x00, 0x08, 0xa9, 0x20, 0x00, 0x02, 0xca, 0x9b, 0xe8, 0x8f, 0x5c, 0xb4, 0x58, 0x84, 0xa7, 0xf2,
	0x08, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xe8, 0x60, 0x00, 0x00,
	0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x5c, 0x00, 0x91, 0x29, 0x00, 0x0c, 0x60, 0x20,
	0x14, 0x2c, 0xc8, 0x00, 0x23, 0x20, 0x08, 0x89, 0x20, 0x00, 0x02, 0xca, 0x9b, 0xe8, 0x8f, 0x5c,
	0xb4, 0x58, 0x84, 0xa7, 0xf2, 0x08, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x10, 0xe8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x5d, 0x00, 0x91,
	0x29, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x23, 0x40, 0x08, 0xa9, 0x20, 0x00, 0x02,
	0xca, 0x9b, 0xe8, 0x8f, 0x5c, 0xb4, 0x58, 0x8a, 0xc4, 0xd3, 0x68, 0x40, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xe8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff,
	0xe0, 0x00,
}

// Packet [65] opcode=0x2f len=530b
var streamingPacket65 = []byte{
	0x2f, 0x00, 0x48, 0x95, 0x00, 0x06, 0x30, 0x10, 0x14, 0x2c, 0xc8, 0x00, 0x23, 0x60, 0x08, 0x89,
	0x20, 0x00, 0x02, 0xca, 0x9b, 0xe8, 0x8f, 0x5c, 0xb4, 0x58, 0x8a, 0xc4, 0xd3, 0x68, 0x40, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xe8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1f,
	0xff, 0xff, 0xff, 0xe0, 0x00, 0x5f, 0x00, 0x91, 0x2a, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8,
	0x00, 0x23, 0x80, 0x08, 0xa9, 0x20, 0x00, 0x02, 0xca, 0x9b, 0xe8, 0x8f, 0x5c, 0xb4, 0x58, 0x91,
	0x01, 0xb4, 0xc8, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xe8, 0x60,
	0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x60, 0x00, 0x91, 0x2b, 0x00, 0x0c,
	0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x23, 0xa0, 0x08, 0x89, 0x20, 0x00, 0x02, 0xca, 0x9b, 0xe8,
	0x8f, 0x5c, 0xb4, 0x58, 0x91, 0x01, 0xb4, 0xc8, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x10, 0xe8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x61,
	0x00, 0x91, 0x2b, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x23, 0xc0, 0x08, 0xa9, 0x20,
	0x00, 0x02, 0xca, 0x9b, 0xe8, 0x8f, 0x5c, 0xb4, 0x58, 0x97, 0x3e, 0x96, 0x08, 0x40, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xe8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff,
	0xff, 0xff, 0xe0, 0x00, 0x62, 0x00, 0x91, 0x2c, 0x00, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00,
	0x23, 0xe0, 0x08, 0x89, 0x20, 0x00, 0x02, 0xca, 0x9b, 0xe8, 0x8f, 0x5c, 0xb4, 0x58, 0x97, 0x3e,
	0x96, 0x08, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xe8, 0x60, 0x00,
	0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x63, 0x00, 0x91, 0x2c, 0x80, 0x0c, 0x60,
	0x20, 0x14, 0x2c, 0xc8, 0x00, 0x24, 0x00, 0x08, 0xa9, 0x20, 0x00, 0x02, 0xca, 0x9b, 0xe8, 0x8f,
	0x5c, 0xb4, 0x58, 0x9d, 0x7b, 0x77, 0x68, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x10, 0xe8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x64, 0x00,
	0x91, 0x2d, 0x00, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x24, 0x20, 0x08, 0x89, 0x20, 0x00,
	0x02, 0xca, 0x9b, 0xe8, 0x8f, 0x5c, 0xb4, 0x58, 0x9d, 0x7b, 0x77, 0x68, 0x40, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xe8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff,
	0xff, 0xe0, 0x00, 0x65, 0x00, 0x91, 0x2d, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x24,
	0x40, 0x08, 0xa9, 0x20, 0x00, 0x02, 0xca, 0x9b, 0xe8, 0x8f, 0x5c, 0xb4, 0x58, 0x83, 0x98, 0x78,
	0xc8, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xe8, 0x60, 0x00, 0x00,
	0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x66, 0x00, 0x91, 0x2e, 0x00, 0x0c, 0x60, 0x20,
	0x14, 0x2c, 0xc8, 0x00, 0x24, 0x60, 0x08, 0x89, 0x20, 0x00, 0x02, 0xca, 0x9b, 0xe8, 0x8f, 0x5c,
	0xb4, 0x58, 0x83, 0x98, 0x78, 0xc8, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x10, 0xe8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x67, 0x00, 0x91,
	0x2e, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x24, 0x80, 0x08, 0xa9, 0x20, 0x00, 0x02,
	0xca, 0x9b, 0xe8, 0x8f, 0x5c, 0xb4, 0x58, 0x89, 0xd5, 0x5a, 0x28, 0x40, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xe8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff,
	0xe0, 0x00,
}

// Packet [67] opcode=0x34 len=530b
var streamingPacket67 = []byte{
	0x34, 0x00, 0x48, 0x97, 0x80, 0x06, 0x30, 0x10, 0x14, 0x2c, 0xc8, 0x00, 0x24, 0xa0, 0x08, 0x89,
	0x20, 0x00, 0x02, 0xca, 0x9b, 0xe8, 0x8f, 0x5c, 0xb4, 0x58, 0x89, 0xd5, 0x5a, 0x28, 0x40, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xe8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1f,
	0xff, 0xff, 0xff, 0xe0, 0x00, 0x69, 0x00, 0x91, 0x2f, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8,
	0x00, 0x24, 0xc0, 0x08, 0xa9, 0x20, 0x00, 0x02, 0xca, 0x9b, 0xe8, 0x8f, 0x5c, 0xb4, 0x58, 0x8f,
	0xf2, 0x3b, 0x88, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xe8, 0x60,
	0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x6a, 0x00, 0x91, 0x30, 0x00, 0x0c,
	0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x24, 0xe0, 0x08, 0x89, 0x20, 0x00, 0x02, 0xca, 0x9b, 0xe8,
	0x8f, 0x5c, 0xb4, 0x58, 0x8f, 0xf2, 0x3b, 0x88, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x10, 0xe8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x6b,
	0x00, 0x91, 0x30, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x25, 0x00, 0x08, 0xa9, 0x20,
	0x00, 0x02, 0xca, 0x9b, 0xe8, 0x8f, 0x5c, 0xb4, 0x58, 0x96, 0x2f, 0x1c, 0xe8, 0x40, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xe8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff,
	0xff, 0xff, 0xe0, 0x00, 0x6c, 0x00, 0x91, 0x31, 0x00, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00,
	0x25, 0x20, 0x08, 0x89, 0x20, 0x00, 0x02, 0xca, 0x9b, 0xe8, 0x8f, 0x5c, 0xb4, 0x58, 0x96, 0x2f,
	0x1c, 0xe8, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xe8, 0x60, 0x00,
	0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x6d, 0x00, 0x91, 0x31, 0x80, 0x0c, 0x60,
	0x20, 0x14, 0x2c, 0xc8, 0x00, 0x25, 0x40, 0x08, 0xa9, 0x20, 0x00, 0x02, 0xca, 0x9b, 0xe8, 0x8f,
	0x5c, 0xb4, 0x58, 0x9c, 0x4b, 0xfe, 0x48, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x10, 0xe8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x6e, 0x00,
	0x91, 0x32, 0x00, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x25, 0x60, 0x08, 0x89, 0x20, 0x00,
	0x02, 0xca, 0x9b, 0xe8, 0x8f, 0x5c, 0xb4, 0x58, 0x9c, 0x4b, 0xfe, 0x48, 0x40, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xe8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff,
	0xff, 0xe0, 0x00, 0x6f, 0x00, 0x91, 0x32, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x25,
	0x80, 0x08, 0xa9, 0x20, 0x00, 0x02, 0xca, 0x9b, 0xe8, 0x8f, 0x5c, 0xb4, 0x58, 0x82, 0x88, 0xff,
	0xa8, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xe8, 0x60, 0x00, 0x00,
	0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x70, 0x00, 0x91, 0x33, 0x00, 0x0c, 0x60, 0x20,
	0x14, 0x2c, 0xc8, 0x00, 0x25, 0xa0, 0x08, 0x89, 0x20, 0x00, 0x02, 0xca, 0x9b, 0xe8, 0x8f, 0x5c,
	0xb4, 0x58, 0x82, 0x88, 0xff, 0xa8, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x10, 0xe8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x71, 0x00, 0x91,
	0x33, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x25, 0xc0, 0x0f, 0x49, 0x60, 0x00, 0x11,
	0xf6, 0x51, 0x68, 0x8a, 0x48, 0x17, 0x58, 0x89, 0x1c, 0x20, 0x48, 0x40, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x08, 0x60, 0x1f, 0xff, 0xff, 0xff,
	0xe0, 0x00,
}

// Packet [69] opcode=0x39 len=530b
var streamingPacket69 = []byte{
	0x39, 0x00, 0x48, 0x9a, 0x00, 0x06, 0x30, 0x10, 0x14, 0x2c, 0xc8, 0x00, 0x25, 0xe0, 0x0f, 0x69,
	0x60, 0x00, 0x11, 0xf6, 0x51, 0x68, 0x8a, 0x48, 0x17, 0x58, 0x89, 0x1c, 0x20, 0x48, 0x40, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x08, 0x60, 0x1f,
	0xff, 0xff, 0xff, 0xe0, 0x00, 0x73, 0x00, 0x91, 0x34, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8,
	0x00, 0x26, 0x00, 0x0f, 0xa9, 0x60, 0x00, 0x19, 0xad, 0x92, 0x08, 0x8f, 0x6b, 0x96, 0x78, 0x90,
	0xbd, 0x70, 0x68, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x53, 0x33, 0x27, 0xc0,
	0x00, 0x19, 0x08, 0x40, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x74, 0x00, 0x91, 0x35, 0x00, 0x0c,
	0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x26, 0x20, 0x0f, 0xa9, 0x60, 0x00, 0x1a, 0xed, 0x72, 0x08,
	0x83, 0xf5, 0xb6, 0x98, 0x9c, 0x2f, 0x50, 0x48, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x08, 0x40, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x75,
	0x00, 0x91, 0x35, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x26, 0x40, 0x0f, 0xa9, 0x60,
	0x00, 0x09, 0x0d, 0x32, 0x08, 0x85, 0x31, 0x96, 0xb8, 0x9c, 0x2f, 0x50, 0x48, 0x20, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x08, 0x40, 0x1f, 0xff,
	0xff, 0xff, 0xe0, 0x00, 0x76, 0x00, 0x91, 0x36, 0x00, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00,
	0x26, 0x60, 0x0f, 0xa9, 0x60, 0x00, 0x10, 0xb5, 0x72, 0x08, 0x86, 0x71, 0x76, 0xf8, 0x9c, 0x2f,
	0x50, 0x48, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0xc8, 0xf2, 0xa8, 0x20, 0x00,
	0x19, 0x08, 0x40, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x77, 0x00, 0x91, 0x36, 0x80, 0x0c, 0x60,
	0x20, 0x14, 0x2c, 0xc8, 0x00, 0x26, 0x80, 0x0f, 0xa9, 0x60, 0x00, 0x0f, 0x62, 0x92, 0x28, 0x9a,
	0xf9, 0x77, 0x18, 0x9c, 0x2f, 0x50, 0x48, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f,
	0x62, 0x91, 0xc8, 0x20, 0x00, 0x19, 0x08, 0x40, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x78, 0x00,
	0x91, 0x37, 0x00, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x26, 0xa0, 0x0f, 0xa9, 0x60, 0x00,
	0x1c, 0x3f, 0x52, 0x08, 0x9d, 0x98, 0x37, 0x78, 0x9c, 0x2f, 0x50, 0x48, 0x20, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x05, 0x2b, 0x93, 0xf8, 0x20, 0x00, 0x19, 0x08, 0x40, 0x1f, 0xff, 0xff,
	0xff, 0xe0, 0x00, 0x79, 0x00, 0x91, 0x37, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x26,
	0xc0, 0x0f, 0xa9, 0x60, 0x00, 0x1e, 0xcd, 0x11, 0xc8, 0x97, 0x0e, 0xd7, 0xd8, 0x9c, 0x2f, 0x50,
	0x48, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x57, 0x11, 0x58, 0x40, 0x00, 0x19,
	0x08, 0x40, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x7a, 0x00, 0x91, 0x38, 0x00, 0x0c, 0x60, 0x20,
	0x14, 0x2c, 0xc8, 0x00, 0x26, 0xe0, 0x0f, 0xa9, 0x60, 0x00, 0x1d, 0x94, 0x31, 0x68, 0x98, 0x6d,
	0xb7, 0xd8, 0x8f, 0x62, 0x90, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x1c,
	0x3b, 0x58, 0x40, 0x00, 0x19, 0x08, 0x40, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x7b, 0x00, 0x91,
	0x38, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x27, 0x00, 0x0f, 0xa9, 0x60, 0x00, 0x18,
	0x64, 0xb1, 0x28, 0x98, 0x79, 0xb7, 0x78, 0x8f, 0x62, 0x90, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x0f, 0x72, 0x83, 0xd8, 0x60, 0x00, 0x19, 0x08, 0x40, 0x1f, 0xff, 0xff, 0xff,
	0xe0, 0x00,
}

// Packet [71] opcode=0x3e len=530b
var streamingPacket71 = []byte{
	0x3e, 0x00, 0x48, 0x9c, 0x80, 0x06, 0x30, 0x10, 0x14, 0x2c, 0xc8, 0x00, 0x27, 0x20, 0x0f, 0xa9,
	0x60, 0x00, 0x01, 0x41, 0xf1, 0x28, 0x89, 0x19, 0x37, 0x18, 0x8f, 0x62, 0x90, 0x88, 0x20, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x9e, 0x08, 0xb8, 0x60, 0x00, 0x19, 0x08, 0x40, 0x1f,
	0xff, 0xff, 0xff, 0xe0, 0x00, 0x7d, 0x00, 0x91, 0x39, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8,
	0x00, 0x27, 0x40, 0x0f, 0xa9, 0x60, 0x00, 0x0c, 0xce, 0xd1, 0x28, 0x94, 0x91, 0x16, 0xf8, 0x8f,
	0x62, 0x90, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x9e, 0x08, 0xb8, 0x60,
	0x00, 0x19, 0x08, 0x40, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x7e, 0x00, 0x91, 0x3a, 0x00, 0x0c,
	0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x27, 0x60, 0x0f, 0xa9, 0x60, 0x00, 0x1d, 0x97, 0x31, 0x28,
	0x8c, 0xd5, 0xd6, 0x98, 0x91, 0xf8, 0x50, 0x28, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0e, 0x27, 0xa6, 0x98, 0x60, 0x00, 0x19, 0x08, 0x40, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x7f,
	0x00, 0x91, 0x3a, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x27, 0x80, 0x0f, 0xa9, 0x60,
	0x00, 0x0a, 0x57, 0x11, 0x28, 0x81, 0x51, 0xf6, 0xb8, 0x91, 0xf8, 0x50, 0x28, 0x20, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x13, 0xc6, 0xb8, 0x60, 0x00, 0x19, 0x08, 0x40, 0x1f, 0xff,
	0xff, 0xff, 0xe0, 0x00, 0x80, 0x00, 0x91, 0x3b, 0x00, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00,
	0x27, 0xa0, 0x0f, 0xa9, 0x60, 0x00, 0x14, 0x97, 0x11, 0x28, 0x85, 0x2b, 0x96, 0x78, 0x91, 0xf8,
	0x50, 0x28, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x27, 0xa6, 0x98, 0x60, 0x00,
	0x19, 0x08, 0x40, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x81, 0x00, 0x91, 0x3b, 0x80, 0x0c, 0x60,
	0x20, 0x14, 0x2c, 0xc8, 0x00, 0x27, 0xc0, 0x0f, 0xa9, 0x60, 0x00, 0x1d, 0x99, 0x31, 0x08, 0x8e,
	0x33, 0xb6, 0x98, 0x91, 0xf8, 0x57, 0x68, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e,
	0x27, 0xa6, 0x98, 0x60, 0x00, 0x19, 0x08, 0x40, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x82, 0x00,
	0x91, 0x3c, 0x00, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x27, 0xe0, 0x0f, 0xa9, 0x60, 0x00,
	0x1a, 0xf9, 0x71, 0x08, 0x9a, 0xe9, 0x76, 0xd8, 0x91, 0xf8, 0x57, 0x68, 0x20, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x18, 0x6e, 0xa6, 0x78, 0x60, 0x00, 0x19, 0x08, 0x40, 0x1f, 0xff, 0xff,
	0xff, 0xe0, 0x00, 0x83, 0x00, 0x91, 0x3c, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x28,
	0x00, 0x0f, 0xa9, 0x60, 0x00, 0x0a, 0x54, 0x11, 0x08, 0x82, 0x95, 0xd7, 0xb8, 0x83, 0xf0, 0xb7,
	0x68, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x57, 0x01, 0x58, 0x60, 0x00, 0x19,
	0x08, 0x40, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x84, 0x00, 0x91, 0x3d, 0x00, 0x0c, 0x60, 0x20,
	0x14, 0x2c, 0xc8, 0x00, 0x28, 0x20, 0x0f, 0xa9, 0x60, 0x00, 0x11, 0xf4, 0x51, 0x28, 0x8f, 0x7a,
	0x97, 0xd8, 0x85, 0x2b, 0x97, 0x68, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x4a,
	0xe1, 0x38, 0x60, 0x00, 0x19, 0x08, 0x40, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x85, 0x00, 0x91,
	0x3d, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x28, 0x40, 0x0f, 0xa9, 0x60, 0x00, 0x1a,
	0xec, 0x72, 0x08, 0x85, 0x39, 0x97, 0xd8, 0x82, 0x95, 0xd7, 0x68, 0x20, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1c, 0x2f, 0x45, 0x18, 0x40, 0x00, 0x19, 0x08, 0x40, 0x1f, 0xff, 0xff, 0xff,
	0xe0, 0x00,
}

// Packet [73] opcode=0x43 len=530b
var streamingPacket73 = []byte{
	0x43, 0x00, 0x48, 0x9f, 0x00, 0x06, 0x30, 0x10, 0x14, 0x2c, 0xc8, 0x00, 0x28, 0x60, 0x0f, 0xa9,
	0x60, 0x00, 0x1c, 0x2c, 0x52, 0x28, 0x80, 0x15, 0x17, 0xb8, 0x82, 0x95, 0xd7, 0x68, 0x20, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x7e, 0xa4, 0x58, 0x40, 0x00, 0x19, 0x08, 0x40, 0x1f,
	0xff, 0xff, 0xff, 0xe0, 0x00, 0x87, 0x00, 0x91, 0x3e, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8,
	0x00, 0x28, 0x80, 0x0f, 0xa9, 0x60, 0x00, 0x09, 0x0c, 0x32, 0x28, 0x9d, 0x88, 0x36, 0x98, 0x86,
	0x66, 0x77, 0x68, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0xf8, 0x5e, 0xb7, 0xa0,
	0x00, 0x19, 0x08, 0x40, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x88, 0x00, 0x91, 0x3f, 0x00, 0x0c,
	0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x28, 0xa0, 0x0f, 0xa9, 0x60, 0x00, 0x1c, 0x2c, 0x52, 0x28,
	0x81, 0x51, 0xf6, 0x58, 0x80, 0x00, 0x17, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0e, 0x27, 0xa1, 0x47, 0xe0, 0x00, 0x19, 0x08, 0x40, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x89,
	0x00, 0x91, 0x3f, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x28, 0xc0, 0x0f, 0xc9, 0x60,
	0x00, 0x1c, 0x2d, 0x52, 0x08, 0x8b, 0x9a, 0xf6, 0x98, 0x87, 0xa1, 0x50, 0x68, 0x20, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0xf4, 0x76, 0x78, 0x40, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff,
	0xff, 0xff, 0xe0, 0x00, 0x8a, 0x00, 0x91, 0x40, 0x00, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00,
	0x28, 0xe0, 0x0f, 0xc9, 0x60, 0x00, 0x00, 0x0d, 0x12, 0x08, 0x86, 0x6f, 0x76, 0x98, 0x89, 0x1c,
	0x30, 0x48, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0xf4, 0x76, 0x78, 0x40, 0x00,
	0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x8b, 0x00, 0x91, 0x40, 0x80, 0x0c, 0x60,
	0x20, 0x14, 0x2c, 0xc8, 0x00, 0x29, 0x00, 0x0f, 0xc9, 0x60, 0x00, 0x1a, 0xed, 0x72, 0x08, 0x87,
	0xb1, 0x56, 0x78, 0x89, 0x1c, 0x30, 0x48, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a,
	0xf4, 0x76, 0x78, 0x40, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x8c, 0x00,
	0x91, 0x41, 0x00, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x29, 0x20, 0x0f, 0xc9, 0x60, 0x00,
	0x06, 0x6d, 0x72, 0x08, 0x8a, 0x46, 0x16, 0x78, 0x89, 0x1c, 0x30, 0x48, 0x20, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0c, 0xcc, 0xd6, 0x78, 0x40, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff,
	0xff, 0xe0, 0x00, 0x8d, 0x00, 0x91, 0x41, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x29,
	0x40, 0x10, 0x29, 0x60, 0x00, 0x18, 0x6c, 0xb2, 0x08, 0x81, 0x40, 0xf6, 0x98, 0x93, 0x53, 0x32,
	0xa8, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x62, 0x96, 0x48, 0x40, 0x00, 0x1e,
	0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x8e, 0x00, 0x91, 0x42, 0x00, 0x0c, 0x60, 0x20,
	0x14, 0x2c, 0xc8, 0x00, 0x29, 0x60, 0x10, 0x29, 0x60, 0x00, 0x1c, 0x26, 0x52, 0x28, 0x80, 0x1e,
	0x16, 0x58, 0x94, 0x8e, 0x11, 0xe8, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x8f, 0x00, 0x91,
	0x42, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x29, 0x80, 0x10, 0x29, 0x60, 0x00, 0x19,
	0xa1, 0x92, 0x28, 0x89, 0x03, 0x36, 0xb8, 0x82, 0x95, 0xd1, 0xe8, 0x20, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff,
	0xe0, 0x00,
}

// Packet [75] opcode=0x48 len=530b
var streamingPacket75 = []byte{
	0x48, 0x00, 0x48, 0xa1, 0x80, 0x06, 0x30, 0x10, 0x14, 0x2c, 0xc8, 0x00, 0x29, 0xa0, 0x1d, 0xe1,
	0x20, 0x00, 0x18, 0x60, 0xb2, 0x48, 0x8f, 0x71, 0x96, 0x78, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x53, 0x33, 0x27, 0xc0, 0x00, 0x1e, 0x08, 0x20, 0x1f,
	0xff, 0xff, 0xff, 0xe0, 0x00, 0x91, 0x00, 0x91, 0x43, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8,
	0x00, 0x29, 0xc0, 0x1c, 0xe1, 0x20, 0x00, 0x15, 0xda, 0xf2, 0x68, 0x93, 0x41, 0x36, 0xb8, 0x86,
	0x66, 0x6d, 0x68, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xbd, 0x76, 0xb8, 0x40,
	0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x92, 0x00, 0x91, 0x44, 0x00, 0x0c,
	0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x29, 0xe0, 0x1d, 0xe1, 0x20, 0x00, 0x06, 0x7c, 0x72, 0x28,
	0x99, 0xb1, 0x96, 0x78, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0a, 0x57, 0x13, 0xc7, 0xc0, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x93,
	0x00, 0x91, 0x44, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x2a, 0x00, 0x1d, 0x41, 0x20,
	0x00, 0x1d, 0x91, 0x32, 0x48, 0x87, 0xad, 0x56, 0x78, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x4a, 0xe6, 0x88, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff,
	0xff, 0xff, 0xe0, 0x00, 0x94, 0x00, 0x91, 0x45, 0x00, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00,
	0x2a, 0x20, 0x1d, 0x61, 0x20, 0x00, 0x05, 0x2d, 0x92, 0x48, 0x9d, 0x8d, 0x36, 0x78, 0x9a, 0xf4,
	0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x86, 0x06, 0x88, 0x60, 0x00,
	0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x95, 0x00, 0x91, 0x45, 0x80, 0x0c, 0x60,
	0x20, 0x14, 0x2c, 0xc8, 0x00, 0x2a, 0x40, 0x1d, 0x81, 0x20, 0x00, 0x1d, 0x86, 0x32, 0x48, 0x90,
	0xad, 0x76, 0x78, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,
	0xa5, 0x66, 0x88, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x96, 0x00,
	0x91, 0x46, 0x00, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x2a, 0x60, 0x18, 0x00, 0xe0, 0x00,
	0x1a, 0xf5, 0x72, 0x08, 0x9c, 0x2a, 0x56, 0x98, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x15, 0xc0, 0xfc, 0x38, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff,
	0xff, 0xe0, 0x00, 0x97, 0x00, 0x91, 0x46, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x2a,
	0x80, 0x1b, 0x80, 0xe0, 0x00, 0x00, 0x0d, 0x12, 0x28, 0x9d, 0x81, 0x36, 0xb8, 0x80, 0x00, 0x0d,
	0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0xc5, 0x06, 0x78, 0x60, 0x00, 0x1e,
	0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x98, 0x00, 0x91, 0x47, 0x00, 0x0c, 0x60, 0x20,
	0x14, 0x2c, 0xc8, 0x00, 0x2a, 0xa0, 0x1b, 0x80, 0xe0, 0x00, 0x09, 0x05, 0x32, 0x48, 0x8e, 0x3f,
	0xb6, 0x58, 0x80, 0x00, 0x0d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0xdc,
	0xd6, 0x68, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x99, 0x00, 0x91,
	0x47, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x2a, 0xc0, 0x18, 0x60, 0xe0, 0x00, 0x05,
	0x2c, 0x92, 0x28, 0x9c, 0x31, 0x56, 0x78, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x15, 0xd0, 0xf6, 0x88, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff,
	0xe0, 0x00,
}

// Packet [77] opcode=0x4d len=530b
var streamingPacket77 = []byte{
	0x4d, 0x00, 0x48, 0xa4, 0x00, 0x06, 0x30, 0x10, 0x14, 0x2c, 0xc8, 0x00, 0x2a, 0xe0, 0x18, 0x80,
	0xe0, 0x00, 0x05, 0x30, 0x92, 0x28, 0x91, 0xf1, 0x56, 0x78, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0xcc, 0xd6, 0x88, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f,
	0xff, 0xff, 0xff, 0xe0, 0x00, 0x9b, 0x00, 0x91, 0x48, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8,
	0x00, 0x2b, 0x00, 0x06, 0xe1, 0x60, 0x00, 0x09, 0x13, 0x32, 0x28, 0x97, 0x0f, 0xd6, 0x98, 0x9a,
	0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x37, 0x46, 0x28, 0x60,
	0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x9c, 0x00, 0x91, 0x49, 0x00, 0x0c,
	0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x2b, 0x20, 0x06, 0xe1, 0x60, 0x00, 0x0c, 0xd2, 0xd2, 0x28,
	0x8b, 0x93, 0xf6, 0x98, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x1e, 0xc1, 0x16, 0x68, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x9d,
	0x00, 0x91, 0x49, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x2b, 0x40, 0x0f, 0xc1, 0x60,
	0x00, 0x14, 0x8e, 0x12, 0x08, 0x98, 0x62, 0xb6, 0xf8, 0x89, 0x1c, 0x2e, 0xc8, 0x20, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x8e, 0x11, 0xd8, 0x40, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff,
	0xff, 0xff, 0xe0, 0x00, 0x9e, 0x00, 0x91, 0x4a, 0x00, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00,
	0x2b, 0x60, 0x18, 0x60, 0xe0, 0x00, 0x1a, 0xf0, 0x72, 0x28, 0x87, 0xad, 0x56, 0x78, 0x9d, 0x8a,
	0x2d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x7e, 0xa6, 0x88, 0x60, 0x00,
	0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x9f, 0x00, 0x91, 0x4a, 0x80, 0x0c, 0x60,
	0x20, 0x14, 0x2c, 0xc8, 0x00, 0x2b, 0x80, 0x1c, 0x41, 0x20, 0x00, 0x05, 0x2c, 0x92, 0x48, 0x89,
	0x0f, 0x36, 0x98, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e,
	0xc5, 0x06, 0xd8, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xa0, 0x00,
	0x91, 0x4b, 0x00, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x2b, 0xa0, 0x18, 0xe0, 0xe0, 0x00,
	0x00, 0x17, 0x12, 0x48, 0x9d, 0x9e, 0x36, 0x78, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0a, 0x4f, 0x06, 0x68, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff,
	0xff, 0xe0, 0x00, 0xa1, 0x00, 0x91, 0x4b, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x2b,
	0xc0, 0x19, 0x80, 0xe0, 0x00, 0x07, 0xa7, 0x52, 0x48, 0x80, 0x1e, 0x16, 0x78, 0x9a, 0xf4, 0x6d,
	0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x43, 0x26, 0x68, 0x60, 0x00, 0x1e,
	0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xa2, 0x00, 0x91, 0x4c, 0x00, 0x0c, 0x60, 0x20,
	0x14, 0x2c, 0xc8, 0x00, 0x2b, 0xe0, 0x19, 0x80, 0xe0, 0x00, 0x15, 0xd8, 0xf2, 0x48, 0x85, 0x2d,
	0x96, 0x78, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x27,
	0xa6, 0x68, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xa3, 0x00, 0x91,
	0x4c, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x2c, 0x00, 0x18, 0xe0, 0xe0, 0x00, 0x0b,
	0x9c, 0xf2, 0x48, 0x8f, 0x6d, 0x96, 0x78, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1d, 0x92, 0x26, 0x68, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff,
	0xe0, 0x00,
}

// Packet [79] opcode=0x52 len=530b
var streamingPacket79 = []byte{
	0x52, 0x00, 0x48, 0xa6, 0x80, 0x06, 0x30, 0x10, 0x14, 0x2c, 0xc8, 0x00, 0x2c, 0x20, 0x19, 0x60,
	0xe0, 0x00, 0x19, 0xba, 0x92, 0x68, 0x86, 0x6c, 0x76, 0x78, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x88, 0x40, 0x00, 0x1e, 0x08, 0x20, 0x1f,
	0xff, 0xff, 0xff, 0xe0, 0x00, 0xa5, 0x00, 0x91, 0x4d, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8,
	0x00, 0x2c, 0x40, 0x19, 0x40, 0xe0, 0x00, 0x03, 0xfa, 0xb2, 0x68, 0x87, 0xb8, 0x56, 0x78, 0x9a,
	0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x88, 0x40,
	0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xa6, 0x00, 0x91, 0x4e, 0x00, 0x0c,
	0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x2c, 0x60, 0x19, 0x20, 0xe0, 0x00, 0x03, 0xfa, 0xb2, 0x68,
	0x91, 0xf4, 0x56, 0x78, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x16, 0x88, 0x40, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xa7,
	0x00, 0x91, 0x4e, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x2c, 0x80, 0x1d, 0xc1, 0x20,
	0x00, 0x1e, 0xcf, 0x12, 0x28, 0x8e, 0x2f, 0xb6, 0x98, 0x9e, 0xc5, 0x0d, 0x88, 0x20, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0xa6, 0x48, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff,
	0xff, 0xff, 0xe0, 0x00, 0xa8, 0x00, 0x91, 0x4f, 0x00, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00,
	0x2c, 0xa0, 0x1d, 0x01, 0x20, 0x00, 0x05, 0x3b, 0x92, 0x28, 0x87, 0xb4, 0x56, 0x98, 0x86, 0x66,
	0x6d, 0x68, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xa1, 0x5a, 0xf7, 0xc0, 0x00,
	0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xa9, 0x00, 0x91, 0x4f, 0x80, 0x0c, 0x60,
	0x20, 0x14, 0x2c, 0xc8, 0x00, 0x2c, 0xc0, 0x1d, 0xc1, 0x20, 0x00, 0x0c, 0xce, 0xd2, 0x28, 0x98,
	0x73, 0xb6, 0x98, 0x9c, 0x2f, 0x4d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a,
	0x57, 0x1b, 0xd7, 0xe0, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xaa, 0x00,
	0x91, 0x50, 0x00, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x2c, 0xe0, 0x18, 0x00, 0xe0, 0x00,
	0x1c, 0x35, 0x52, 0x08, 0x97, 0x0e, 0xd6, 0x78, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x15, 0xc0, 0xfc, 0x38, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff,
	0xff, 0xe0, 0x00, 0xab, 0x00, 0x91, 0x50, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x2d,
	0x00, 0x1b, 0x80, 0xe0, 0x00, 0x1d, 0x99, 0x32, 0x28, 0x9e, 0xc1, 0x16, 0xb8, 0x80, 0x00, 0x0d,
	0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x03, 0xc6, 0x98, 0x60, 0x00, 0x1e,
	0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xac, 0x00, 0x91, 0x51, 0x00, 0x0c, 0x60, 0x20,
	0x14, 0x2c, 0xc8, 0x00, 0x2d, 0x20, 0x1c, 0x41, 0x20, 0x00, 0x0f, 0x70, 0x92, 0x48, 0x91, 0xef,
	0x56, 0x98, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x0c,
	0x26, 0xb8, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xad, 0x00, 0x91,
	0x51, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x2d, 0x40, 0x1c, 0x41, 0x20, 0x00, 0x0f,
	0x74, 0x92, 0x48, 0x86, 0x6f, 0x76, 0x98, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x18, 0x7e, 0xa6, 0x98, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff,
	0xe0, 0x00,
}

// Packet [81] opcode=0x57 len=530b
var streamingPacket81 = []byte{
	0x57, 0x00, 0x48, 0xa9, 0x00, 0x06, 0x30, 0x10, 0x14, 0x2c, 0xc8, 0x00, 0x2d, 0x60, 0x1c, 0x41,
	0x20, 0x00, 0x05, 0x38, 0x92, 0x48, 0x85, 0x2f, 0x96, 0x98, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x06, 0xb8, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f,
	0xff, 0xff, 0xff, 0xe0, 0x00, 0xaf, 0x00, 0x91, 0x52, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8,
	0x00, 0x2d, 0x80, 0x17, 0xa0, 0xe0, 0x00, 0x0a, 0x4b, 0x12, 0x48, 0x94, 0x9e, 0x16, 0x78, 0x9a,
	0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x37, 0xa6, 0xb8, 0x60,
	0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xb0, 0x00, 0x91, 0x53, 0x00, 0x0c,
	0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x2d, 0xa0, 0x17, 0xa0, 0xe0, 0x00, 0x0a, 0x4f, 0x12, 0x48,
	0x89, 0x1e, 0x36, 0x78, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x19, 0xb9, 0x86, 0x98, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xb1,
	0x00, 0x91, 0x53, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x2d, 0xc0, 0x17, 0xa0, 0xe0,
	0x00, 0x00, 0x13, 0x12, 0x48, 0x93, 0x5e, 0x36, 0x78, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x5a, 0xe6, 0x98, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff,
	0xff, 0xff, 0xe0, 0x00, 0xb2, 0x00, 0x91, 0x54, 0x00, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00,
	0x2d, 0xe0, 0x1c, 0xe1, 0x20, 0x00, 0x00, 0x1b, 0x12, 0x68, 0x9e, 0xdd, 0x16, 0x98, 0x86, 0x66,
	0x6d, 0x68, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x91, 0xf6, 0xb8, 0x40, 0x00,
	0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xb3, 0x00, 0x91, 0x54, 0x80, 0x0c, 0x60,
	0x20, 0x14, 0x2c, 0xc8, 0x00, 0x2e, 0x00, 0x1c, 0xe1, 0x20, 0x00, 0x15, 0xda, 0xf2, 0x68, 0x9e,
	0xd9, 0x16, 0x98, 0x86, 0x66, 0x6d, 0x68, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b,
	0x91, 0xf6, 0xb8, 0x40, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xb4, 0x00,
	0x91, 0x55, 0x00, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x2e, 0x20, 0x1c, 0xe1, 0x20, 0x00,
	0x15, 0xda, 0xf2, 0x68, 0x8a, 0x55, 0x16, 0x98, 0x86, 0x66, 0x6d, 0x68, 0x20, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x98, 0x40, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff,
	0xff, 0xe0, 0x00, 0xb5, 0x00, 0x91, 0x55, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x2e,
	0x40, 0x1d, 0xa1, 0x20, 0x00, 0x00, 0x1b, 0x12, 0x68, 0x81, 0x50, 0xf6, 0x98, 0x9a, 0xf4, 0x6d,
	0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x03, 0xd6, 0x98, 0x40, 0x00, 0x1e,
	0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xb6, 0x00, 0x91, 0x56, 0x00, 0x0c, 0x60, 0x20,
	0x14, 0x2c, 0xc8, 0x00, 0x2e, 0x60, 0x1d, 0xa1, 0x20, 0x00, 0x00, 0x1b, 0x12, 0x68, 0x8c, 0xcc,
	0xd6, 0x98, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x03,
	0xd6, 0x98, 0x40, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xb7, 0x00, 0x91,
	0x56, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x2e, 0x80, 0x1d, 0xa1, 0x20, 0x00, 0x15,
	0xda, 0xf2, 0x68, 0x83, 0xe8, 0xb6, 0x98, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x17, 0x03, 0xd6, 0x98, 0x40, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff,
	0xe0, 0x00,
}

// Packet [83] opcode=0x5c len=530b
var streamingPacket83 = []byte{
	0x5c, 0x00, 0x48, 0xab, 0x80, 0x06, 0x30, 0x10, 0x14, 0x2c, 0xc8, 0x00, 0x2e, 0xa0, 0x1d, 0xe1,
	0x20, 0x00, 0x0a, 0x5b, 0x12, 0x68, 0x98, 0x64, 0xb6, 0x98, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x95, 0xd6, 0xb8, 0x40, 0x00, 0x1e, 0x08, 0x20, 0x1f,
	0xff, 0xff, 0xff, 0xe0, 0x00, 0xb9, 0x00, 0x91, 0x57, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8,
	0x00, 0x2e, 0xc0, 0x1d, 0xa1, 0x20, 0x00, 0x09, 0x1b, 0x32, 0x68, 0x8e, 0x20, 0xb6, 0x98, 0x9a,
	0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0x03, 0xd6, 0x98, 0x40,
	0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xba, 0x00, 0x91, 0x58, 0x00, 0x0c,
	0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x2e, 0xe0, 0x1d, 0xe1, 0x20, 0x00, 0x01, 0x5a, 0xf2, 0x68,
	0x99, 0xbc, 0x96, 0x78, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x02, 0x95, 0xd6, 0xb8, 0x40, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xbb,
	0x00, 0x91, 0x58, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x2f, 0x00, 0x18, 0xc0, 0xe0,
	0x00, 0x03, 0xfa, 0xb2, 0x68, 0x8e, 0x3e, 0xb6, 0x58, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x66, 0x6a, 0x68, 0x00, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff,
	0xff, 0xff, 0xe0, 0x00, 0xbc, 0x00, 0x91, 0x59, 0x00, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00,
	0x2f, 0x20, 0x18, 0xc0, 0xe0, 0x00, 0x05, 0x36, 0x92, 0x68, 0x8b, 0x9e, 0xf6, 0x58, 0x9a, 0xf4,
	0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x66, 0x6a, 0x68, 0x00, 0x00,
	0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xbd, 0x00, 0x91, 0x59, 0x80, 0x0c, 0x60,
	0x20, 0x14, 0x2c, 0xc8, 0x00, 0x2f, 0x40, 0x18, 0xc0, 0xe0, 0x00, 0x10, 0xb2, 0x72, 0x68, 0x9d,
	0x9f, 0x36, 0x58, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06,
	0x66, 0x6a, 0x68, 0x00, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xbe, 0x00,
	0x91, 0x5a, 0x00, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x2f, 0x60, 0x18, 0xc0, 0xe0, 0x00,
	0x10, 0xae, 0x72, 0x68, 0x91, 0xff, 0x56, 0x58, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x06, 0x66, 0x6a, 0x68, 0x00, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff,
	0xff, 0xe0, 0x00, 0xbf, 0x00, 0x91, 0x5a, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x2f,
	0x80, 0x18, 0xc0, 0xe0, 0x00, 0x10, 0xaa, 0x72, 0x68, 0x8f, 0x7f, 0x96, 0x58, 0x9a, 0xf4, 0x6d,
	0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x66, 0x6a, 0x68, 0x00, 0x00, 0x1e,
	0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xc0, 0x00, 0x91, 0x5b, 0x00, 0x0c, 0x60, 0x20,
	0x14, 0x2c, 0xc8, 0x00, 0x2f, 0xa0, 0x18, 0xc0, 0xe0, 0x00, 0x1c, 0x26, 0x52, 0x68, 0x90, 0xbf,
	0x76, 0x58, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x66,
	0x6a, 0x68, 0x00, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xc1, 0x00, 0x91,
	0x5b, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x2f, 0xc0, 0x19, 0x20, 0xe0, 0x00, 0x03,
	0xfa, 0xb2, 0x68, 0x9c, 0x30, 0x56, 0x78, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x88, 0x40, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff,
	0xe0, 0x00,
}

// Packet [85] opcode=0x61 len=530b
var streamingPacket85 = []byte{
	0x61, 0x00, 0x48, 0xae, 0x00, 0x06, 0x30, 0x10, 0x14, 0x2c, 0xc8, 0x00, 0x2f, 0xe0, 0x1b, 0x80,
	0xe0, 0x00, 0x00, 0x1e, 0x12, 0x48, 0x87, 0xbf, 0x56, 0x58, 0x80, 0x00, 0x0d, 0x88, 0x20, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x72, 0xb6, 0x88, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f,
	0xff, 0xff, 0xff, 0xe0, 0x00, 0xc3, 0x00, 0x91, 0x5c, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8,
	0x00, 0x30, 0x00, 0x1b, 0x80, 0xe0, 0x00, 0x0e, 0x31, 0xb2, 0x48, 0x9a, 0xff, 0x76, 0x58, 0x80,
	0x00, 0x0d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x5e, 0xf6, 0x68, 0x60,
	0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xc4, 0x00, 0x91, 0x5d, 0x00, 0x0c,
	0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x30, 0x20, 0x1b, 0x80, 0xe0, 0x00, 0x06, 0x60, 0x72, 0x28,
	0x86, 0x61, 0x76, 0xb8, 0x80, 0x00, 0x0d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x14, 0x9e, 0x06, 0x78, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xc5,
	0x00, 0x91, 0x5d, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x30, 0x40, 0x1d, 0x61, 0x20,
	0x00, 0x0c, 0xc9, 0xd2, 0x48, 0x91, 0xed, 0x56, 0x78, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0xe8, 0x46, 0xa8, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff,
	0xff, 0xff, 0xe0, 0x00, 0xc6, 0x00, 0x91, 0x5e, 0x00, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00,
	0x30, 0x60, 0x1e, 0x21, 0x20, 0x00, 0x07, 0xa7, 0x52, 0x28, 0x9c, 0x3f, 0x56, 0x58, 0x8b, 0x91,
	0xed, 0xc8, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x62, 0x96, 0xb8, 0x40, 0x00,
	0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xc7, 0x00, 0x91, 0x5e, 0x80, 0x0c, 0x60,
	0x20, 0x14, 0x2c, 0xc8, 0x00, 0x30, 0x80, 0x1e, 0x21, 0x20, 0x00, 0x07, 0xa3, 0x52, 0x28, 0x91,
	0xff, 0x56, 0x58, 0x8b, 0x91, 0xed, 0xc8, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f,
	0x62, 0x96, 0xb8, 0x40, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xc8, 0x00,
	0x91, 0x5f, 0x00, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x30, 0xa0, 0x1e, 0x21, 0x20, 0x00,
	0x1d, 0x9f, 0x32, 0x08, 0x90, 0xbf, 0x76, 0x58, 0x8b, 0x91, 0xed, 0xc8, 0x20, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0f, 0x62, 0x96, 0xb8, 0x40, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff,
	0xff, 0xe0, 0x00, 0xc9, 0x00, 0x91, 0x5f, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x30,
	0xc0, 0x1e, 0x21, 0x20, 0x00, 0x07, 0xab, 0x52, 0x28, 0x9a, 0xff, 0x76, 0x58, 0x8b, 0x91, 0xed,
	0xc8, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x62, 0x96, 0xb8, 0x40, 0x00, 0x1e,
	0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xca, 0x00, 0x91, 0x60, 0x00, 0x0c, 0x60, 0x20,
	0x14, 0x2c, 0xc8, 0x00, 0x30, 0xe0, 0x18, 0x80, 0xe0, 0x00, 0x05, 0x2c, 0x92, 0x28, 0x9c, 0x2d,
	0x56, 0x78, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x2b,
	0xa0, 0xe8, 0x80, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xcb, 0x00, 0x91,
	0x60, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x31, 0x00, 0x18, 0x80, 0xe0, 0x00, 0x07,
	0xb8, 0x52, 0x28, 0x87, 0xb1, 0x56, 0x78, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x0c, 0xcc, 0xd6, 0x88, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff,
	0xe0, 0x00,
}

// Packet [87] opcode=0x66 len=530b
var streamingPacket87 = []byte{
	0x66, 0x00, 0x48, 0xb0, 0x80, 0x06, 0x30, 0x10, 0x14, 0x2c, 0xc8, 0x00, 0x31, 0x20, 0x18, 0x60,
	0xe0, 0x00, 0x07, 0xb4, 0x52, 0x28, 0x91, 0xf1, 0x56, 0x78, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0xd0, 0xf6, 0x88, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f,
	0xff, 0xff, 0xff, 0xe0, 0x00, 0xcd, 0x00, 0x91, 0x61, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8,
	0x00, 0x31, 0x40, 0x18, 0x60, 0xe0, 0x00, 0x10, 0xb8, 0x72, 0x28, 0x93, 0x4d, 0x36, 0x78, 0x9d,
	0x8a, 0x2d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x7e, 0xa6, 0x88, 0x60,
	0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xce, 0x00, 0x91, 0x62, 0x00, 0x0c,
	0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x31, 0x60, 0x18, 0x80, 0xe0, 0x00, 0x07, 0xb4, 0x52, 0x28,
	0x9d, 0x8d, 0x36, 0x78, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x05, 0x23, 0x80, 0xe8, 0x80, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xcf,
	0x00, 0x91, 0x62, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x31, 0x80, 0x1d, 0x01, 0x20,
	0x00, 0x09, 0x17, 0x32, 0x28, 0x87, 0xb4, 0x56, 0x98, 0x86, 0x66, 0x6d, 0x68, 0x20, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x53, 0x33, 0x37, 0xe0, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff,
	0xff, 0xff, 0xe0, 0x00, 0xd0, 0x00, 0x91, 0x63, 0x00, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00,
	0x31, 0xa0, 0x1d, 0x01, 0x20, 0x00, 0x11, 0xff, 0x52, 0x28, 0x87, 0xb4, 0x56, 0x98, 0x86, 0x66,
	0x6d, 0x68, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0xf8, 0x4e, 0xb7, 0xa0, 0x00,
	0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xd1, 0x00, 0x91, 0x63, 0x80, 0x0c, 0x60,
	0x20, 0x14, 0x2c, 0xc8, 0x00, 0x31, 0xc0, 0x06, 0xe1, 0x60, 0x00, 0x09, 0x17, 0x32, 0x28, 0x80,
	0x10, 0x16, 0x98, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
	0xe8, 0xa6, 0x48, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xd2, 0x00,
	0x91, 0x64, 0x00, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x31, 0xe0, 0x06, 0xe1, 0x60, 0x00,
	0x1d, 0x9b, 0x32, 0x28, 0x9e, 0xd0, 0x16, 0x98, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x13, 0x4b, 0x26, 0x68, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff,
	0xff, 0xe0, 0x00, 0xd3, 0x00, 0x91, 0x64, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x32,
	0x00, 0x06, 0xe1, 0x60, 0x00, 0x09, 0x1f, 0x32, 0x28, 0x89, 0x10, 0x36, 0x98, 0x9a, 0xf4, 0x6d,
	0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0xfc, 0x66, 0x68, 0x60, 0x00, 0x1e,
	0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xd4, 0x00, 0x91, 0x65, 0x00, 0x0c, 0x60, 0x20,
	0x14, 0x2c, 0xc8, 0x00, 0x32, 0x20, 0x1d, 0xe1, 0x20, 0x00, 0x05, 0x20, 0x92, 0x48, 0x90, 0xad,
	0x76, 0x78, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0xa1,
	0x86, 0x88, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xd5, 0x00, 0x91,
	0x65, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x32, 0x40, 0x1d, 0xe1, 0x20, 0x00, 0x06,
	0x7c, 0x72, 0x28, 0x9a, 0xed, 0x76, 0x78, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x13, 0x4b, 0x26, 0x88, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff,
	0xe0, 0x00,
}

// Packet [89] opcode=0x6b len=530b
var streamingPacket89 = []byte{
	0x6b, 0x00, 0x48, 0xb3, 0x00, 0x06, 0x30, 0x10, 0x14, 0x2c, 0xc8, 0x00, 0x32, 0x60, 0x1b, 0x80,
	0xe0, 0x00, 0x05, 0x2a, 0x92, 0x48, 0x8e, 0x22, 0xb6, 0x98, 0x80, 0x00, 0x0d, 0x88, 0x20, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x16, 0x68, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f,
	0xff, 0xff, 0xff, 0xe0, 0x00, 0xd7, 0x00, 0x91, 0x66, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8,
	0x00, 0x32, 0x80, 0x1b, 0x80, 0xe0, 0x00, 0x14, 0x97, 0x12, 0x48, 0x81, 0x42, 0xf6, 0x98, 0x80,
	0x00, 0x0d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e, 0xdd, 0x16, 0x68, 0x60,
	0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xd8, 0x00, 0x91, 0x67, 0x00, 0x0c,
	0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x32, 0xa0, 0x1b, 0x80, 0xe0, 0x00, 0x13, 0x45, 0x32, 0x68,
	0x9d, 0x95, 0x36, 0x98, 0x80, 0x00, 0x0d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x01, 0x5e, 0xf6, 0x68, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xd9,
	0x00, 0x91, 0x67, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x32, 0xc0, 0x19, 0x80, 0xe0,
	0x00, 0x10, 0xb5, 0x72, 0x48, 0x93, 0x41, 0x36, 0xb8, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x43, 0x26, 0x68, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff,
	0xff, 0xff, 0xe0, 0x00, 0xda, 0x00, 0x91, 0x68, 0x00, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00,
	0x32, 0xe0, 0x17, 0xa0, 0xe0, 0x00, 0x11, 0xf9, 0x52, 0x48, 0x87, 0xa1, 0x56, 0xb8, 0x9a, 0xf4,
	0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x37, 0xa6, 0xb8, 0x60, 0x00,
	0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xdb, 0x00, 0x91, 0x68, 0x80, 0x0c, 0x60,
	0x20, 0x14, 0x2c, 0xc8, 0x00, 0x33, 0x00, 0x17, 0xa0, 0xe0, 0x00, 0x07, 0xbd, 0x52, 0x48, 0x86,
	0x61, 0x76, 0xb8, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x5a, 0xe6, 0x98, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xdc, 0x00,
	0x91, 0x69, 0x00, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x33, 0x20, 0x17, 0xa0, 0xe0, 0x00,
	0x13, 0x41, 0x32, 0x68, 0x9a, 0xe1, 0x76, 0xb8, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x01, 0x5a, 0xe6, 0x98, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff,
	0xff, 0xe0, 0x00, 0xdd, 0x00, 0x91, 0x69, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x33,
	0x40, 0x18, 0xe0, 0xe0, 0x00, 0x1e, 0xc5, 0x12, 0x68, 0x9a, 0xe1, 0x76, 0xb8, 0x9a, 0xf4, 0x6d,
	0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x4f, 0x06, 0x68, 0x60, 0x00, 0x1e,
	0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xde, 0x00, 0x91, 0x6a, 0x00, 0x0c, 0x60, 0x20,
	0x14, 0x2c, 0xc8, 0x00, 0x33, 0x60, 0x19, 0x80, 0xe0, 0x00, 0x11, 0xe9, 0x52, 0x68, 0x90, 0xa1,
	0x76, 0xb8, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x27,
	0xa6, 0x68, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xdf, 0x00, 0x91,
	0x6a, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x33, 0x80, 0x18, 0xe0, 0xe0, 0x00, 0x11,
	0xed, 0x52, 0x68, 0x9a, 0xe1, 0x76, 0xb8, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1d, 0x92, 0x26, 0x68, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff,
	0xe0, 0x00,
}

// Packet [91] opcode=0x70 len=530b
var streamingPacket91 = []byte{
	0x70, 0x00, 0x48, 0xb5, 0x80, 0x06, 0x30, 0x10, 0x14, 0x2c, 0xc8, 0x00, 0x33, 0xa0, 0x19, 0x40,
	0xe0, 0x00, 0x07, 0xa3, 0x52, 0x68, 0x83, 0xf0, 0xb6, 0x98, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xa1, 0x4a, 0xf7, 0xe0, 0x00, 0x1e, 0x08, 0x20, 0x1f,
	0xff, 0xff, 0xff, 0xe0, 0x00, 0xe1, 0x00, 0x91, 0x6b, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8,
	0x00, 0x33, 0xc0, 0x19, 0x60, 0xe0, 0x00, 0x1d, 0x8b, 0x32, 0x68, 0x8c, 0xd0, 0xd6, 0x98, 0x9a,
	0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0xc8, 0xf4, 0x37, 0xe0,
	0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xe2, 0x00, 0x91, 0x6c, 0x00, 0x0c,
	0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x33, 0xe0, 0x1d, 0xe1, 0x20, 0x00, 0x0f, 0x63, 0x92, 0x48,
	0x9d, 0x90, 0x36, 0x98, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0a, 0x5f, 0x06, 0x48, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xe3,
	0x00, 0x91, 0x6c, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x34, 0x00, 0x1d, 0xe1, 0x20,
	0x00, 0x03, 0xe7, 0xb2, 0x48, 0x87, 0xb0, 0x56, 0x98, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x96, 0x06, 0x68, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff,
	0xff, 0xff, 0xe0, 0x00, 0xe4, 0x00, 0x91, 0x6d, 0x00, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00,
	0x34, 0x20, 0x1d, 0xe1, 0x20, 0x00, 0x1a, 0xe7, 0x72, 0x48, 0x9a, 0xf4, 0x76, 0x98, 0x9a, 0xf4,
	0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0xf8, 0x4e, 0xb7, 0xa0, 0x00,
	0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xe5, 0x00, 0x91, 0x6d, 0x80, 0x0c, 0x60,
	0x20, 0x14, 0x2c, 0xc8, 0x00, 0x34, 0x40, 0x1d, 0xe1, 0x20, 0x00, 0x10, 0xa3, 0x72, 0x48, 0x90,
	0xb4, 0x76, 0x98, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a,
	0x57, 0x13, 0xc7, 0xc0, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xe6, 0x00,
	0x91, 0x6e, 0x00, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x34, 0x60, 0x1d, 0x41, 0x20, 0x00,
	0x14, 0x9c, 0x12, 0x28, 0x9a, 0xff, 0x76, 0x58, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x07, 0xa1, 0x5a, 0xe7, 0xc0, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff,
	0xff, 0xe0, 0x00, 0xe7, 0x00, 0x91, 0x6e, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x34,
	0x80, 0x1d, 0x61, 0x20, 0x00, 0x1e, 0xd8, 0x12, 0x28, 0x8f, 0x7f, 0x96, 0x58, 0x9a, 0xf4, 0x6d,
	0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x66, 0x66, 0x67, 0xe0, 0x00, 0x1e,
	0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xe8, 0x00, 0x91, 0x6f, 0x00, 0x0c, 0x60, 0x20,
	0x14, 0x2c, 0xc8, 0x00, 0x34, 0xa0, 0x1d, 0x81, 0x20, 0x00, 0x09, 0x10, 0x32, 0x28, 0x83, 0xff,
	0xb6, 0x58, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x53,
	0x23, 0x27, 0xe0, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xe9, 0x00, 0x91,
	0x6f, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x34, 0xc0, 0x1d, 0x61, 0x20, 0x00, 0x1e,
	0xd4, 0x12, 0x28, 0x83, 0xff, 0xb6, 0x58, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x0b, 0x91, 0xf0, 0x47, 0xe0, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff,
	0xe0, 0x00,
}

// Packet [93] opcode=0x75 len=530b
var streamingPacket93 = []byte{
	0x75, 0x00, 0x48, 0xb8, 0x00, 0x06, 0x30, 0x10, 0x14, 0x2c, 0xc8, 0x00, 0x34, 0xe0, 0x1d, 0x41,
	0x20, 0x00, 0x0e, 0x20, 0xb2, 0x68, 0x85, 0x31, 0x96, 0x78, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0xf8, 0x4e, 0xa7, 0xc0, 0x00, 0x1e, 0x08, 0x20, 0x1f,
	0xff, 0xff, 0xff, 0xe0, 0x00, 0xeb, 0x00, 0x91, 0x70, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8,
	0x00, 0x35, 0x00, 0x1d, 0x61, 0x20, 0x00, 0x01, 0x58, 0xf2, 0x48, 0x9a, 0xf1, 0x76, 0x78, 0x9a,
	0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0xf8, 0x4e, 0xb7, 0xa0,
	0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xec, 0x00, 0x91, 0x71, 0x00, 0x0c,
	0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x35, 0x20, 0x1d, 0x81, 0x20, 0x00, 0x01, 0x54, 0xf2, 0x48,
	0x90, 0xb1, 0x76, 0x78, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x1d, 0x8a, 0x27, 0x07, 0xc0, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xed,
	0x00, 0x91, 0x71, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x35, 0x40, 0x1d, 0x61, 0x20,
	0x00, 0x0c, 0xdc, 0xd2, 0x48, 0x85, 0x31, 0x96, 0x78, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x5a, 0xe0, 0x78, 0x00, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff,
	0xff, 0xff, 0xe0, 0x00, 0xee, 0x00, 0x91, 0x72, 0x00, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00,
	0x35, 0x60, 0x1d, 0x81, 0x20, 0x00, 0x0a, 0x55, 0x12, 0x48, 0x9d, 0x8d, 0x36, 0x78, 0x9a, 0xf4,
	0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xa5, 0x66, 0x88, 0x60, 0x00,
	0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xef, 0x00, 0x91, 0x72, 0x80, 0x0c, 0x60,
	0x20, 0x14, 0x2c, 0xc8, 0x00, 0x35, 0x80, 0x18, 0xe0, 0xe0, 0x00, 0x15, 0xde, 0xf2, 0x48, 0x91,
	0xfe, 0x56, 0x78, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d,
	0x92, 0x26, 0x68, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xf0, 0x00,
	0x91, 0x73, 0x00, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x35, 0xa0, 0x19, 0x80, 0xe0, 0x00,
	0x15, 0xda, 0xf2, 0x48, 0x87, 0xbe, 0x56, 0x78, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x0e, 0x27, 0xa6, 0x68, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff,
	0xff, 0xe0, 0x00, 0xf1, 0x00, 0x91, 0x73, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x35,
	0xc0, 0x19, 0x80, 0xe0, 0x00, 0x0e, 0x20, 0xb2, 0x68, 0x9a, 0xed, 0x76, 0x78, 0x9a, 0xf4, 0x6d,
	0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x27, 0xa6, 0x68, 0x60, 0x00, 0x1e,
	0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xf2, 0x00, 0x91, 0x74, 0x00, 0x0c, 0x60, 0x20,
	0x14, 0x2c, 0xc8, 0x00, 0x35, 0xe0, 0x18, 0xe0, 0xe0, 0x00, 0x03, 0xe4, 0xb2, 0x68, 0x85, 0x2d,
	0x96, 0x78, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x92,
	0x26, 0x68, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xf3, 0x00, 0x91,
	0x74, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x36, 0x00, 0x1d, 0x81, 0x20, 0x00, 0x02,
	0x85, 0xd2, 0x48, 0x86, 0x71, 0x76, 0x78, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1d, 0x8a, 0x27, 0x07, 0xc0, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff,
	0xe0, 0x00,
}

// Packet [95] opcode=0x7a len=530b
var streamingPacket95 = []byte{
	0x7a, 0x00, 0x48, 0xba, 0x80, 0x06, 0x30, 0x10, 0x14, 0x2c, 0xc8, 0x00, 0x36, 0x20, 0x1d, 0x61,
	0x20, 0x00, 0x18, 0x69, 0xb2, 0x48, 0x86, 0x71, 0x76, 0x78, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0xcc, 0xcc, 0xc7, 0xe0, 0x00, 0x1e, 0x08, 0x20, 0x1f,
	0xff, 0xff, 0xff, 0xe0, 0x00, 0xf5, 0x00, 0x91, 0x75, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8,
	0x00, 0x36, 0x40, 0x1d, 0x61, 0x20, 0x00, 0x1c, 0x2d, 0x52, 0x48, 0x91, 0xf1, 0x56, 0x78, 0x9a,
	0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x2f, 0x42, 0x87, 0xe0,
	0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xf6, 0x00, 0x91, 0x76, 0x00, 0x0c,
	0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x36, 0x60, 0x1d, 0x41, 0x20, 0x00, 0x01, 0x50, 0xf2, 0x48,
	0x87, 0xb1, 0x56, 0x78, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x13, 0x53, 0x33, 0x27, 0xc0, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xf7,
	0x00, 0x91, 0x76, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x36, 0x80, 0x06, 0xe1, 0x60,
	0x00, 0x19, 0xad, 0x92, 0x28, 0x98, 0x62, 0xb6, 0x98, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x66, 0x96, 0x88, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff,
	0xff, 0xff, 0xe0, 0x00, 0xf8, 0x00, 0x91, 0x77, 0x00, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00,
	0x36, 0xa0, 0x1d, 0x01, 0x20, 0x00, 0x15, 0xd1, 0xf2, 0x28, 0x8b, 0x82, 0xf6, 0x98, 0x86, 0x66,
	0x6d, 0x68, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x53, 0x33, 0x37, 0xe0, 0x00,
	0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xf9, 0x00, 0x91, 0x77, 0x80, 0x0c, 0x60,
	0x20, 0x14, 0x2c, 0xc8, 0x00, 0x36, 0xc0, 0x1d, 0x01, 0x20, 0x00, 0x15, 0xd5, 0xf2, 0x28, 0x80,
	0x03, 0x16, 0x98, 0x86, 0x66, 0x6d, 0x68, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07,
	0xa1, 0x5a, 0xf7, 0xc0, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xfa, 0x00,
	0x91, 0x78, 0x00, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x36, 0xe0, 0x1d, 0x01, 0x20, 0x00,
	0x00, 0x1a, 0x12, 0x28, 0x80, 0x03, 0x16, 0x98, 0x86, 0x66, 0x6d, 0x68, 0x20, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x11, 0xf8, 0x4e, 0xb7, 0xa0, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff,
	0xff, 0xe0, 0x00, 0xfb, 0x00, 0x91, 0x78, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x37,
	0x00, 0x1d, 0xe1, 0x20, 0x00, 0x10, 0xbe, 0x72, 0x28, 0x8f, 0x62, 0x96, 0x98, 0x9a, 0xf4, 0x6d,
	0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x57, 0x13, 0xc7, 0xc0, 0x00, 0x1e,
	0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xfc, 0x00, 0x91, 0x79, 0x00, 0x0c, 0x60, 0x20,
	0x14, 0x2c, 0xc8, 0x00, 0x37, 0x20, 0x1d, 0xe1, 0x20, 0x00, 0x1a, 0xe2, 0x72, 0x48, 0x8f, 0x62,
	0x96, 0x98, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x53,
	0x33, 0x27, 0xc0, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0xfd, 0x00, 0x91,
	0x79, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x37, 0x40, 0x1d, 0xe1, 0x20, 0x00, 0x0f,
	0x62, 0x92, 0x48, 0x86, 0x7e, 0x76, 0x78, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x19, 0xa1, 0x86, 0x88, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff,
	0xe0, 0x00,
}

// Packet [97] opcode=0x7f len=530b
var streamingPacket97 = []byte{
	0x7f, 0x00, 0x48, 0xbd, 0x00, 0x06, 0x30, 0x10, 0x14, 0x2c, 0xc8, 0x00, 0x37, 0x60, 0x1d, 0xe1,
	0x20, 0x00, 0x0e, 0x3e, 0xb2, 0x28, 0x90, 0xbe, 0x76, 0x78, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x4b, 0x26, 0x88, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f,
	0xff, 0xff, 0xff, 0xe0, 0x00, 0xff, 0x00, 0x91, 0x7a, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8,
	0x00, 0x37, 0x80, 0x06, 0xe1, 0x60, 0x00, 0x19, 0xae, 0x92, 0x28, 0x8e, 0x3e, 0xb6, 0x78, 0x9a,
	0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x33, 0x86, 0x88, 0x60,
	0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x01, 0x91, 0x7b, 0x00, 0x0c,
	0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x37, 0xa0, 0x06, 0xe1, 0x60, 0x00, 0x18, 0x72, 0xb2, 0x28,
	0x8e, 0x3e, 0xb6, 0x78, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x03, 0xf8, 0xa6, 0x68, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x01,
	0x01, 0x91, 0x7b, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x37, 0xc0, 0x06, 0xe1, 0x60,
	0x00, 0x18, 0x76, 0xb2, 0x28, 0x98, 0x7e, 0xb6, 0x78, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x33, 0x86, 0x88, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff,
	0xff, 0xff, 0xe0, 0x00, 0x02, 0x01, 0x91, 0x7c, 0x00, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00,
	0x37, 0xe0, 0x06, 0xe1, 0x60, 0x00, 0x18, 0x7a, 0xb2, 0x28, 0x83, 0xfe, 0xb6, 0x78, 0x9a, 0xf4,
	0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x33, 0x86, 0x88, 0x60, 0x00,
	0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x03, 0x01, 0x91, 0x7c, 0x80, 0x0c, 0x60,
	0x20, 0x14, 0x2c, 0xc8, 0x00, 0x38, 0x00, 0x18, 0xc0, 0xe0, 0x00, 0x1c, 0x3c, 0x52, 0x48, 0x81,
	0x53, 0xf6, 0x98, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14,
	0x8e, 0x03, 0xb8, 0x00, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x04, 0x01,
	0x91, 0x7d, 0x00, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x38, 0x20, 0x18, 0xc0, 0xe0, 0x00,
	0x05, 0x36, 0x92, 0x68, 0x8b, 0x9e, 0xf6, 0x58, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x06, 0x66, 0x6a, 0x68, 0x00, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff,
	0xff, 0xe0, 0x00, 0x05, 0x01, 0x91, 0x7d, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x38,
	0x40, 0x18, 0xc0, 0xe0, 0x00, 0x07, 0xb8, 0x52, 0x48, 0x82, 0x93, 0xd6, 0x98, 0x9a, 0xf4, 0x6d,
	0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0xf8, 0x5e, 0xa7, 0xc0, 0x00, 0x1e,
	0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x06, 0x01, 0x91, 0x7e, 0x00, 0x0c, 0x60, 0x20,
	0x14, 0x2c, 0xc8, 0x00, 0x38, 0x60, 0x18, 0xc0, 0xe0, 0x00, 0x1c, 0x34, 0x52, 0x48, 0x82, 0x93,
	0xd6, 0x98, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x53,
	0x33, 0x37, 0xe0, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x07, 0x01, 0x91,
	0x7e, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x38, 0x80, 0x18, 0xc0, 0xe0, 0x00, 0x10,
	0xb0, 0x72, 0x48, 0x8e, 0x33, 0xb6, 0x98, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x10, 0xbd, 0x72, 0x37, 0xe0, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff,
	0xe0, 0x00,
}

var streamingPacket99 = []byte{
	0x04, 0x00, 0xc8, 0xbf, 0x80, 0x06, 0x30, 0x10, 0x14, 0x2c, 0xc8, 0x00, 0x38, 0xa0, 0x18, 0xc0,
	0xe0, 0x00, 0x1a, 0xec, 0x72, 0x48, 0x83, 0xf3, 0xb6, 0x98, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0x8a, 0x27, 0x17, 0xe0, 0x00, 0x1e, 0x08, 0x20, 0x1f,
	0xff, 0xff, 0xff, 0xe0, 0x00, 0x09, 0x01, 0x91, 0x7f, 0x80, 0x0c, 0x60, 0x20, 0x14, 0x2c, 0xc8,
	0x00, 0x38, 0xc0, 0x1c, 0x41, 0x20, 0x00, 0x09, 0x02, 0x32, 0x48, 0x9d, 0x81, 0x36, 0xb8, 0x9a,
	0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x3f, 0x46, 0x58, 0x60,
	0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x0a, 0x01, 0x91, 0x00, 0x00, 0x8c,
	0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x38, 0xe0, 0x1c, 0x41, 0x20, 0x00, 0x06, 0x66, 0x72, 0x48,
	0x89, 0x01, 0x36, 0xb8, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x1c, 0x3f, 0x46, 0x58, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x0b,
	0x01, 0x91, 0x00, 0x80, 0x8c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x39, 0x00, 0x1c, 0x41, 0x20,
	0x00, 0x0e, 0x2a, 0xb2, 0x48, 0x93, 0x41, 0x36, 0xb8, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x3f, 0x46, 0x58, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff,
	0xff, 0xff, 0xe0, 0x00, 0x0c, 0x01, 0x91, 0x01, 0x00, 0x8c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00,
	0x39, 0x20, 0x1c, 0x41, 0x20, 0x00, 0x01, 0x4e, 0xf2, 0x48, 0x87, 0xa1, 0x56, 0xb8, 0x9a, 0xf4,
	0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x06, 0xb8, 0x60, 0x00,
	0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x0d, 0x01, 0x91, 0x01, 0x80, 0x8c, 0x60,
	0x20, 0x14, 0x2c, 0xc8, 0x00, 0x39, 0x40, 0x1c, 0x41, 0x20, 0x00, 0x05, 0x3c, 0x92, 0x48, 0x83,
	0xef, 0xb6, 0x98, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x10, 0x06, 0xb8, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x0e, 0x01,
	0x91, 0x02, 0x00, 0x8c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x39, 0x60, 0x1b, 0x80, 0xe0, 0x00,
	0x07, 0xa3, 0x52, 0x68, 0x80, 0x03, 0x16, 0x98, 0x80, 0x00, 0x0d, 0x88, 0x20, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x01, 0x5e, 0xf6, 0x68, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff,
	0xff, 0xe0, 0x00, 0x0f, 0x01, 0x91, 0x02, 0x80, 0x8c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x39,
	0x80, 0x19, 0x60, 0xe0, 0x00, 0x17, 0x06, 0xd2, 0x68, 0x85, 0x3e, 0x96, 0x78, 0x9a, 0xf4, 0x6d,
	0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1e,
	0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x10, 0x01, 0x91, 0x03, 0x00, 0x8c, 0x60, 0x20,
	0x14, 0x2c, 0xc8, 0x00, 0x39, 0xa0, 0x19, 0x40, 0xe0, 0x00, 0x0b, 0x82, 0xf2, 0x68, 0x85, 0x3e,
	0x96, 0x78, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0xf8,
	0x4e, 0xa7, 0xa0, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x11, 0x01, 0x91,
	0x03, 0x80, 0x8c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x39, 0xc0, 0x19, 0x20, 0xe0, 0x00, 0x11,
	0xe7, 0x52, 0x68, 0x99, 0xb0, 0x96, 0x98, 0x9a, 0xf4, 0x6d, 0x88, 0x20, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x18, 0x6e, 0xa6, 0x68, 0x60, 0x00, 0x1e, 0x08, 0x20, 0x1f, 0xff, 0xff, 0xff,
	0xe0, 0x00,
}

// Packet [101] frame=230 opcode=0x09 len=530b
var streamingPacket101 = []byte{
	0x09, 0x00, 0xc8, 0x82, 0x00, 0x46, 0x30, 0x10, 0x14, 0x2c, 0xc8, 0x00, 0x39, 0xe0, 0x08, 0x69,
	0x20, 0x00, 0x14, 0x3f, 0x11, 0xe8, 0x7d, 0x45, 0x59, 0x38, 0x9e, 0x81, 0x52, 0xc8, 0x20, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x08, 0x40, 0x00, 0x00, 0x00, 0x00, 0x1f,
	0xff, 0xff, 0xff, 0xe0, 0x00, 0x13, 0x01, 0x91, 0x04, 0x80, 0x8c, 0x60, 0x20, 0x14, 0x2c, 0xc8,
	0x00, 0x3a, 0x00, 0x08, 0xa9, 0x20, 0x00, 0x1a, 0x85, 0x71, 0xe8, 0x6d, 0xe4, 0x59, 0x38, 0x9e,
	0x81, 0x52, 0xc8, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x08, 0x40,
	0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x14, 0x01, 0x91, 0x05, 0x00, 0x8c,
	0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x3a, 0x20, 0x08, 0x89, 0x20, 0x00, 0x0d, 0xd8, 0xb2, 0x08,
	0x70, 0x66, 0x99, 0x38, 0x9e, 0x81, 0x52, 0xc8, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x14, 0x08, 0x40, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x15,
	0x01, 0x91, 0x05, 0x80, 0x8c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x3a, 0x40, 0x08, 0xa9, 0x20,
	0x00, 0x0d, 0xc4, 0xb1, 0xe8, 0x79, 0x65, 0x39, 0x38, 0x8b, 0x4e, 0x32, 0xc8, 0x20, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x08, 0x40, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff,
	0xff, 0xff, 0xe0, 0x00, 0x16, 0x01, 0x91, 0x06, 0x00, 0x8c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00,
	0x3a, 0x60, 0x08, 0x89, 0x20, 0x00, 0x01, 0x17, 0xf2, 0x08, 0x7b, 0xe7, 0x79, 0x38, 0x8b, 0x4e,
	0x32, 0xc8, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x08, 0x40, 0x00,
	0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x17, 0x01, 0x91, 0x06, 0x80, 0x8c, 0x60,
	0x20, 0x14, 0x2c, 0xc8, 0x00, 0x3a, 0x80, 0x08, 0xa9, 0x20, 0x00, 0x14, 0x3f, 0x11, 0xe8, 0x78,
	0x26, 0x59, 0x38, 0x82, 0x90, 0x00, 0xe8, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x14, 0x08, 0x40, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x18, 0x01,
	0x91, 0x07, 0x00, 0x8c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x3a, 0xa0, 0x08, 0x89, 0x20, 0x00,
	0x14, 0x3f, 0x11, 0xe8, 0x78, 0x26, 0x59, 0x38, 0x82, 0x90, 0x00, 0xe8, 0x40, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x08, 0x40, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff,
	0xff, 0xe0, 0x00, 0x19, 0x01, 0x91, 0x07, 0x80, 0x8c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x3a,
	0xc0, 0x08, 0xa9, 0x20, 0x00, 0x14, 0x3f, 0x11, 0xe8, 0x78, 0x26, 0x59, 0x38, 0x91, 0x97, 0xc7,
	0xe8, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x08, 0x40, 0x00, 0x00,
	0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x1a, 0x01, 0x91, 0x08, 0x00, 0x8c, 0x60, 0x20,
	0x14, 0x2c, 0xc8, 0x00, 0x3a, 0xe0, 0x08, 0x89, 0x20, 0x00, 0x14, 0x3f, 0x11, 0xe8, 0x78, 0x26,
	0x59, 0x38, 0x91, 0x97, 0xc7, 0xe8, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x14, 0x08, 0x40, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x1b, 0x01, 0x91,
	0x08, 0x80, 0x8c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x3b, 0x00, 0x08, 0xa9, 0x20, 0x00, 0x14,
	0x3f, 0x11, 0xe8, 0x78, 0x26, 0x59, 0x38, 0x91, 0x97, 0xca, 0x28, 0x40, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x08, 0x40, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff,
	0xe0, 0x00,
}

// Packet [103] frame=232 opcode=0x0e len=530b
var streamingPacket103 = []byte{
	0x0e, 0x00, 0xc8, 0x84, 0x80, 0x46, 0x30, 0x10, 0x14, 0x2c, 0xc8, 0x00, 0x3b, 0x20, 0x08, 0x89,
	0x20, 0x00, 0x14, 0x3f, 0x11, 0xe8, 0x78, 0x26, 0x59, 0x38, 0x91, 0x97, 0xca, 0x28, 0x40, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x08, 0x40, 0x00, 0x00, 0x00, 0x00, 0x1f,
	0xff, 0xff, 0xff, 0xe0, 0x00, 0x1d, 0x01, 0x91, 0x09, 0x80, 0x8c, 0x60, 0x20, 0x14, 0x2c, 0xc8,
	0x00, 0x3b, 0x40, 0x08, 0xa9, 0x20, 0x00, 0x14, 0x3f, 0x11, 0xe8, 0x78, 0x26, 0x59, 0x38, 0x91,
	0x97, 0xcc, 0x68, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x08, 0x40,
	0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x1e, 0x01, 0x91, 0x0a, 0x00, 0x8c,
	0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x3b, 0x60, 0x08, 0x89, 0x20, 0x00, 0x14, 0x3f, 0x11, 0xe8,
	0x78, 0x26, 0x59, 0x38, 0x91, 0x97, 0xcc, 0x68, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x14, 0x08, 0x40, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x1f,
	0x01, 0x91, 0x0a, 0x80, 0x8c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x3b, 0x80, 0x08, 0xa9, 0x20,
	0x00, 0x14, 0x3f, 0x11, 0xe8, 0x78, 0x26, 0x59, 0x38, 0x91, 0x97, 0xce, 0xa8, 0x40, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x08, 0x40, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff,
	0xff, 0xff, 0xe0, 0x00, 0x20, 0x01, 0x91, 0x0b, 0x00, 0x8c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00,
	0x3b, 0xa0, 0x08, 0x89, 0x20, 0x00, 0x14, 0x3f, 0x11, 0xe8, 0x78, 0x26, 0x59, 0x38, 0x91, 0x97,
	0xce, 0xa8, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x08, 0x40, 0x00,
	0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x21, 0x01, 0x91, 0x0b, 0x80, 0x8c, 0x60,
	0x20, 0x14, 0x2c, 0xc8, 0x00, 0x3b, 0xc0, 0x08, 0xa9, 0x20, 0x00, 0x14, 0x3f, 0x11, 0xe8, 0x78,
	0x26, 0x59, 0x38, 0x88, 0xdb, 0xf0, 0x68, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x14, 0x08, 0x40, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x22, 0x01,
	0x91, 0x0c, 0x00, 0x8c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x3b, 0xe0, 0x08, 0x89, 0x20, 0x00,
	0x14, 0x3f, 0x11, 0xe8, 0x78, 0x26, 0x59, 0x38, 0x88, 0xdb, 0xf0, 0x68, 0x40, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x08, 0x40, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff,
	0xff, 0xe0, 0x00, 0x23, 0x01, 0x91, 0x0c, 0x80, 0x8c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x3c,
	0x00, 0x08, 0xa9, 0x20, 0x00, 0x14, 0x3f, 0x11, 0xe8, 0x78, 0x26, 0x59, 0x38, 0x88, 0xdb, 0xf1,
	0x88, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x08, 0x40, 0x00, 0x00,
	0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x24, 0x01, 0x91, 0x0d, 0x00, 0x8c, 0x60, 0x20,
	0x14, 0x2c, 0xc8, 0x00, 0x3c, 0x20, 0x08, 0x89, 0x20, 0x00, 0x14, 0x3f, 0x11, 0xe8, 0x78, 0x26,
	0x59, 0x38, 0x88, 0xdb, 0xf1, 0x88, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x14, 0x08, 0x40, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x25, 0x01, 0x91,
	0x0d, 0x80, 0x8c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x3c, 0x40, 0x08, 0xa9, 0x20, 0x00, 0x14,
	0x3f, 0x11, 0xe8, 0x78, 0x26, 0x59, 0x38, 0x88, 0xdb, 0xf2, 0xa8, 0x40, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x08, 0x40, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff,
	0xe0, 0x00,
}

// Packet [105] frame=240 opcode=0x13 len=530b
var streamingPacket105 = []byte{
	0x13, 0x00, 0xc8, 0x87, 0x00, 0x46, 0x30, 0x10, 0x14, 0x2c, 0xc8, 0x00, 0x3c, 0x60, 0x08, 0x89,
	0x20, 0x00, 0x14, 0x3f, 0x11, 0xe8, 0x78, 0x26, 0x59, 0x38, 0x88, 0xdb, 0xf2, 0xa8, 0x40, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x08, 0x40, 0x00, 0x00, 0x00, 0x00, 0x1f,
	0xff, 0xff, 0xff, 0xe0, 0x00, 0x27, 0x01, 0x91, 0x0e, 0x80, 0x8c, 0x60, 0x20, 0x14, 0x2c, 0xc8,
	0x00, 0x3c, 0x80, 0x08, 0xa9, 0x20, 0x00, 0x14, 0x3f, 0x11, 0xe8, 0x78, 0x26, 0x59, 0x38, 0x88,
	0xdb, 0xf3, 0xc8, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x08, 0x40,
	0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x28, 0x01, 0x91, 0x0f, 0x00, 0x8c,
	0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x3c, 0xa0, 0x08, 0x89, 0x20, 0x00, 0x14, 0x3f, 0x11, 0xe8,
	0x78, 0x26, 0x59, 0x38, 0x88, 0xdb, 0xf3, 0xc8, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x14, 0x08, 0x40, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x29,
	0x01, 0x91, 0x0f, 0x80, 0x8c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x3c, 0xc0, 0x08, 0xa9, 0x20,
	0x00, 0x14, 0x3f, 0x11, 0xe8, 0x78, 0x26, 0x59, 0x38, 0x88, 0xdb, 0xf4, 0xe8, 0x40, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x08, 0x40, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff,
	0xff, 0xff, 0xe0, 0x00, 0x2a, 0x01, 0x91, 0x10, 0x00, 0x8c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00,
	0x3c, 0xe0, 0x08, 0x89, 0x20, 0x00, 0x14, 0x3f, 0x11, 0xe8, 0x78, 0x26, 0x59, 0x38, 0x88, 0xdb,
	0xf4, 0xe8, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x08, 0x40, 0x00,
	0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x2b, 0x01, 0x91, 0x10, 0x80, 0x8c, 0x60,
	0x20, 0x14, 0x2c, 0xc8, 0x00, 0x3d, 0x00, 0x08, 0xa9, 0x20, 0x00, 0x14, 0x3f, 0x11, 0xe8, 0x78,
	0x26, 0x59, 0x38, 0x88, 0xdb, 0xf6, 0x08, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x14, 0x08, 0x40, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x2c, 0x01,
	0x91, 0x11, 0x00, 0x8c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x3d, 0x20, 0x08, 0x89, 0x20, 0x00,
	0x14, 0x3f, 0x11, 0xe8, 0x78, 0x26, 0x59, 0x38, 0x88, 0xdb, 0xf6, 0x08, 0x40, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x08, 0x40, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff,
	0xff, 0xe0, 0x00, 0x2d, 0x01, 0x91, 0x11, 0x80, 0x8c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x3d,
	0x40, 0x08, 0xa9, 0x20, 0x00, 0x14, 0x3f, 0x11, 0xe8, 0x78, 0x26, 0x59, 0x38, 0x88, 0xdb, 0xf7,
	0x28, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x08, 0x40, 0x00, 0x00,
	0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x2e, 0x01, 0x91, 0x12, 0x00, 0x8c, 0x60, 0x20,
	0x14, 0x2c, 0xc8, 0x00, 0x3d, 0x60, 0x08, 0x89, 0x20, 0x00, 0x14, 0x3f, 0x11, 0xe8, 0x78, 0x26,
	0x59, 0x38, 0x88, 0xdb, 0xf7, 0x28, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x14, 0x08, 0x40, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x2f, 0x01, 0x91,
	0x12, 0x80, 0x8c, 0x60, 0x20, 0x14, 0x2c, 0xc8, 0x00, 0x3d, 0x80, 0x08, 0xa9, 0x20, 0x00, 0x14,
	0x3f, 0x11, 0xe8, 0x78, 0x26, 0x59, 0x38, 0x88, 0xdb, 0xf8, 0x48, 0x40, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x08, 0x40, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff,
	0xe0, 0x00,
}

// Packet [107] frame=248 opcode=0x18 len=348b
var streamingPacket107 = []byte{
	0x18, 0x00, 0xc8, 0x89, 0x80, 0x46, 0x30, 0x10, 0x14, 0x2c, 0xc8, 0x00, 0x3d, 0xa0, 0x08, 0x89,
	0x20, 0x00, 0x14, 0x3f, 0x11, 0xe8, 0x78, 0x26, 0x59, 0x38, 0x88, 0xdb, 0xf8, 0x48, 0x40, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x08, 0x40, 0x00, 0x00, 0x00, 0x00, 0x1f,
	0xff, 0xff, 0xff, 0xe0, 0x00, 0x31, 0x01, 0x91, 0x13, 0x80, 0x9e, 0xc1, 0x00, 0x14, 0x8b, 0xda,
	0x61, 0x00, 0x00, 0x80, 0x38, 0x8c, 0x00, 0x00, 0x20, 0x42, 0xc9, 0xc0, 0x00, 0x00, 0x00, 0x00,
	0x10, 0x10, 0x00, 0x00, 0x01, 0x00, 0x26, 0xf1, 0x20, 0x33, 0xc0, 0x00, 0x00, 0x00, 0x00, 0xa0,
	0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x04,
	0x00, 0x00, 0x00, 0x41, 0x4d, 0x04, 0xb5, 0x35, 0x40, 0x80, 0xc0, 0xb8, 0xcc, 0x81, 0x4d, 0x95,
	0xc9, 0xd9, 0x95, 0xc8, 0x94, 0x2c, 0x38, 0x64, 0x0c, 0x60, 0x00, 0x08, 0x0c, 0x3c, 0x28, 0x68,
	0x18, 0x0c, 0x44, 0x30, 0x2c, 0x24, 0x2c, 0x1c, 0x64, 0x4c, 0x3c, 0x00, 0x2c, 0x00, 0x30, 0x1c,
	0x18, 0x70, 0x04, 0x00, 0x00, 0x20, 0x00, 0x1c, 0x30, 0x24, 0x08, 0x70, 0x04, 0x00, 0x08, 0x10,
	0x1c, 0x10, 0x14, 0x08, 0x20, 0x00, 0x04, 0x30, 0x08, 0x24, 0x18, 0x30, 0x0c, 0x2c, 0x18, 0x00,
	0x18, 0x90, 0x20, 0x98, 0x00, 0x00, 0x34, 0x20, 0xcc, 0x08, 0x3c, 0x34, 0x18, 0x60, 0x24, 0xa8,
	0x24, 0x44, 0x30, 0x44, 0x44, 0x04, 0xc8, 0x18, 0x28, 0x34, 0x14, 0x38, 0x00, 0x38, 0x1c, 0x04,
	0x14, 0x2c, 0x00, 0x0c, 0xd0, 0x0c, 0x14, 0x04, 0x24, 0x00, 0x00, 0x00, 0x04, 0x14, 0x38, 0x0c,
	0x40, 0x00, 0x10, 0x0c, 0x10, 0x1c, 0x00, 0x04, 0x40, 0x08, 0x38, 0x24, 0x00, 0x78, 0x64, 0x20,
	0x14, 0x3c, 0x04, 0x0c, 0x00, 0x14, 0x34, 0x34, 0x28, 0x3c, 0x10, 0x2c, 0x64, 0x00, 0x0c, 0x00,
	0x10, 0x4c, 0x5c, 0x4c, 0x24, 0x40, 0x24, 0x10, 0x20, 0x38, 0x10, 0x04, 0x0c, 0x1c, 0x50, 0x00,
	0x00, 0x00, 0x2c, 0x10, 0x44, 0x34, 0x4c, 0x04, 0x00, 0x00, 0x08, 0x2c, 0x34, 0x00, 0x24, 0x00,
	0x08, 0x04, 0x10, 0x0c, 0x14, 0x0c, 0x10, 0x28, 0x04, 0x24, 0x10, 0x14, 0x00, 0x04, 0x3c, 0x24,
	0x04, 0x3c, 0x00, 0x00, 0x08, 0x2c, 0x00, 0x04, 0x28, 0x20, 0x10, 0x20, 0x2c, 0x00, 0x08, 0x24,
	0x04, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
}

// Packet [110] frame=287 opcode=0x19 len=264b
var streamingPacket110 = []byte{
	0x19, 0x00, 0xc8, 0x8a, 0x00, 0x51, 0xe0, 0x14, 0x7c, 0xe2, 0x00, 0x10, 0x00, 0x00, 0x00, 0x33,
	0x01, 0x91, 0x14, 0x80, 0x97, 0x60, 0xa0, 0x14, 0x86, 0xd3, 0x00, 0xa0, 0x80, 0x02, 0x33, 0x53,
	0x33, 0x27, 0xc0, 0x00, 0x10, 0x07, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x19, 0x08, 0x60, 0x00,
	0x04, 0x08, 0x44, 0x44, 0x44, 0x57, 0x60, 0x00, 0x20, 0x00, 0x00, 0x1f, 0xe0, 0x40, 0x00, 0x00,
	0x04, 0x08, 0x20, 0x10, 0x19, 0xe8, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x07, 0xff, 0xff, 0xff, 0xff, 0xee, 0x00, 0x04, 0x0a,
	0x0e, 0x4c, 0xae, 0x6e, 0x64, 0x0f, 0xcc, 0x4f, 0xcf, 0xcd, 0x6f, 0xcf, 0xc8, 0xe9, 0xeb, 0xe9,
	0x88, 0xa8, 0xca, 0x8f, 0xc4, 0x0f, 0xce, 0xef, 0xcd, 0xee, 0x44, 0x0f, 0xcc, 0x4f, 0xcf, 0xcd,
	0x6f, 0xcf, 0xc8, 0xe9, 0xeb, 0xea, 0x49, 0x28, 0xe9, 0x0a, 0x8f, 0xc4, 0x0f, 0xce, 0xef, 0xce,
	0x8d, 0xe4, 0x0e, 0x6e, 0xed, 0x2e, 0x8c, 0x6d, 0x04, 0x0c, 0x6d, 0x2e, 0x8d, 0x2c, 0xae, 0x65,
	0xcf, 0xcd, 0xcf, 0xc4, 0x0a, 0x0e, 0x4c, 0xae, 0x6e, 0x64, 0x0f, 0xce, 0x4f, 0xcf, 0xcd, 0x6f,
	0xcf, 0xca, 0x08, 0xa8, 0x8b, 0xe8, 0xc9, 0x2a, 0x48, 0xaa, 0xe8, 0xa8, 0x2a, 0x09, 0xe9, 0xcf,
	0xc4, 0x0f, 0xce, 0xef, 0xce, 0x8d, 0xe4, 0x0e, 0x6c, 0xad, 0x8c, 0xac, 0x6e, 0x85, 0xc0, 0x34,
	0x01, 0x82, 0x6c, 0x04, 0x14, 0x80, 0xcf, 0x00, 0x20, 0x1f, 0xe5, 0x40, 0x20, 0x00, 0x0f, 0xd3,
	0x7c, 0x1b, 0x68, 0x81, 0x08, 0x9d, 0xb8, 0x98, 0xbf, 0xcb, 0x08, 0x34, 0x67, 0x30, 0xa8, 0x7f,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0,
}

// Frame 285 (534 bytes)
var packet58_534 = []byte{
	0x58, 0x80, 0xc8, 0xa7, 0xc0, 0x41, 0xb0, 0x20, 0x14, 0xa4, 0xdf, 0x00, 0x3f, 0x60, 0x4a, 0x80,
	0x40, 0x00, 0x08, 0x28, 0x39, 0x08, 0x84, 0xb0, 0x1a, 0x78, 0x8a, 0x11, 0xb6, 0x68, 0x16, 0x0c,
	0x76, 0x48, 0x40, 0x00, 0x20, 0x00, 0x0f, 0x48, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xb2, 0x01, 0x91, 0x50,
	0x00, 0x83, 0x60, 0x40, 0x14, 0xa4, 0xdf, 0x00, 0x3f, 0x80, 0x4a, 0x80, 0x40, 0x00, 0x1e, 0x6d,
	0x98, 0xe8, 0x9f, 0xfe, 0x5a, 0xb8, 0x87, 0x52, 0x56, 0x68, 0x0f, 0x4a, 0xc6, 0x88, 0x60, 0x00,
	0x20, 0x00, 0x0f, 0x48, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xb3, 0x01, 0x91, 0x50, 0x80, 0x83, 0x60, 0x40,
	0x14, 0xa4, 0xdf, 0x00, 0x3f, 0xa0, 0x41, 0x60, 0x40, 0x00, 0x18, 0x38, 0xb8, 0xa8, 0x96, 0x8c,
	0x5a, 0x18, 0x89, 0x1c, 0x35, 0xc8, 0x1d, 0xf1, 0x0e, 0x08, 0x60, 0x00, 0x00, 0x00, 0x0f, 0x48,
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xe0, 0xb4, 0x01, 0x91, 0x51, 0x00, 0x83, 0x60, 0x40, 0x14, 0xa4, 0xdf, 0x00,
	0x3f, 0xc0, 0x41, 0x60, 0x40, 0x00, 0x1e, 0x39, 0x58, 0xa8, 0x84, 0x15, 0x1a, 0x18, 0x89, 0x1c,
	0x35, 0xc8, 0x0e, 0xcb, 0xed, 0xe8, 0x60, 0x00, 0x00, 0x00, 0x0f, 0x48, 0x80, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0,
	0xb5, 0x01, 0x91, 0x51, 0x80, 0x83, 0x60, 0x40, 0x14, 0xa4, 0xdf, 0x00, 0x3f, 0xe0, 0x41, 0x60,
	0x40, 0x00, 0x0e, 0x98, 0xb8, 0xa8, 0x94, 0x3c, 0xda, 0x18, 0x80, 0x9c, 0xf5, 0xc8, 0x0a, 0x1f,
	0x8d, 0xa8, 0x60, 0x00, 0x00, 0x00, 0x0f, 0x48, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xb6, 0x01, 0x91, 0x52,
	0x00, 0x83, 0x60, 0x40, 0x14, 0xa4, 0xdf, 0x00, 0x20, 0x00, 0x61, 0x60, 0x40, 0x00, 0x1b, 0x18,
	0x98, 0xa8, 0x9a, 0x25, 0xda, 0x38, 0x9d, 0x7c, 0x55, 0xc8, 0x06, 0x80, 0x4d, 0xc8, 0x60, 0x00,
	0x00, 0x00, 0x0f, 0x48, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xb7, 0x01, 0x91, 0x52, 0x80, 0xa2, 0xc0, 0x14,
	0xa5, 0xe1, 0x00, 0x70, 0x30, 0xb8, 0x01, 0x91, 0x53, 0x00, 0xa2, 0xc0, 0x14, 0xa5, 0xe1, 0x00,
	0x80, 0x30, 0xb9, 0x01, 0x91, 0x53, 0x80, 0xa2, 0xc0, 0x14, 0xa5, 0xe1, 0x00, 0x90, 0x30, 0xba,
	0x01, 0x91, 0x54, 0x00, 0xa2, 0xc0, 0x14, 0xa5, 0xe1, 0x01, 0x00, 0x30, 0xbb, 0x01, 0x91, 0x54,
	0x80, 0xa2, 0xc0, 0x14, 0xa5, 0xe1, 0x01, 0x10, 0x30, 0xbc, 0x01, 0x91, 0x55, 0x00, 0xa2, 0xc0,
	0x14, 0xa5, 0xe1, 0x02, 0x40, 0x30,
}

// Frame 286 (547 bytes)
var packet5E_547 = []byte{
	0x5e, 0x80, 0xc8, 0xaa, 0xc0, 0x51, 0x60, 0x14, 0xa5, 0xe1, 0x02, 0x50, 0x30, 0xbe, 0x01, 0x91,
	0x56, 0x00, 0xa2, 0xc0, 0x14, 0xa5, 0xe1, 0x02, 0x60, 0x30, 0xbf, 0x01, 0x91, 0x56, 0x80, 0xa2,
	0xc0, 0x14, 0xa5, 0xe1, 0x02, 0x70, 0x30, 0xc0, 0x01, 0x91, 0x57, 0x00, 0xa2, 0xc0, 0x14, 0xa5,
	0xe1, 0x02, 0x80, 0x30, 0xc1, 0x01, 0x91, 0x57, 0x80, 0xa2, 0xc0, 0x14, 0xa5, 0xe1, 0x02, 0x90,
	0x30, 0xc2, 0x01, 0x91, 0x58, 0x00, 0xa2, 0xc0, 0x14, 0xa5, 0xe1, 0x02, 0xa0, 0x30, 0xc3, 0x01,
	0x91, 0x58, 0x80, 0xa2, 0xc0, 0x14, 0xa5, 0xe1, 0x02, 0xb0, 0x30, 0xc4, 0x01, 0x91, 0x59, 0x00,
	0x83, 0x60, 0x40, 0x14, 0xa4, 0xdf, 0x00, 0x2e, 0x00, 0x64, 0x40, 0x40, 0x00, 0x07, 0x22, 0xb8,
	0x08, 0x9b, 0x3b, 0x1c, 0xd8, 0x9a, 0xca, 0xca, 0x88, 0x26, 0xf1, 0x2a, 0x27, 0xe0, 0x6a, 0xe0,
	0x00, 0x0f, 0x48, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xc5, 0x01, 0x91, 0x59, 0x80, 0x83, 0x60, 0x40, 0x14,
	0xa4, 0xdf, 0x00, 0x2e, 0x20, 0x7b, 0x60, 0x20, 0x00, 0x1d, 0xf8, 0x59, 0x28, 0x9c, 0x77, 0x9d,
	0x98, 0x86, 0x94, 0x4a, 0xa8, 0x2c, 0x5f, 0x36, 0x48, 0x6c, 0xca, 0x00, 0x00, 0x0f, 0x48, 0x80,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xe0, 0xc6, 0x01, 0x91, 0x5a, 0x00, 0x83, 0x60, 0x40, 0x14, 0xa4, 0xdf, 0x00, 0x2e,
	0x40, 0x64, 0x40, 0x40, 0x00, 0x1c, 0x31, 0x1c, 0x08, 0x82, 0x95, 0x3e, 0x38, 0x8a, 0x9c, 0x6a,
	0x28, 0x25, 0xae, 0x66, 0x88, 0x6e, 0x29, 0xc0, 0x00, 0x0f, 0x48, 0x80, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xc7,
	0x01, 0x91, 0x5a, 0x80, 0x83, 0x60, 0x40, 0x14, 0xa4, 0xdf, 0x00, 0x2e, 0x60, 0x64, 0x20, 0x40,
	0x00, 0x09, 0x40, 0xdb, 0xc8, 0x80, 0xf6, 0xdd, 0xf8, 0x8b, 0xe5, 0x2a, 0x68, 0x3d, 0x92, 0x36,
	0xa8, 0x44, 0xe0, 0x20, 0x00, 0x0f, 0x48, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xc8, 0x01, 0x91, 0x5b, 0x00,
	0x83, 0x60, 0x40, 0x14, 0xa4, 0xdf, 0x00, 0x2e, 0x80, 0x72, 0x00, 0x20, 0x00, 0x19, 0x60, 0x9b,
	0xc8, 0x94, 0x6d, 0x9d, 0xd8, 0x85, 0x55, 0x2a, 0xe8, 0x21, 0x36, 0x30, 0xe8, 0x6c, 0xa0, 0x20,
	0x00, 0x0f, 0x48, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xc9, 0x01, 0x91, 0x5b, 0x80, 0x83, 0x60, 0x40, 0x14,
	0xa4, 0xdf, 0x00, 0x2e, 0xa0, 0x72, 0x00, 0x20, 0x00, 0x12, 0x70, 0x9c, 0x28, 0x9b, 0xb5, 0x9d,
	0xd8, 0x84, 0xca, 0x6a, 0xa8, 0x31, 0xda, 0xb0, 0xc8, 0x61, 0x41, 0x40, 0x00, 0x0f, 0x48, 0x80,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xe0,
}

// Frame 287 (532 bytes)
var packet65_532 = []byte{
	0x65, 0x00, 0xc8, 0xae, 0x00, 0x41, 0xb0, 0x20, 0x14, 0xa4, 0xdf, 0x00, 0x2e, 0xc0, 0x7b, 0x40,
	0x20, 0x00, 0x14, 0xb1, 0xfc, 0x28, 0x97, 0x7d, 0x5d, 0xf8, 0x8a, 0xcf, 0xaa, 0x48, 0x21, 0x3e,
	0x30, 0xc8, 0x6d, 0xc0, 0x20, 0x00, 0x0f, 0x48, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xcb, 0x01, 0x91, 0x5c,
	0x80, 0x83, 0x60, 0x40, 0x14, 0xa4, 0xdf, 0x00, 0x2e, 0xe0, 0x7e, 0x00, 0x20, 0x00, 0x1d, 0xc7,
	0xbb, 0xe8, 0x89, 0x55, 0x3e, 0x38, 0x99, 0xb9, 0x8a, 0x48, 0x37, 0x49, 0x2b, 0x87, 0xe6, 0x88,
	0xa0, 0x00, 0x0f, 0x48, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xcc, 0x01, 0x91, 0x5d, 0x00, 0x83, 0x60, 0x40,
	0x14, 0xa4, 0xdf, 0x00, 0x2f, 0x00, 0x7e, 0x00, 0x20, 0x00, 0x1c, 0x61, 0x1b, 0xc8, 0x8e, 0xf8,
	0x5d, 0x98, 0x9d, 0x52, 0xa9, 0xe8, 0x2f, 0xa9, 0xd1, 0x08, 0x61, 0xe1, 0xe0, 0x00, 0x0f, 0x48,
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xe0, 0xcd, 0x01, 0x91, 0x5d, 0x80, 0x83, 0x60, 0x40, 0x14, 0xa4, 0xdf, 0x00,
	0x2f, 0x20, 0x7c, 0x40, 0x20, 0x00, 0x0c, 0x82, 0x1b, 0xc8, 0x86, 0xaf, 0xfd, 0xb8, 0x82, 0xa3,
	0xab, 0x08, 0x2a, 0x96, 0x95, 0xc8, 0x41, 0x41, 0x40, 0x00, 0x0f, 0x48, 0x80, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0,
	0xce, 0x01, 0x91, 0x5e, 0x00, 0x83, 0x60, 0x40, 0x14, 0xa4, 0xdf, 0x00, 0x2f, 0x40, 0x7c, 0x40,
	0x20, 0x00, 0x0f, 0x5d, 0x9b, 0xe8, 0x8d, 0xb4, 0xde, 0x38, 0x8b, 0xe5, 0x2b, 0x08, 0x33, 0x03,
	0xc6, 0x88, 0x6e, 0xce, 0xc0, 0x00, 0x0f, 0x48, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xcf, 0x01, 0x91, 0x5e,
	0x80, 0x83, 0x60, 0x40, 0x14, 0xa4, 0xdf, 0x00, 0x2f, 0x60, 0x79, 0xa0, 0x20, 0x00, 0x0f, 0x7f,
	0x3b, 0xa8, 0x82, 0x02, 0xbd, 0xf8, 0x8a, 0x11, 0xa9, 0xe8, 0x34, 0x57, 0xb0, 0xc8, 0x67, 0xa0,
	0x20, 0x00, 0x0f, 0x48, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xd0, 0x01, 0x91, 0x5f, 0x00, 0x83, 0x60, 0x40,
	0x14, 0xa4, 0xdf, 0x00, 0x2f, 0x80, 0x79, 0xa0, 0x20, 0x00, 0x0f, 0xbe, 0xfb, 0xa8, 0x9f, 0x48,
	0x7d, 0xf8, 0x95, 0x91, 0x69, 0xe8, 0x27, 0xa6, 0x50, 0x68, 0x69, 0x60, 0x20, 0x00, 0x0f, 0x48,
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xe0,
}

// Frame 288 (532 bytes)
var packet68_532 = []byte{
	0x68, 0x80, 0xc8, 0xaf, 0xc0, 0x41, 0xb0, 0x20, 0x14, 0xa4, 0xdf, 0x00, 0x2f, 0xa0, 0x63, 0x00,
	0x40, 0x00, 0x1f, 0x8b, 0x1c, 0xa8, 0x84, 0xdf, 0xfd, 0x38, 0x9c, 0x2f, 0x4a, 0x28, 0x29, 0xe7,
	0xc6, 0x68, 0x63, 0xcc, 0x00, 0x00, 0x0f, 0x48, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xd2, 0x01, 0x91, 0x60,
	0x00, 0x83, 0x60, 0x40, 0x14, 0xa4, 0xdf, 0x00, 0x2f, 0xc0, 0x7e, 0x00, 0x20, 0x00, 0x05, 0x52,
	0x9c, 0xa8, 0x8d, 0x76, 0x9c, 0xf8, 0x98, 0x96, 0x2a, 0x28, 0x22, 0xbf, 0xa6, 0x68, 0x62, 0x82,
	0x80, 0x00, 0x0f, 0x48, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xd3, 0x01, 0x91, 0x60, 0x80, 0x83, 0x60, 0x40,
	0x14, 0xa4, 0xdf, 0x00, 0x2f, 0xe0, 0x73, 0xc0, 0x20, 0x00, 0x0a, 0xab, 0x9d, 0x08, 0x80, 0xae,
	0x7d, 0x58, 0x91, 0xa5, 0x0b, 0x28, 0x2f, 0x86, 0x26, 0x88, 0x6b, 0xe0, 0x20, 0x00, 0x0f, 0x48,
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xe0, 0xd4, 0x01, 0x91, 0x61, 0x00, 0x83, 0x60, 0x40, 0x14, 0xa4, 0xdf, 0x00,
	0x30, 0x00, 0x7a, 0x80, 0x20, 0x00, 0x03, 0x92, 0x5d, 0xa8, 0x9a, 0x07, 0x5c, 0xf8, 0x95, 0x34,
	0x8a, 0x68, 0x3b, 0x0e, 0x06, 0x48, 0x4b, 0xc7, 0xe0, 0x00, 0x0f, 0x48, 0x80, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0,
	0xd5, 0x01, 0x91, 0x61, 0x80, 0x83, 0x60, 0x40, 0x14, 0xa4, 0xdf, 0x00, 0x31, 0x40, 0x73, 0x60,
	0x20, 0x00, 0x17, 0xfe, 0x3a, 0x08, 0x8b, 0x5e, 0x3a, 0xd8, 0x84, 0xf6, 0x34, 0x28, 0x29, 0x79,
	0x50, 0xc8, 0x70, 0x8d, 0x80, 0x00, 0x0f, 0x48, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xd6, 0x01, 0x91, 0x62,
	0x00, 0x83, 0x60, 0x40, 0x14, 0xa4, 0xdf, 0x00, 0x31, 0x60, 0x73, 0xe0, 0x20, 0x00, 0x0b, 0xa3,
	0xd9, 0xe8, 0x8e, 0xde, 0x1a, 0x78, 0x9f, 0x1a, 0x74, 0x28, 0x38, 0xaf, 0x16, 0x68, 0x70, 0x66,
	0xa0, 0x00, 0x0f, 0x48, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xd7, 0x01, 0x91, 0x62, 0x80, 0x83, 0x60, 0x40,
	0x14, 0xa4, 0xdf, 0x00, 0x31, 0x80, 0x7e, 0x00, 0x20, 0x00, 0x1f, 0xdf, 0xda, 0x08, 0x89, 0x61,
	0xfa, 0xb8, 0x9a, 0x93, 0x54, 0x28, 0x29, 0x6e, 0x50, 0xe8, 0x68, 0x49, 0x00, 0x00, 0x0f, 0x48,
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xe0,
}

// Frame 289 (532 bytes)
var packet6C_532 = []byte{
	0x6c, 0x00, 0xc8, 0xb1, 0x80, 0x41, 0xb0, 0x20, 0x14, 0xa4, 0xdf, 0x00, 0x31, 0xa0, 0x79, 0xa0,
	0x20, 0x00, 0x1f, 0x87, 0xda, 0x28, 0x99, 0xc4, 0x3a, 0xd8, 0x8b, 0xaf, 0xd4, 0x08, 0x2f, 0x68,
	0x70, 0xc8, 0x45, 0x60, 0x20, 0x00, 0x0f, 0x48, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xd9, 0x01, 0x91, 0x63,
	0x80, 0x83, 0x60, 0x40, 0x14, 0xa4, 0xdf, 0x00, 0x20, 0xe0, 0x84, 0xa0, 0x40, 0x00, 0x12, 0xd2,
	0x7e, 0x68, 0x89, 0x64, 0x00, 0x98, 0xb3, 0x1b, 0xaa, 0x68, 0x27, 0xb7, 0x76, 0xa8, 0x49, 0xe4,
	0xe0, 0x00, 0x0f, 0x48, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xda, 0x01, 0x91, 0x64, 0x00, 0x83, 0x60, 0x40,
	0x14, 0xa4, 0xdf, 0x00, 0x21, 0x00, 0x9e, 0x00, 0x20, 0x00, 0x04, 0x90, 0x1e, 0x68, 0x8e, 0x7d,
	0xc0, 0x98, 0xae, 0xe5, 0xaa, 0x88, 0x2e, 0x71, 0x10, 0xc8, 0x64, 0xa2, 0x60, 0x00, 0x0f, 0x48,
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xe0, 0xdb, 0x01, 0x91, 0x64, 0x80, 0x83, 0x60, 0x40, 0x14, 0xa4, 0xdf, 0x00,
	0x21, 0x40, 0x93, 0xc0, 0x20, 0x00, 0x0e, 0x70, 0xfe, 0x08, 0x9d, 0x17, 0xc0, 0x98, 0xba, 0x1a,
	0xab, 0x48, 0x3b, 0xbb, 0xb6, 0x68, 0x6b, 0xe0, 0x20, 0x00, 0x0f, 0x48, 0x80, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0,
	0xdc, 0x01, 0x91, 0x65, 0x00, 0x83, 0x60, 0x40, 0x14, 0xa4, 0xdf, 0x00, 0x21, 0x60, 0x88, 0x00,
	0x40, 0x00, 0x0c, 0xa9, 0xbe, 0x48, 0x92, 0xd3, 0xc0, 0x58, 0xb1, 0xf8, 0x4a, 0x48, 0x3e, 0x1e,
	0xd5, 0xe8, 0x49, 0x41, 0x00, 0x00, 0x0f, 0x48, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xdd, 0x01, 0x91, 0x65,
	0x80, 0x83, 0x60, 0x40, 0x14, 0xa4, 0xdf, 0x00, 0x21, 0x80, 0x80, 0xc0, 0x40, 0x00, 0x02, 0xcc,
	0x7e, 0xe8, 0x8b, 0x23, 0x20, 0x38, 0xab, 0x76, 0x2a, 0x48, 0x25, 0x70, 0xf8, 0xc7, 0xeb, 0xe0,
	0x20, 0x00, 0x0f, 0x48, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xde, 0x01, 0x91, 0x66, 0x00, 0x83, 0x60, 0x40,
	0x14, 0xa4, 0xdf, 0x00, 0x22, 0x20, 0x9b, 0x60, 0x20, 0x00, 0x0d, 0x14, 0xbe, 0xe8, 0x90, 0x85,
	0xbf, 0x18, 0x88, 0xd2, 0x8a, 0xa8, 0x3b, 0x55, 0x8f, 0x47, 0x84, 0x20, 0x00, 0x00, 0x0f, 0x48,
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xe0,
}

// Frame 290 (532 bytes)
var packet6F_532 = []byte{
	0x6f, 0x80, 0xc8, 0xb3, 0x40, 0x41, 0xb0, 0x20, 0x14, 0xa4, 0xdf, 0x00, 0x22, 0x40, 0x97, 0x60,
	0x20, 0x00, 0x0e, 0xeb, 0xdf, 0x48, 0x9e, 0xf0, 0x9e, 0x58, 0x86, 0x17, 0x6b, 0xe8, 0x2c, 0x7b,
	0xf6, 0x88, 0x42, 0x80, 0x20, 0x00, 0x0f, 0x48, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xe0, 0x01, 0x91, 0x67,
	0x00, 0x83, 0x60, 0x40, 0x14, 0xa4, 0xdf, 0x00, 0x23, 0xc0, 0x85, 0x40, 0x40, 0x00, 0x0e, 0xe1,
	0xde, 0x28, 0x9f, 0x6c, 0x1c, 0x18, 0x8c, 0xd1, 0x0a, 0xe8, 0x29, 0xb2, 0xb0, 0xc8, 0x61, 0xe4,
	0x00, 0x00, 0x0f, 0x48, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xe1, 0x01, 0x91, 0x67, 0x80, 0x83, 0x60, 0x40,
	0x14, 0xa4, 0xdf, 0x00, 0x23, 0xe0, 0x9b, 0x60, 0x20, 0x00, 0x0e, 0xe2, 0x7e, 0xe8, 0x82, 0x5e,
	0xba, 0xf8, 0x98, 0xe9, 0x6f, 0x88, 0x3c, 0x88, 0x90, 0xe8, 0x64, 0x20, 0x00, 0x00, 0x0f, 0x48,
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xe0, 0xe2, 0x01, 0x91, 0x68, 0x00, 0x83, 0x60, 0x40, 0x14, 0xa4, 0xdf, 0x00,
	0x3e, 0x20, 0x83, 0xc0, 0x40, 0x00, 0x04, 0x74, 0x9c, 0x08, 0x90, 0xf4, 0x7a, 0x98, 0x88, 0x8d,
	0x2a, 0x88, 0x36, 0x91, 0x06, 0x68, 0x63, 0xeb, 0xa0, 0x00, 0x0f, 0x48, 0x80, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0,
	0xe3, 0x01, 0x91, 0x68, 0x80, 0x83, 0x60, 0x40, 0x14, 0xa4, 0xdf, 0x00, 0x3e, 0x40, 0x81, 0x20,
	0x40, 0x00, 0x01, 0x5f, 0xdc, 0x28, 0x82, 0x81, 0x9a, 0x78, 0x8e, 0x96, 0xaa, 0x28, 0x22, 0xb7,
	0xba, 0x48, 0x49, 0x61, 0xa0, 0x00, 0x0f, 0x48, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xe4, 0x01, 0x91, 0x69,
	0x00, 0x83, 0x60, 0x40, 0x14, 0xa4, 0xdf, 0x00, 0x3e, 0x60, 0x93, 0xc0, 0x20, 0x00, 0x10, 0xb7,
	0x7b, 0xc8, 0x84, 0xb5, 0x7a, 0x98, 0x9f, 0xb0, 0xeb, 0x28, 0x3c, 0xac, 0x2e, 0xa8, 0x03, 0x20,
	0x20, 0x00, 0x0f, 0x48, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xe5, 0x01, 0x91, 0x69, 0x80, 0x83, 0x60, 0x40,
	0x14, 0xa4, 0xdf, 0x00, 0x3e, 0xc0, 0x96, 0xe0, 0x20, 0x00, 0x1b, 0xda, 0x7a, 0x08, 0x9a, 0xdb,
	0x9d, 0x78, 0x83, 0xc2, 0xca, 0xe8, 0x3f, 0xb0, 0xe7, 0x08, 0x08, 0x29, 0xe0, 0x00, 0x0f, 0x48,
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xe0,
}

// Frame 291 (536 bytes)
var packet73_536 = []byte{
	0x73, 0x00, 0xc8, 0xb5, 0x00, 0x41, 0xb0, 0x20, 0x14, 0xa4, 0xdf, 0x00, 0x3e, 0xe0, 0x93, 0xc0,
	0x20, 0x00, 0x1d, 0x95, 0xf9, 0xc8, 0x93, 0x76, 0x9c, 0xb8, 0x8e, 0x27, 0xab, 0x48, 0x37, 0xef,
	0xb1, 0xa7, 0xe9, 0x00, 0x20, 0x00, 0x0f, 0x48, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xe7, 0x01, 0x91, 0x6a,
	0x80, 0x83, 0x60, 0x40, 0x14, 0xa4, 0xdf, 0x00, 0x20, 0x40, 0xb4, 0x80, 0x20, 0x00, 0x14, 0xfe,
	0x7b, 0xa8, 0x8a, 0x50, 0x1d, 0x18, 0x8b, 0x4c, 0x8a, 0x88, 0x35, 0xb3, 0x30, 0xc8, 0x60, 0xc0,
	0x20, 0x00, 0x0f, 0x48, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xe8, 0x01, 0x91, 0x6b, 0x00, 0x83, 0x60, 0x40,
	0x14, 0xa4, 0xdf, 0x00, 0x20, 0x60, 0xb4, 0x80, 0x20, 0x00, 0x0c, 0x6c, 0x1b, 0x88, 0x83, 0xd0,
	0x1d, 0x18, 0x8a, 0xeb, 0x6a, 0x88, 0x2c, 0x14, 0xd0, 0xe8, 0x60, 0xc0, 0x20, 0x00, 0x0f, 0x48,
	0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xe0, 0xe9, 0x01, 0x91, 0x6b, 0x80, 0x83, 0x60, 0x40, 0x14, 0xa4, 0xdf, 0x00,
	0x20, 0x80, 0xb4, 0x80, 0x20, 0x00, 0x1e, 0x53, 0xbb, 0x48, 0x8d, 0x0f, 0xdd, 0x18, 0x90, 0xcb,
	0x4a, 0x88, 0x2f, 0x06, 0x50, 0xe8, 0x60, 0xc0, 0x20, 0x00, 0x0f, 0x48, 0x80, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0,
	0xea, 0x01, 0x91, 0x6c, 0x00, 0x83, 0x60, 0x40, 0x14, 0xa4, 0xdf, 0x00, 0x20, 0xa0, 0xb4, 0x80,
	0x20, 0x00, 0x13, 0xba, 0xbb, 0x08, 0x98, 0xef, 0xbd, 0x18, 0x89, 0xcc, 0x4a, 0x88, 0x28, 0xa9,
	0x10, 0xe8, 0x60, 0xc0, 0x20, 0x00, 0x0f, 0x48, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xeb, 0x01, 0x91, 0x6c,
	0x80, 0xa2, 0xc0, 0x14, 0xa5, 0xe1, 0x00, 0x60, 0x50, 0xec, 0x01, 0x91, 0x6d, 0x00, 0xa2, 0xc0,
	0x14, 0xa5, 0xe1, 0x00, 0x70, 0x50, 0xed, 0x01, 0x91, 0x6d, 0x80, 0xa2, 0xc0, 0x14, 0xa5, 0xe1,
	0x00, 0x80, 0x50, 0xee, 0x01, 0x91, 0x6e, 0x00, 0xa2, 0xc0, 0x14, 0xa5, 0xe1, 0x00, 0x90, 0x50,
	0xef, 0x01, 0x91, 0x6e, 0x80, 0xa2, 0xc0, 0x14, 0xa5, 0xe1, 0x00, 0xa0, 0x50, 0xf0, 0x01, 0x91,
	0x6f, 0x00, 0xa2, 0xc0, 0x14, 0xa5, 0xe1, 0x00, 0xb0, 0x50, 0xf1, 0x01, 0x91, 0x6f, 0x80, 0xa2,
	0xc0, 0x14, 0xa5, 0xe1, 0x00, 0xc0, 0x50, 0xf2, 0x01, 0x91, 0x70, 0x00, 0xa2, 0xc0, 0x14, 0xa5,
	0xe1, 0x00, 0xd0, 0x50, 0xf3, 0x01, 0x91, 0x70, 0x80, 0xa2, 0xc0, 0x14, 0xa5, 0xe1, 0x00, 0xe0,
	0x50, 0xf4, 0x01, 0x91, 0x71, 0x00, 0xa2, 0xc0, 0x14, 0xa5, 0xe1, 0x00, 0xf0, 0x50, 0xf5, 0x01,
	0x91, 0x71, 0x80, 0xa2, 0xc0, 0x14, 0xa5, 0xe1, 0x01, 0x00, 0x50, 0xf6, 0x01, 0x91, 0x72, 0x00,
	0xa2, 0xc0, 0x14, 0xa5, 0xe1, 0x01, 0x10, 0x50,
}

// Frame 292 (153 bytes)
var packet7B_153 = []byte{
	0x7b, 0x80, 0xc8, 0xb9, 0x40, 0x51, 0x60, 0x14, 0xa5, 0xe1, 0x01, 0x20, 0x50, 0xf8, 0x01, 0x91,
	0x73, 0x00, 0xad, 0xc0, 0x14, 0x5f, 0xec, 0x09, 0x50, 0x00, 0x00, 0x0f, 0x80, 0x40, 0x00, 0x01,
	0x70, 0x00, 0x00, 0x0a, 0xe7, 0x5e, 0x54, 0x4a, 0x14, 0xfd, 0x2c, 0x46, 0x41, 0x35, 0x64, 0x10,
	0xf9, 0x01, 0x91, 0x73, 0x80, 0xad, 0xc0, 0x14, 0x5f, 0xec, 0x0d, 0x90, 0x00, 0x00, 0x0f, 0x80,
	0x40, 0x00, 0x01, 0x70, 0x00, 0x00, 0x06, 0xbf, 0x8f, 0x64, 0x4d, 0xa9, 0x4f, 0xec, 0x40, 0x0c,
	0x05, 0x84, 0x10, 0xfa, 0x01, 0x91, 0x74, 0x00, 0xad, 0xc0, 0x14, 0x5f, 0xec, 0x0d, 0xa0, 0x00,
	0x00, 0x0f, 0x80, 0x40, 0x00, 0x01, 0x70, 0x00, 0x00, 0x0a, 0x6a, 0x2f, 0x24, 0x42, 0xf4, 0x00,
	0x4c, 0x5f, 0xf1, 0xf5, 0xb4, 0x10, 0xfb, 0x01, 0x91, 0x74, 0x80, 0xad, 0xc0, 0x14, 0x5f, 0xec,
	0x0d, 0xb0, 0x00, 0x00, 0x0f, 0x80, 0x40, 0x00, 0x01, 0x70, 0x00, 0x00, 0x03, 0xd0, 0xee, 0x54,
	0x45, 0xa5, 0x3e, 0x6c, 0x40, 0x04, 0x05, 0x94, 0x10,
}

// Urutan lengkap burst (tambahkan ke sendJoinResponseSequence setelah packet51_530):
//
// burst := [][]byte{
//     packet51_530,  // frame 284
//     packet58_534,  // frame 285
//     packet5E_547,  // frame 286
//     packet65_532,  // frame 287
//     packet68_532,  // frame 288
//     packet6C_532,  // frame 289
//     packet6F_532,  // frame 290
//     packet73_536,  // frame 291
//     packet7B_153,  // frame 292
// }

// Handshake sequence packets (after first 0x88)
// FIX #8: E3:00 challenge - MUST be exactly 25 bytes (verified from Wireshark)
// Official: e3:00:00:00:00:85:20:0c:10:34:34:44:33:33:46:33:34:45:46:45:34:45:46:35:00
// Breakdown: [header 9 bytes][version 15 bytes][null 1 byte] = 25 bytes total
var packetE3_00 = []byte{
	// Header (9 bytes)
	0xE3, 0x00,                               // Packet ID + subtype
	0x00, 0x00, 0x00, 0x85, 0x20, 0x0C, 0x10, // Fixed values
	// Version string (15 bytes) - "44D33F34EFE4EF5"
	0x34, 0x34, 0x44, 0x33, 0x33, 0x46, 0x33, 0x34,
	0x45, 0x46, 0x45, 0x34, 0x45, 0x46, 0x35,
	// Null terminator (1 byte)
	0x00,
	// Total: 9 + 15 + 1 = 25 bytes 
}

var packetE3_01 = []byte{0xe3, 0x01, 0x00}

// Packet variable declarations moved to lines 3492+ for complete data

// Step 7b: 0x4A (465 bytes) [Frame 283]
var packet4A_465 = []byte{
	0x4a, 0x00, 0xc8, 0xa0, 0xc0, 0x56, 0x80, 0x14, 0x56, 0xeb, 0x40, 0x00, 0x00, 0x64, 0x24, 0xf4,
	0xd4, 0x24, 0x55, 0x20, 0x46, 0xe7, 0x56, 0xc6, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x95, 0x01, 0x91, 0x42, 0x00, 0xad, 0x80, 0x14, 0x56, 0xeb, 0xc0, 0x00, 0x00, 0x75, 0x24,
	0x15, 0x05, 0x04, 0x94, 0xe4, 0x70, 0x46, 0xe7, 0x56, 0xc6, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x96, 0x01, 0x91, 0x42, 0x80, 0xac, 0x00, 0x14, 0x56, 0xea, 0x40, 0x00, 0x00,
	0x45, 0x34, 0x84, 0xf5, 0x00, 0x46, 0xe7, 0x56, 0xc6, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x97, 0x01, 0x91, 0x43, 0x00, 0xac, 0x80, 0x14, 0x56, 0xea, 0xc0, 0x00, 0x00, 0x54,
	0x24, 0x54, 0x14, 0x34, 0x80, 0x46, 0xe7, 0x56, 0xc6, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x98, 0x01, 0x91, 0x43, 0x80, 0xad, 0x80, 0x14, 0x56, 0xeb, 0xc0, 0x00, 0x00, 0x75,
	0x34, 0xd4, 0xf4, 0xb4, 0x94, 0xe4, 0x70, 0x46, 0xe7, 0x56, 0xc6, 0xc0, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x99, 0x01, 0x91, 0x44, 0x00, 0xac, 0x00, 0x14, 0x56, 0xea, 0x40, 0x00,
	0x00, 0x44, 0x64, 0xf4, 0xf4, 0x40, 0x46, 0xe7, 0x56, 0xc6, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x9a, 0x01, 0x91, 0x44, 0x80, 0xaf, 0x00, 0x14, 0x56, 0xed, 0x40, 0x00, 0x00,
	0xa4, 0xf4, 0xe5, 0xf4, 0xc4, 0xf4, 0xf4, 0xb4, 0x55, 0x25, 0x30, 0x46, 0xe7, 0x56, 0xc6, 0xc0,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9b, 0x01, 0x91, 0x45, 0x00, 0xad, 0x00, 0x14,
	0x56, 0xeb, 0x40, 0x00, 0x00, 0x64, 0x44, 0x54, 0x14, 0xc4, 0x55, 0x20, 0x46, 0xe7, 0x56, 0xc6,
	0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9c, 0x01, 0x91, 0x45, 0x80, 0xac, 0x80,
	0x14, 0x56, 0xea, 0xc0, 0x00, 0x00, 0x54, 0x35, 0x24, 0x14, 0x34, 0xb0, 0x46, 0xe7, 0x56, 0xc6,
	0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9d, 0x01, 0x91, 0x46, 0x00, 0xac, 0x80,
	0x14, 0x56, 0xea, 0xc0, 0x00, 0x00, 0x54, 0x34, 0x15, 0x25, 0x25, 0x90, 0x46, 0xe7, 0x56, 0xc6,
	0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9e, 0x01, 0x91, 0x46, 0x80, 0xaf, 0x80,
	0x14, 0x56, 0xed, 0xc0, 0x00, 0x00, 0xb4, 0x34, 0xf5, 0x05, 0xf4, 0x14, 0xd4, 0x24, 0x94, 0x54,
	0xe5, 0x40, 0x46, 0xe7, 0x56, 0xc6, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9f,
	0x01, 0x91, 0x47, 0x00, 0xac, 0x00, 0x14, 0x56, 0xea, 0x40, 0x00, 0x00, 0x45, 0x04, 0x15, 0x24,
	0xb0, 0x46, 0xe7, 0x56, 0xc6, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa0, 0x01,
	0x91, 0x47, 0x80, 0xae, 0x80, 0x14, 0x56, 0xec, 0xc0, 0x00, 0x00, 0x94, 0x94, 0xe5, 0x45, 0xf4,
	0x84, 0xf5, 0x55, 0x34, 0x50, 0x46, 0xe7, 0x56, 0xc6, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xa1, 0x01, 0x91, 0x48, 0x00, 0xac, 0x00, 0x14, 0x56, 0xea, 0x40, 0x00, 0x00, 0x44,
	0x64, 0xf4, 0xf4, 0x40, 0x46, 0xe7, 0x56, 0xc6, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00,
}

// Step 8: 0x51 (530 bytes) [Frame 284]
var packet51_530 = []byte{
	0x51, 0x00, 0xc8, 0xa4, 0x40, 0x46, 0x30, 0x20, 0x14, 0x86, 0xc8, 0x00, 0x40, 0xa0, 0x02, 0x80,
	0x00, 0x00, 0x07, 0xe0, 0x00, 0x18, 0x07, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x14, 0x08, 0x80,
	0x00, 0x14, 0x08, 0x90, 0x10, 0x10, 0x10, 0x00, 0x00, 0x40, 0x00, 0x00, 0x1f, 0xe0, 0x60, 0x00,
	0x08, 0x02, 0xe8, 0x80, 0x00, 0x19, 0x08, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x07, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xa0, 0x06,
	0x26, 0xc7, 0x46, 0x06, 0x40, 0xa3, 0x01, 0x91, 0x49, 0x00, 0xa2, 0xc0, 0x14, 0x1d, 0xe1, 0x01,
	0x00, 0x30, 0xa4, 0x01, 0x91, 0x49, 0x80, 0xa2, 0x00, 0x14, 0x9c, 0xf8, 0x00, 0xa5, 0x01, 0x91,
	0x4a, 0x00, 0xa2, 0x00, 0x14, 0x1e, 0xf8, 0x00, 0xa6, 0x01, 0x91, 0x4a, 0x80, 0xa2, 0x00, 0x14,
	0x14, 0xf0, 0xf0, 0xa7, 0x01, 0x91, 0x4b, 0x00, 0xa3, 0xc0, 0x14, 0x12, 0xe2, 0x03, 0x07, 0x50,
	0x00, 0x00, 0xa8, 0x01, 0x91, 0x4b, 0x80, 0xa7, 0xc0, 0x14, 0x0c, 0xe6, 0x0f, 0x36, 0x5a, 0x24,
	0x43, 0x25, 0xb4, 0x8c, 0x4f, 0xd4, 0x7a, 0x84, 0x20, 0xa9, 0x01, 0x91, 0x4c, 0x00, 0xa3, 0xc0,
	0x14, 0x13, 0xe2, 0x08, 0x2c, 0x38, 0x64, 0x30, 0xaa, 0x01, 0x91, 0x4c, 0x80, 0xa5, 0xc0, 0x14,
	0x16, 0xe4, 0x01, 0x60, 0x00, 0x00, 0x06, 0x40, 0x00, 0x00, 0x00, 0xab, 0x01, 0x91, 0x4d, 0x00,
	0xa2, 0x00, 0x14, 0x1e, 0xf8, 0x00, 0xac, 0x01, 0x70, 0x80, 0x80, 0x22, 0x80, 0xd0, 0x00, 0x00,
	0x00, 0x00, 0xad, 0x01, 0x91, 0x4d, 0x80, 0x83, 0x60, 0x40, 0x14, 0xa4, 0xdf, 0x00, 0x21, 0x20,
	0x03, 0x40, 0x40, 0x00, 0x05, 0x53, 0x1a, 0x88, 0x9c, 0xc6, 0x9e, 0x98, 0x8e, 0xa0, 0x4d, 0xc8,
	0x20, 0x00, 0x09, 0x08, 0x7f, 0xff, 0xe0, 0x00, 0x0f, 0x48, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xae, 0x01,
	0x91, 0x4e, 0x00, 0x83, 0x60, 0x40, 0x14, 0xa4, 0xdf, 0x00, 0x3f, 0x00, 0x4a, 0x80, 0x40, 0x00,
	0x0d, 0xa9, 0xb9, 0x08, 0x8b, 0xcf, 0x9a, 0x58, 0x95, 0xf2, 0x96, 0x68, 0x17, 0xfd, 0xd0, 0xc8,
	0x60, 0x00, 0x20, 0x00, 0x0f, 0x48, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xaf, 0x01, 0x91, 0x4e, 0x80, 0x83,
	0x60, 0x40, 0x14, 0xa4, 0xdf, 0x00, 0x3f, 0x20, 0x4a, 0x80, 0x40, 0x00, 0x1e, 0x9d, 0xf8, 0xc8,
	0x8b, 0x3c, 0x3a, 0xb8, 0x81, 0xf3, 0x96, 0x68, 0x18, 0xbf, 0xc6, 0x47, 0xa0, 0x00, 0x20, 0x00,
	0x0f, 0x48, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0xb0, 0x01, 0x91, 0x4f, 0x00, 0x83, 0x60, 0x40, 0x14, 0xa4,
	0xdf, 0x00, 0x3f, 0x40, 0x4a, 0x80, 0x40, 0x00, 0x0e, 0x68, 0xd9, 0x08, 0x9a, 0x5f, 0xfa, 0x58,
	0x9b, 0x71, 0x56, 0x68, 0x1b, 0x16, 0x16, 0x68, 0x40, 0x00, 0x20, 0x00, 0x0f, 0x48, 0x80, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xe0,
}

func init() {
	b := make([]byte, 8)
	crypto_rand.Read(b)
	serverGUID = binary.BigEndian.Uint64(b)
	log.Printf(" Generated server GUID: %d (0x%016X)", serverGUID, serverGUID)
	
	testPort := 63532
	testAddr := &net.UDPAddr{IP: net.ParseIP("127.0.0.1"), Port: testPort}
	encoded := encodeAddressV2(testAddr)
	expectedLo := byte(uint16(testPort) & 0xFF)
	expectedHi := byte(uint16(testPort) >> 8)
	if encoded[5] != expectedLo || encoded[6] != expectedHi {
		panic(fmt.Sprintf("encodeAddress BUG: dapat %02x %02x, ekspektasi %02x %02x",
			encoded[5], encoded[6], expectedLo, expectedHi))
	}
	log.Printf(" encodeAddress verified: port %d = %02x %02x", testPort, encoded[5], encoded[6])
}

type RakNetHandler struct {
	sessions      map[string]*protocol.Session // key: "ip:port"
	sessionsByIP  map[string]*protocol.Session // key: "ip" only (for port migration)
	sessionsByGUID map[uint64]*protocol.Session // key: client GUID (for session migration)
	conn          *net.UDPConn
	server        *Server                       // Reference to server for config access
	mu            sync.RWMutex
	serverGUID    uint64
	cookieTable   map[string]uint32 // key: "ip:port", value: cookie
	onPacket      func(*protocol.Session, *protocol.RakNetPacket)
	running       bool
}

func NewRakNetHandler(conn *net.UDPConn, server *Server) *RakNetHandler {
	return &RakNetHandler{
		sessions:       make(map[string]*protocol.Session),
		sessionsByIP:   make(map[string]*protocol.Session),
		sessionsByGUID: make(map[uint64]*protocol.Session),
		conn:           conn,
		server:         server,
		serverGUID:     serverGUID, // Use package-level GUID
		cookieTable:    make(map[string]uint32),
		running:        true,
	}
}

func (rh *RakNetHandler) SetPacketHandler(handler func(*protocol.Session, *protocol.RakNetPacket)) {
	rh.onPacket = handler
}

func (rh *RakNetHandler) HandlePacket(data []byte, addr *net.UDPAddr) {
	if len(data) == 0 {
		return
	}
	
	// Check for SA-MP query packets (starts with "SAMP")
	if len(data) >= 11 && string(data[0:4]) == "SAMP" {
		rh.handleSAMPQuery(data, addr)
		return
	}
	
	packetID := data[0]
	sessionKey := addr.String()
	
	// Check if this is a RakNet data packet (bit 7 set)
	isDataPacket := (packetID & 0x80) != 0
	
	// Get session
	rh.mu.RLock()
	session, sessionExists := rh.sessions[sessionKey]
	rh.mu.RUnlock()
	
	// ============================================================
	// SIMPLIFIED PACKET DISPATCHER (v5 - Complete Refactor)
	// ============================================================
	
	//  STEP 1: Cookie Request 
	if packetID == 0x08 && len(data) == 4 {
		rh.handleCookieRequest(data, addr, session)
		return
	}
	
	//  STEP 2: OpenConnectionRequest2 (all variants) 
	if len(data) == 4 && sessionExists {
		session.Mu.RLock()
		state := session.State
		session.Mu.RUnlock()
		
		if state == protocol.STATE_HANDSHAKE_SENT {
			// SA-MP client sends 0x00, 0x02, 0x80, 0x82, 0x8A  all valid
			log.Printf("[0x%02X] Connection response from %s  sending 0x19", packetID, addr)
			rh.sendOpenConnectionReply2(session)
			return
		}
	}
	
	//  STEP 3: Auth 
	if packetID == 0x88 && len(data) == 6 {
		rh.handleAuthPacket(data, addr, session)
		return
	}
	
	//  STEP 4: ACK from client 
	if packetID == 0xA2 && len(data) == 4 {
		log.Printf("[0xA2] ACK from %s", addr)
		// No action needed, client already received E3:00
		return
	}
	
	//  STEP 5: Login data 
	if packetID == 0x22 {
		rh.handleLoginData(data, addr, session)
		return
	}
	
	//  STEP 6: 0x0A keepalive vs Full Conn Req 
	if packetID == 0x0A {
		if len(data) >= 84 && sessionExists {
			rh.handleFullConnectionRequest(data, addr, session)
		}
		// < 84 bytes = keepalive, ignore
		return
	}
	
	//  Keepalive in-game 
	if packetID == 0x80 && len(data) == 6 && sessionExists {
		// Send ACK for keepalive
		ack := protocol.NewACK()
		ack.Packets = append(ack.Packets, 0)
		ackData := ack.Encode()
		rh.conn.WriteToUDP(ackData, session.Addr)
		return
	}
	
	// ============================================================
	// FALLBACK TO OLD HANDLERS (for other packets)
	// ============================================================
	
	// Log packets for debugging
	if sessionExists {
		session.Mu.RLock()
		state := session.State
		gameEntrySent := session.GameEntrySent
		session.Mu.RUnlock()
		
		if state == protocol.STATE_IN_GAME || gameEntrySent {
			log.Printf(" [IN_GAME] Received packet 0x%02X (%d bytes) from %s (state=%d, gameEntrySent=%v)", 
				packetID, len(data), addr.String(), state, gameEntrySent)
		}
	}
	
	if packetID != 0x53 && packetID != 0x70 {
		log.Printf("Received packet 0x%02X (%d bytes) from %s", packetID, len(data), addr.String())
	}
	
	// 
	// FIX #10: Handle 4-byte data packets (0x80, 0x82, etc.) as connection response
	// SA-MP client sends 0x82 (DATA + ACK_REQUEST) after receiving 0x1A
	// 
	if isDataPacket && len(data) == 4 {
		log.Printf(" Detected 4-byte data packet 0x%02X from %s", packetID, addr)
		
		if sessionExists {
			session.Mu.RLock()
			state := session.State
			session.Mu.RUnlock()
			
			if state == protocol.STATE_HANDSHAKE_SENT {
				// FIX #10: This is the connection response after 0x1A!
				log.Printf(" Connection response 0x%02X from %s  sending 0x19", packetID, addr)
				
				// Send 0x19 (ConnectionRequestAccepted)
				response := []byte{0x19, 0x00}
				rh.conn.WriteToUDP(response, addr)
				log.Printf(" Sent 0x19 to %s", addr)
				
				// Update session state
				session.Mu.Lock()
				session.State = protocol.STATE_CONNECTING
				session.LastReceiveTime = time.Now()
				session.Mu.Unlock()
				
				return
			}
		} else {
			// FIX #12: Session rebinding for port changes
			// SA-MP client may switch UDP port during login-to-game transition
			// Same IP = same logical connection, even if port changes
			log.Printf(" 4-byte data packet from unknown session %s", addr)
			
			// Check if same IP has an existing active session on different port
			clientIP := addr.IP.String()
			var existingSession *protocol.Session
			var oldSessionKey string
			
			rh.mu.RLock()
			for sessKey, sess := range rh.sessions {
				if sess.Addr.IP.String() == clientIP && sess.State >= protocol.STATE_LOGIN_COMPLETE {
					existingSession = sess
					oldSessionKey = sessKey
					log.Printf("   Found existing session for IP %s on %s (state=%d)", clientIP, sessKey, sess.State)
					break
				}
			}
			rh.mu.RUnlock()
			
			// If existing session found, rebind to new port
			if existingSession != nil {
				log.Printf(" Rebinding session from %s to %s", oldSessionKey, addr)
				
				// Update session address to new port
				existingSession.Mu.Lock()
				existingSession.Addr = addr
				existingSession.Mu.Unlock()
				
				// Register new port in sessions map
				rh.mu.Lock()
				rh.sessions[sessionKey] = existingSession
				rh.mu.Unlock()
				
				log.Printf(" Session rebound to new port - NO 0x1A sent, NO new session created")
				log.Printf(" Client port switch handled - session stable")
				return
			}
			
			// No existing session for this IP - create new session
			log.Printf("   No active session found for IP %s - creating new session", clientIP)
			
			// Send 0x1A to this port
			clientPort := uint16(addr.Port)
			hi := byte(clientPort >> 8)
			lo := byte(clientPort & 0xFF)
			encoded0 := hi ^ 0x82
			encoded1 := lo ^ 0x93
			cookieResponse := []byte{0x1A, encoded0, encoded1}
			rh.conn.WriteToUDP(cookieResponse, addr)
			
			// Create session for this port
			rh.mu.Lock()
			newSession := protocol.NewSession(addr, protocol.DEFAULT_MTU_SIZE)
			newSession.State = protocol.STATE_HANDSHAKE_SENT
			rh.sessions[sessionKey] = newSession
			rh.mu.Unlock()
			
			log.Printf(" Created new session and sent 0x1A to %s", addr)
			return
		}
	}
	
	// CRITICAL: 0x28 is SA-MP join request sent as RAW UDP (not RakNet datagram)
	// This is the ONLY place that should trigger game entry + join response sequence
	if packetID == 0x28 {
		rh.mu.RLock()
		session, exists := rh.sessions[addr.String()]
		rh.mu.RUnlock()
		
		if !exists {
			// Port baru dari client yang sudah in-game
			// SA-MP client sering buka port baru untuk konfirmasi akhir
			log.Printf(" Received 0x28 from %s but no session exists - searching by IP", addr)
			
			// Cari session berdasarkan IP saja (ignore port)
			ip := addr.IP.String()
			var existingSession *protocol.Session
			
			rh.mu.RLock()
			for _, sess := range rh.sessions {
				if sess.Addr.IP.String() == ip && sess.GetGameEntrySent() {
					existingSession = sess
					log.Printf(" Found existing session for IP %s (original port: %d)", ip, sess.Addr.Port)
					break
				}
			}
			rh.mu.RUnlock()
			
			if existingSession == nil {
				log.Printf(" 0x28 from %s but no active session found for IP %s", addr, ip)
				return
			}
			
			// Register port baru ke session yang ada
			rh.mu.Lock()
			rh.sessions[addr.String()] = existingSession
			rh.mu.Unlock()
			log.Printf(" Associated new port %d to session for IP %s", addr.Port, ip)
			
			// Update session address to new port
			existingSession.Mu.Lock()
			existingSession.Addr = addr
			existingSession.Mu.Unlock()
			
			// Send ACK for the 0x28 packet to new port
			ack := protocol.NewACK()
			ack.Packets = append(ack.Packets, 0) // ACK with dummy sequence
			ackData := ack.Encode()
			rh.conn.WriteToUDP(ackData, addr)
			log.Printf(" Sent ACK for 0x28 to new port %d", addr.Port)
			
			// Resend e3:21 spawn trigger to new port
			e321 := []byte{0xe3, 0x21, 0x00}
			rh.conn.WriteToUDP(e321, addr)
			log.Printf(" Sent e3:21 spawn trigger to new port %d", addr.Port)
			log.Printf(" Player spawned! Game entry complete for %s", ip)
			
			return
		}
		
		// Update last receive time
		session.UpdateLastReceiveTime()
		
		// Check if join response already sent
		if session.GetJoinResponseSent() {
			// Client is resending 0x28 - likely didn't receive all packets
			// Resend e3:21 as spawn trigger
			log.Printf(" Received 0x28 resend from %s (%d bytes) - sending e3:21 spawn trigger", addr, len(data))
			
			// Send ACK for the 0x28 packet
			ack := protocol.NewACK()
			ack.Packets = append(ack.Packets, 0) // ACK with dummy sequence
			ackData := ack.Encode()
			rh.conn.WriteToUDP(ackData, addr)
			log.Printf(" Sent ACK for 0x28 resend")
			
			// Resend e3:21 spawn trigger
			e321 := []byte{0xe3, 0x21, 0x00}
			rh.conn.WriteToUDP(e321, addr)
			log.Printf(" Resent e3:21 spawn trigger")
		} else {
			// 0x28 diterima pertama kali.
			// Setelah fix 0x8A: game entry harusnya SUDAH dikirim.
			// 0x28 dari client = konfirmasi + bisa dari port baru.
			
			session.Mu.RLock()
			gameEntrySent := session.GameEntrySent
			currentState := session.State
			session.Mu.RUnlock()
			
			// ACK dulu
			ack := protocol.NewACK()
			ack.Packets = append(ack.Packets, 0)
			rh.conn.WriteToUDP(ack.Encode(), addr)
			log.Printf(" Sent ACK for 0x28")
			
			// CRITICAL: Don't resend anything if already in game
			if currentState >= protocol.STATE_IN_GAME && gameEntrySent {
				log.Printf(" [0x28] Already in game (state=%d) - normal keepalive, no resend", currentState)
				log.Printf(" Player session stable for %s", addr)
				return
			}
			
			if gameEntrySent {
				// Game entry sent but not yet in final state - this is the FIRST 0x28
				// This means client received spawn sequence and is syncing
				log.Printf(" [0x28] First confirmation after spawn sequence - client syncing")
				log.Printf(" Client sync received! Waiting for stable state before world streaming...")
				
				// Update state to IN_GAME
				session.Mu.Lock()
				session.State = protocol.STATE_IN_GAME
				session.Mu.Unlock()
				
				// Start world streaming after a small delay to let client stabilize
				go func() {
					time.Sleep(300 * time.Millisecond)
					log.Printf(" Starting world streaming for %s after client sync...", addr)
					rh.sendWorldStreamingPackets(session)
				}()
			} else {
				// Game entry not sent yet - this should not happen in normal flow
				// 0x28 should only come AFTER 0x8A triggers game entry
				log.Printf(" [0x28] Received before game entry sent - ignoring (waiting for 0x8A)")
			}
		}
		return
	}
	
	// Check if it's a data packet (bit 7 set = 0x80-0x8F)
	// 0x80, 0x82, 0x84, 0x86, 0x88, 0x8A, 0x8C, 0x8E are all RakNet data packets
	// Note: isDataPacket already declared above, reuse it here
	
	if isDataPacket {
		// Update session last receive time
		rh.mu.RLock()
		if sess, exists := rh.sessions[addr.String()]; exists {
			sess.LastReceiveTime = time.Now()
			// Upgrade state if receiving data packets
			if sess.State == protocol.STATE_HANDSHAKE_SENT {
				sess.State = protocol.STATE_CONNECTING
				log.Printf("Session %s upgraded to CONNECTING (received data packet)", addr.String())
			}
		}
		rh.mu.RUnlock()
		
		rh.handleDataPacket(data, addr)
		return
	}
	
	switch packetID {
	case 0x00:
		// CRITICAL DEBUG: Log all 0x00 packets with full hex
		log.Printf(" [0x00] Received %d bytes from %s", len(data), addr)
		log.Printf("   Raw hex: %s", hex.EncodeToString(data))
		
		// 0x00 has dual meaning:
		// 1. OpenConnectionRequest2 (during handshake, 4 bytes)
		// 2. ID_CONNECTED_PING (in-game keepalive, 6+ bytes)
		
		rh.mu.RLock()
		session, exists := rh.sessions[addr.String()]
		rh.mu.RUnlock()
		
		if !exists {
			// Check if this IP has an active session with game entry sent
			clientIP := addr.IP.String()
			var hasActiveSession bool
			rh.mu.RLock()
			for _, sess := range rh.sessions {
				if sess.Addr.IP.String() == clientIP {
					sess.Mu.RLock()
					gameEntrySent := sess.GameEntrySent
					sess.Mu.RUnlock()
					if gameEntrySent {
						hasActiveSession = true
						break
					}
				}
			}
			rh.mu.RUnlock()
			
			if hasActiveSession {
				log.Printf(" [0x00] Active session for IP %s  sending 0x1A to new port %d", clientIP, addr.Port)
				
				// Create session for new port
				rh.mu.Lock()
				newSession := protocol.NewSession(addr, protocol.DEFAULT_MTU_SIZE)
				newSession.State = protocol.STATE_HANDSHAKE_SENT
				newSession.GameEntrySent = true // Inherit state
				rh.sessions[addr.String()] = newSession
				rh.mu.Unlock()
				
				// Send 0x1A Open Connection Reply 2
				reply := []byte{
					0x1A, // ID_OPEN_CONNECTION_REPLY_2
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Server GUID
					byte(addr.Port >> 8), byte(addr.Port), // Client port (big-endian)
					0x05, 0xDC, // MTU (1500)
					0x00, // Encryption enabled (0 = no)
				}
				rh.conn.WriteToUDP(reply, addr)
				log.Printf(" Sent 0x1A Open Connection Reply 2 to new port %s", addr)
				return
			}
			
			log.Printf(" Received 0x00 from unknown session: %s", addr)
			return
		}
		
		log.Printf("   Session state: %d (HANDSHAKE_SENT=%d)", session.State, protocol.STATE_HANDSHAKE_SENT)
		
		// FIX v4: Handle 0x00 (4 bytes) as OpenConnectionRequest2 during handshake
		if len(data) == 4 && session.State == protocol.STATE_HANDSHAKE_SENT {
			log.Printf(" Received 0x00 OpenConnectionRequest2 (4 bytes) from %s", addr)
			log.Printf("   Expected cookie: %02X", session.Cookie)
			log.Printf("   Received bytes: %02X %02X %02X %02X", data[0], data[1], data[2], data[3])
			
			// Send 0x19 (ConnectionRequestAccepted)
			response := []byte{0x19, 0x00}
			_, err := rh.conn.WriteToUDP(response, addr)
			if err != nil {
				log.Printf(" Failed to send 0x19: %v", err)
				return
			}
			
			log.Printf(" Sent 0x19 ConnectionRequestAccepted to %s", addr)
			
			// Update session state
			session.Mu.Lock()
			session.State = protocol.STATE_CONNECTING
			session.LastReceiveTime = time.Now()
			session.Mu.Unlock()
			
			log.Printf(" Session %s upgraded to CONNECTING", addr)
			return
		}
		
		// Otherwise, it's ID_CONNECTED_PING (in-game keepalive)
		// Update last receive time to prevent session cleanup
		session.UpdateLastReceiveTime()
		
		log.Printf(" Received ID_CONNECTED_PING from %s (state=%d, %d bytes)", addr, session.State, len(data))
		
		// Send ID_CONNECTED_PONG (0x03) - echo back all bytes after packet ID
		pong := make([]byte, len(data))
		pong[0] = 0x03 // ID_CONNECTED_PONG
		copy(pong[1:], data[1:]) // Echo timestamp and any other data
		
		_, err := rh.conn.WriteToUDP(pong, addr)
		if err != nil {
			log.Printf(" Failed to send pong: %v", err)
			return
		}
		
		log.Printf(" Sent ID_CONNECTED_PONG (0x03) to %s (%d bytes)", addr, len(pong))
		
		// CRITICAL: Trigger streaming if state=READY and not yet sent
		session.Mu.RLock()
		state := session.State
		gameEntrySent := session.GameEntrySent
		session.Mu.RUnlock()
		
		if state == protocol.STATE_READY && !gameEntrySent {
			log.Printf(" First ping after handshake - triggering streaming!")
			
			// Set to IN_GAME state before streaming
			session.Mu.Lock()
			session.State = protocol.STATE_IN_GAME
			session.Mu.Unlock()
			
			// All packets now sent in sendPostStreamingSequence
			// rh.sendStreamingData(addr) - REMOVED
			rh.sendPostStreamingSequence(addr)
			
			log.Printf(" Sent streaming data after 0x00 ping")
			return
		}
		
		// If session is IN_GAME, also send SA-MP periodic keepalive (e3)
		if session.State == protocol.STATE_IN_GAME {
			// Increment keepalive counter
			session.Mu.Lock()
			if session.ChannelOrderIndex == nil {
				session.ChannelOrderIndex = make(map[uint8]uint32)
			}
			// Use channel 255 for keepalive counter
			keepaliveCounter := session.ChannelOrderIndex[255]
			session.ChannelOrderIndex[255]++
			session.Mu.Unlock()
			
			// Send e3 keepalive with counter
			e3Keepalive := []byte{
				0xe3,
				byte(keepaliveCounter),
				0x00,
			}
			rh.conn.WriteToUDP(e3Keepalive, addr)
			log.Printf(" Sent e3:%02x periodic keepalive to %s", keepaliveCounter, addr)
		}
	case protocol.ID_UNCONNECTED_PING, protocol.ID_UNCONNECTED_PING_OPEN_CONNECTIONS:
		// FIX 2: Bedakan 0x02 berdasarkan state session
		if packetID == protocol.ID_UNCONNECTED_PING_OPEN_CONNECTIONS {
			// Check if this is from an active session
			rh.mu.RLock()
			session, exists := rh.sessions[addr.String()]
			rh.mu.RUnlock()
			
			if exists && session.State >= protocol.STATE_CONNECTING {
				// Dalam session aktif: ini bukan ping, abaikan
				log.Printf(" 0x02 in-session from %s, ignoring (not a ping)", addr)
				return
			}
		}
		
		// Unconnected context: handle as ping
		rh.handleUnconnectedPing(data, addr)
	case protocol.ID_OPEN_CONNECTION_REQUEST_1:
		rh.handleOpenConnectionRequest1(data, addr)
	case protocol.ID_OPEN_CONNECTION_REQUEST_2:
		rh.handleOpenConnectionRequest2(data, addr)
	case 0x08:
		// SA-MP uses 0x08 for multiple purposes (non-standard RakNet):
		// 1. Cookie request (4 bytes)
		// 2. Extended cookie request (10 bytes)
		// 3. Open Connection Request 1 (17 bytes) - SA-MP style
		// 4. Open Connection Request 2 (31+ bytes) - SA-MP style
		if len(data) == 4 {
			// Standard cookie request (4 bytes)
			rh.handleSAMPConnectionCookie(data, addr)
		} else if len(data) == 10 {
			// Extended cookie request (10 bytes)
			// Format: 0x08 + timestamp(4) + cookie(4) + extra(1)
			cookie := binary.LittleEndian.Uint32(data[5:9])
			log.Printf(" Extended cookie request from %s, cookie=0x%08X", addr, cookie)
			// Use the same handler but with extended format
			rh.handleSAMPConnectionCookie(data, addr)
		} else if len(data) >= 17 {
			// CRITICAL: SA-MP uses 0x08 for Open Connection Request (not 0x0A like standard RakNet)
			// This is ID_OPEN_CONNECTION_REQUEST_1 (17 bytes) or ID_OPEN_CONNECTION_REQUEST_2 (31+ bytes)
			log.Printf(" 0x08 Open Connection Request (%d bytes) from %s - treating as handshake", len(data), addr)
			
			// Treat same as 0x0A - call handleOpenConnectionRequest2Proper
			// The function will parse MTU and send 0x0B reply
			rh.handleOpenConnectionRequest2Proper(data, addr)
		} else {
			log.Printf(" Invalid 0x08 packet length: %d from %s", len(data), addr)
		}
	case 0xC0:
		// ACK
		log.Printf(" Received 0xC0 (ACK) from %s, hex: %x", addr, data[:min(16, len(data))])
		rh.handleACK(data, addr)
	case 0xA0:
		// NACK packet - retransmission request
		// DO NOT auto-reset session on abnormal count!
		log.Printf(" Received 0xA0 (NACK) from %s, hex: %x", addr, data[:min(16, len(data))])
		
		if len(data) >= 3 {
			count := binary.LittleEndian.Uint16(data[1:3])
			log.Printf("   NACK count field: %d", count)
			
			// CRITICAL FIX: Don't treat as ACK even if count > 100
			// Abnormal count might indicate packet corruption, but DON'T reset session!
			// Just log warning and try to process as NACK
			if count > 100 {
				log.Printf("    NACK count > 100 (abnormal, possible corruption)")
				log.Printf("   Will attempt to process as NACK anyway (no session reset)")
			}
			
			// Always treat 0xA0 as NACK, never reset session
			rh.handleNACK(data, addr)
		}
	case 0xA2, 0xA8, 0xAA:
		// RakNet ACK variants
		log.Printf(" Received 0x%02X (ACK variant) from %s", data[0], addr)
		if len(data) >= 4 {
			count := binary.BigEndian.Uint16(data[1:3])
			offset := 3
			for i := 0; i < int(count); i++ {
				if offset+6 > len(data) {
					break
				}
				// Read sequence numbers (3 bytes LITTLE-endian each)
				minSeq := uint32(data[offset]) | uint32(data[offset+1])<<8 | uint32(data[offset+2])<<16
				maxSeq := uint32(data[offset+3]) | uint32(data[offset+4])<<8 | uint32(data[offset+5])<<16
				log.Printf(" ACK 0x%02x seq %d-%d from %s", data[0], minSeq, maxSeq, addr)
				offset += 6
			}
		}
		// Also call handleACK for session tracking
		rh.handleACK(data, addr)
	case 0x2A:
		// ACK untuk 0x0B Open Connection Reply 2
		log.Printf(" Client %s acknowledged 0x0B", addr)
		
		// CRITICAL: Upgrade session to READY state after 0x0B is acknowledged
		// This allows the next keepalive to trigger streaming
		rh.mu.RLock()
		session, exists := rh.sessions[addr.String()]
		rh.mu.RUnlock()
		
		if !exists {
			// Check if this is 4-byte 0x2A from new port with active session
			if len(data) == 4 {
				clientIP := addr.IP.String()
				var hasActiveSession bool
				rh.mu.RLock()
				for _, sess := range rh.sessions {
					if sess.Addr.IP.String() == clientIP {
						sess.Mu.RLock()
						gameEntrySent := sess.GameEntrySent
						sess.Mu.RUnlock()
						if gameEntrySent {
							hasActiveSession = true
							break
						}
					}
				}
				rh.mu.RUnlock()
				
				if hasActiveSession {
					log.Printf(" [0x2A] 4-byte from new port  sending 0x1A to %s", addr)
					
					// Create session for new port
					rh.mu.Lock()
					newSession := protocol.NewSession(addr, protocol.DEFAULT_MTU_SIZE)
					newSession.State = protocol.STATE_HANDSHAKE_SENT
					newSession.GameEntrySent = true // Inherit state
					rh.sessions[addr.String()] = newSession
					rh.mu.Unlock()
					
					// Send 0x1A Open Connection Reply 2
					reply := []byte{
						0x1A, // ID_OPEN_CONNECTION_REPLY_2
						0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Server GUID
						byte(addr.Port >> 8), byte(addr.Port), // Client port (big-endian)
						0x05, 0xDC, // MTU (1500)
						0x00, // Encryption enabled (0 = no)
					}
					rh.conn.WriteToUDP(reply, addr)
					log.Printf(" Sent 0x1A Open Connection Reply 2 to new port %s", addr)
					return
				}
			}
			return
		}
		
		if exists {
			session.Mu.Lock()
			if session.State == protocol.STATE_CONNECTING {
				session.State = protocol.STATE_READY
				log.Printf(" Session %s upgraded to READY after 0x2A ACK", addr)
			}
			session.Mu.Unlock()
		}
	case 0x20:
		// Connected Ping - must reply with 0x03 Connected Pong
		rh.handleConnectedPing(data, addr)
	case 0x0A:
		// FIX: 0x0A has multiple meanings based on length and context:
		// 1. Open Connection Request 2 (during handshake, 26+ bytes)
		// 2. ID_DETECT_LOST_CONNECTIONS (in-game ping, 4-6 bytes)
		// 3. RakNet keepalive (4 bytes, no session)
		
		// CRITICAL DEBUG: Log the raw bytes to understand what client is sending
		log.Printf(" [0x0A] Received %d bytes from %s", len(data), addr)
		log.Printf("   Raw hex: %s", hex.EncodeToString(data))
		if len(data) >= 4 {
			log.Printf("   First 4 bytes: %02X %02X %02X %02X", data[0], data[1], data[2], data[3])
		}
		
		rh.mu.RLock()
		session, exists := rh.sessions[addr.String()]
		rh.mu.RUnlock()
		
		if exists {
			log.Printf("   Session state: %d", session.State)
		} else {
			log.Printf("   No session exists")
		}
		
		// FIX: Handle 4-byte 0x0A from new port after game entry sent
		if len(data) == 4 && !exists {
			// Check if this IP has an active session with game entry sent
			clientIP := addr.IP.String()
			var activeSession *protocol.Session
			rh.mu.RLock()
			for _, sess := range rh.sessions {
				if sess.Addr.IP.String() == clientIP {
					sess.Mu.RLock()
					gameEntrySent := sess.GameEntrySent
					sess.Mu.RUnlock()
					if gameEntrySent {
						activeSession = sess
						break
					}
				}
			}
			rh.mu.RUnlock()
			
			if activeSession != nil {
				// Client opening new port after E3:21 - this is expected
				log.Printf(" [0x0A] New port %d from IP %s with active session - creating session and sending 0x06", addr.Port, clientIP)
				
				// Create session for new port
				rh.mu.Lock()
				newSession := protocol.NewSession(addr, protocol.DEFAULT_MTU_SIZE)
				newSession.State = protocol.STATE_UNCONNECTED
				newSession.GameEntrySent = true // Inherit state
				rh.sessions[addr.String()] = newSession
				rh.mu.Unlock()
				
				// Send 0x06 Open Connection Reply 1
				reply := []byte{
					0x06, // ID_OPEN_CONNECTION_REPLY_1
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Server GUID (8 bytes)
					0x00, // Use encryption (0 = no)
					0x05, 0xDC, // MTU size (1500 in big-endian)
				}
				rh.conn.WriteToUDP(reply, addr)
				log.Printf(" Sent 0x06 Open Connection Reply 1 to new port %s", addr)
				return
			}
			
			log.Printf(" Received 0x0A keepalive (4 bytes) from unknown session %s, ignoring", addr)
			return
		}
		
		// Check packet length to determine which type
		if len(data) >= 26 {
			// This is Open Connection Request 2 (handshake)
			if exists && session.State == protocol.STATE_CONNECTED {
				log.Printf(" Ignoring 0x0A handshake - session already CONNECTED")
				return
			}
			rh.handleOpenConnectionRequest2Proper(data, addr)
		} else if len(data) >= 4 && exists && session.State == protocol.STATE_IN_GAME {
			// This is ID_DETECT_LOST_CONNECTIONS (in-game ping)
			log.Printf(" Received ID_DETECT_LOST_CONNECTIONS from %s (state=%d, %d bytes)", addr, session.State, len(data))
			
			// Update last receive time
			session.UpdateLastReceiveTime()
			
			// Send e3 periodic keepalive response (SA-MP specific)
			session.Mu.Lock()
			if session.ChannelOrderIndex == nil {
				session.ChannelOrderIndex = make(map[uint8]uint32)
			}
			keepaliveCounter := session.ChannelOrderIndex[255]
			session.ChannelOrderIndex[255]++
			session.Mu.Unlock()
			
			e3Keepalive := []byte{
				0xe3,
				byte(keepaliveCounter),
				0x00,
			}
			rh.conn.WriteToUDP(e3Keepalive, addr)
			log.Printf(" Sent e3:%02x keepalive response to %s", keepaliveCounter, addr)
		} else {
			log.Printf(" Received 0x0A with unexpected length %d from %s (state=%d)", len(data), addr, session.State)
		}
	case 0x22:
		// FIX #5: Add guards to prevent duplicate E3:01 and E5 packets
		rh.mu.RLock()
		session, exists := rh.sessions[addr.String()]
		rh.mu.RUnlock()
		
		if !exists {
			log.Printf(" Received 0x22 from unknown session: %s", addr)
			return
		}
		
		session.Mu.Lock()
		if session.SentE3Phase1 {
			log.Printf(" 0x22 already processed for %s, skipping duplicate", addr)
			session.Mu.Unlock()
			return
		}
		session.SentE3Phase1 = true
		session.SentNWBitStream = true
		session.Mu.Unlock()
		
		log.Printf(" Received 0x22 from %s - sending E3:01 + E5 sequence", addr)
		
		// Send E3:01 (once only)
		rh.conn.WriteToUDP([]byte{0xe3, 0x01, 0x00}, addr)
		log.Printf(" Sent E3:01")
		
		// Send ConnectedPing (0x00)
		rh.conn.WriteToUDP([]byte{0x00, 0x80, 0x42, 0x68, 0x22, 0x7f, 0x00, 0x00, 0x01, 0x85, 0xf0, 0x00, 0x00, 0x16, 0x64, 0x00, 0x00}, addr)
		log.Printf(" Sent 0x00 ConnectedPing")
		
		// FIX #4: Send correct 0xE5 NWBitStream (8 bytes, not 0xE7 with 10 bytes)
		rh.conn.WriteToUDP(protocol.PacketE5, addr)
		log.Printf(" Sent 0xE5 NWBitStream (8 bytes)")
		
		// Send timing packet
		rh.conn.WriteToUDP([]byte{
			0x01, 0x00, 0x32, 0x28, 0x06, 0x56, 0x35, 0x83, 0x00, 0x03, 0x00, 0x87, 0x00, 0x29, 0x04, 0x00,
			0x64, 0x90, 0x09, 0x51, 0x35, 0x83, 0x00, 0x56, 0x35, 0x83, 0x00, 0x05, 0x00, 0x64, 0x90, 0x09,
			0x52, 0x35, 0x83, 0x00, 0x56, 0x35, 0x83, 0x00, 0x06, 0x00, 0x87, 0x00, 0x17,
		}, addr)
		log.Printf(" Sent 0x01 timing packet")
		return
	default:
		// Log unknown packets (but not query or cookie)
		if packetID != 0x53 && packetID != 0x08 {
			log.Printf("Unknown RakNet packet: 0x%02X (%d bytes) from %s - Hex: %s", 
				packetID, len(data), addr.String(), hex.EncodeToString(data[:min(32, len(data))]))
		}
	}
}

func (rh *RakNetHandler) handleUnconnectedPing(data []byte, addr *net.UDPAddr) {
	// FIX: SA-MP sends very short format - minimum 9 bytes
	// Format: 0x02 + timestamp 8 bytes (no magic, no GUID)
	if len(data) < 9 {
		log.Printf("Ping too short: %d bytes", len(data))
		return
	}
	
	// CRITICAL: Don't reset active sessions
	sessionKey := addr.String()
	rh.mu.RLock()
	session, exists := rh.sessions[sessionKey]
	rh.mu.RUnlock()
	
	if exists {
		session.Mu.RLock()
		state := session.State
		gameEntrySent := session.GameEntrySent
		session.Mu.RUnlock()
		
		// CRITICAL: Jangan ganggu session yang sudah connecting/connected ATAU sudah kirim streaming
		if state >= protocol.STATE_CONNECTING || gameEntrySent {
			log.Printf(" Ignoring unconnected ping from active session %s (state=%d, gameEntrySent=%v)", 
				sessionKey, state, gameEntrySent)
			// Tetap balas ping tapi jangan reset session
			goto sendPong
		}
	}
	
	log.Printf("Received unconnected ping: %d bytes from %s", len(data), addr.String())
	
sendPong:
	// Parse: timestamp at offset 1-8
	pingTime := binary.BigEndian.Uint64(data[1:9])
	
	// Check if there's magic bytes (for longer format)
	if len(data) >= 25 {
		magic := data[9:25]
		if !bytesEqual(magic, protocol.OfflineMessageDataID) {
			log.Printf("Invalid magic bytes in ping")
			return
		}
	}
	
	log.Printf("Valid unconnected ping - PingTime: %d", pingTime)
	
	// Send 0x1C unconnected pong
	response := protocol.NewEmptyBitStream()
	response.WriteByte(protocol.ID_UNCONNECTED_PONG)
	response.WriteUint64(uint64(time.Now().UnixMilli()))
	response.WriteUint64(serverGUID)
	response.WriteBytes(protocol.OfflineMessageDataID)
	
	// SA-MP server info string format (with length prefix)
	// Format: hostname;players;maxplayers;gamemode;language
	serverInfo := "SA-MP Server Go;0;50;Freeroam;Indonesian"
	response.WriteUint16(uint16(len(serverInfo)))
	response.WriteBytes([]byte(serverInfo))
	
	responseData := response.GetData()
	n, err := rh.conn.WriteToUDP(responseData, addr)
	if err != nil {
		log.Printf("Failed to send pong: %v", err)
		return
	}
	
	log.Printf("Sent pong: %d bytes (wrote %d), ServerInfo: %s", len(responseData), n, serverInfo)
	log.Printf("Pong packet hex: %s", hex.EncodeToString(responseData[:min(64, len(responseData))]))
}

func (rh *RakNetHandler) handleSAMPQuery(data []byte, addr *net.UDPAddr) {
	log.Printf("Received SA-MP query: %d bytes from %s", len(data), addr.String())
	log.Printf("Query packet hex: %s", hex.EncodeToString(data))
	
	// SA-MP query format: "SAMP" + IP (4 bytes) + Port (2 bytes) + Opcode (1 byte)
	if len(data) < 11 {
		log.Printf("Invalid SA-MP query packet (too short)")
		return
	}
	
	// Verify header
	if string(data[0:4]) != "SAMP" {
		log.Printf("Invalid SA-MP query header")
		return
	}
	
	opcode := data[10]
	log.Printf("SA-MP query opcode: '%c' (0x%02X)", opcode, opcode)
	
	switch opcode {
	case protocol.SAMP_QUERY_INFO:
		rh.handleSAMPQueryInfo(data, addr)
	case protocol.SAMP_QUERY_RULES:
		rh.handleSAMPQueryRules(data, addr)
	case protocol.SAMP_QUERY_PLAYERS:
		rh.handleSAMPQueryPlayers(data, addr)
	case protocol.SAMP_QUERY_PING:
		rh.handleSAMPQueryPing(data, addr)
	default:
		log.Printf("Unknown SA-MP query opcode: '%c' (0x%02X)", opcode, opcode)
	}
}

func (rh *RakNetHandler) handleSAMPQueryInfo(data []byte, addr *net.UDPAddr) {
	log.Printf("Handling SA-MP info query")
	
	// Response format: "SAMP" + IP + Port + 'i' + password(1) + players(2) + maxplayers(2) + hostname_len(4) + hostname + gamemode_len(4) + gamemode + language_len(4) + language
	response := make([]byte, 0, 256)
	
	// Header
	response = append(response, []byte("SAMP")...)
	response = append(response, data[4:10]...) // Echo back IP and port
	response = append(response, 'i')
	
	// Password (0 = no password)
	response = append(response, 0)
	
	// Players (2 bytes, little endian) - current player count
	playerCount := uint16(0) // TODO: Get actual player count from server
	response = append(response, byte(playerCount), byte(playerCount>>8))
	
	// Max players (2 bytes, little endian) - from server config
	maxPlayers := uint16(rh.server.MaxPlayers)
	response = append(response, byte(maxPlayers), byte(maxPlayers>>8))
	
	// Hostname - from server config
	hostname := rh.server.ServerName
	response = append(response, byte(len(hostname)), 0, 0, 0) // 4 bytes length, little endian
	response = append(response, []byte(hostname)...)
	
	// Gamemode - from server config
	gamemode := rh.server.GameMode
	response = append(response, byte(len(gamemode)), 0, 0, 0)
	response = append(response, []byte(gamemode)...)
	
	// Language - from server config
	language := rh.server.Language
	response = append(response, byte(len(language)), 0, 0, 0)
	response = append(response, []byte(language)...)
	
	n, err := rh.conn.WriteToUDP(response, addr)
	if err != nil {
		log.Printf("Failed to send SA-MP info response: %v", err)
		return
	}
	
	log.Printf("Sent SA-MP info response: %d bytes", n)
	log.Printf("Response hex: %s", hex.EncodeToString(response))
	log.Printf(" INFO QUERY  hostname='%s', gamemode='%s', language='%s', maxplayers=%d", 
		hostname, gamemode, language, maxPlayers)
}

func (rh *RakNetHandler) handleSAMPQueryRules(data []byte, addr *net.UDPAddr) {
	log.Printf("Handling SA-MP rules query")
	
	// Get config from server
	weather := fmt.Sprintf("%d", rh.server.Weather)
	worldtime := fmt.Sprintf("%d:00", rh.server.WorldTime)
	
	// Rules map - CRITICAL: version must be "0.3.7-R2" for 0.3.7-R5 client compatibility
	rules := map[string]string{
		"lagcomp":   "On",
		"mapname":   rh.server.MapName,
		"version":   "0.3.7-R2",
		"weather":   weather,
		"weburl":    rh.server.WebURL,
		"worldtime": worldtime,
	}
	
	// Response format: "SAMP" + IP + Port + 'r' + rules_count(2) + (rule_name_len(1) + rule_name + rule_value_len(1) + rule_value)*
	response := make([]byte, 0, 256)
	
	// Header: Copy 11 bytes from request (SAMP + IP + Port + opcode)
	response = append(response, data[0:11]...)
	
	// Rules count (uint16 little endian)
	count := uint16(len(rules))
	response = append(response, byte(count), byte(count>>8))
	
	// Add each rule with length-prefixed key and value
	for key, value := range rules {
		// Key length + key
		response = append(response, byte(len(key)))
		response = append(response, []byte(key)...)
		
		// Value length + value
		response = append(response, byte(len(value)))
		response = append(response, []byte(value)...)
	}
	
	n, err := rh.conn.WriteToUDP(response, addr)
	if err != nil {
		log.Printf("Failed to send SA-MP rules response: %v", err)
		return
	}
	
	log.Printf("Sent SA-MP rules response: %d bytes", n)
	log.Printf(" RULES QUERY  version=%s, mapname=%s, lagcomp=%s, weather=%s, weburl=%s, worldtime=%s",
		rules["version"], rules["mapname"], rules["lagcomp"], rules["weather"], rules["weburl"], rules["worldtime"])
	log.Printf("    CRITICAL  Rules weather=%s MUST match InitGame weather=%d", rules["weather"], rh.server.Weather)
}

func (rh *RakNetHandler) handleSAMPQueryPlayers(data []byte, addr *net.UDPAddr) {
	log.Printf("Handling SA-MP players query")
	
	// Response format: "SAMP" + IP + Port + 'c' + players_count(2) + (player_name_len(1) + player_name + score(4))*
	response := make([]byte, 0, 256)
	
	// Header
	response = append(response, []byte("SAMP")...)
	response = append(response, data[4:10]...)
	response = append(response, 'c')
	
	// Players count (2 bytes, little endian)
	response = append(response, 0, 0) // 0 players
	
	n, err := rh.conn.WriteToUDP(response, addr)
	if err != nil {
		log.Printf("Failed to send SA-MP players response: %v", err)
		return
	}
	
	log.Printf("Sent SA-MP players response: %d bytes", n)
}

func (rh *RakNetHandler) handleSAMPQueryPing(data []byte, addr *net.UDPAddr) {
	log.Printf("Handling SA-MP ping query")
	
	// Response format: "SAMP" + IP + Port + 'p' + (echo back the rest)
	response := make([]byte, 0, len(data))
	response = append(response, data...)
	
	n, err := rh.conn.WriteToUDP(response, addr)
	if err != nil {
		log.Printf("Failed to send SA-MP ping response: %v", err)
		return
	}
	
	log.Printf("Sent SA-MP ping response: %d bytes", n)
}

func (rh *RakNetHandler) handleSAMPConnectionRequest(data []byte, addr *net.UDPAddr) {
	// Guard: 0x80 with 6 bytes is keepalive, not connection request
	if len(data) == 6 {
		log.Printf(" Received 0x80 keepalive (6 bytes) from %s, ignoring", addr)
		return
	}
	
	// Only process 0x80 with 4 bytes
	if len(data) != 4 {
		log.Printf(" Unexpected 0x80 packet length: %d bytes from %s", len(data), addr)
		return
	}
	
	log.Printf("=== Received SA-MP Connection Response (0x80 4 bytes) ===")
	log.Printf("Packet hex: %s", hex.EncodeToString(data))

	ipKey := cookieKey(addr)

	// SECURITY FIX: Validate cookie handshake before accepting 0x80 (use IP only)
	rh.mu.RLock()
	_, hasCookie := rh.cookieTable[ipKey]
	rh.mu.RUnlock()
	
	if !hasCookie {
		log.Printf(" Rejected 0x80 from %s: no cookie for IP %s", addr, ipKey)
		return
	}

	// Fix race condition: Lock before checking and creating session
	sessionKey := addr.String()
	rh.mu.Lock()
	session, exists := rh.sessions[sessionKey]
	if !exists {
		session = protocol.NewSession(addr, protocol.DEFAULT_MTU_SIZE)
		rh.sessions[sessionKey] = session
		log.Printf(" Created session: %s", sessionKey)
		
		// Send 0x19 0x00 only once when session is created
		response := []byte{0x19, 0x00}
		rh.conn.WriteToUDP(response, addr)
		log.Printf(" Sent 0x19 to %s", addr)
	}
	rh.mu.Unlock()
}


func (rh *RakNetHandler) handleSAMPConnectionCookie(data []byte, addr *net.UDPAddr) {
	log.Printf("Received SA-MP connection cookie: %d bytes from %s", len(data), addr.String())
	log.Printf("Cookie packet hex: %s", hex.EncodeToString(data))
	
	// Accept both 4-byte and 10-byte cookie packets
	if len(data) != 4 && len(data) != 10 {
		log.Printf(" Invalid cookie packet length: %d (expected 4 or 10)", len(data))
		return
	}
	
	sessionKey := addr.String()
	
	// FIX RACE CONDITION: Lock for session check/create, then unlock before I/O
	rh.mu.Lock()
	
	// Check if this is from a known IP (different port)
	var existingSession *protocol.Session
	clientIP := addr.IP.String()
	for key, sess := range rh.sessions {
		if sess.Addr.IP.String() == clientIP && key != sessionKey {
			existingSession = sess
			log.Printf(" Cookie from new port %d (old port: %d) for IP %s", addr.Port, sess.Addr.Port, clientIP)
			break
		}
	}
	
	// FIX #12: Check if session exists and guard against duplicates
	session, exists := rh.sessions[sessionKey]
	
	if exists {
		// Session already exists - check state
		if session.State >= protocol.STATE_CONNECTING {
			// Already past handshake phase - ignore duplicate 0x08
			rh.mu.Unlock()
			log.Printf(" [FIX #12] Duplicate 0x08 from %s (state=%d), ignoring to prevent reset", addr, session.State)
			return
		}
		
		// Still in early phase - can resend 0x1A
		log.Printf(" 0x08 from %s in state=%d, will resend 0x1A", addr, session.State)
	} else if existingSession != nil && existingSession.GameEntrySent {
		// New port from IP that already has game entry sent
		// Create new session for this port and link to existing session data
		session = protocol.NewSession(addr, protocol.DEFAULT_MTU_SIZE)
		session.State = protocol.STATE_UNCONNECTED
		session.GameEntrySent = true // Inherit game entry state
		rh.sessions[sessionKey] = session
		log.Printf(" Created linked session for new port %s (game entry already sent)", sessionKey)
	} else {
		// Create new session
		session = protocol.NewSession(addr, protocol.DEFAULT_MTU_SIZE)
		session.State = protocol.STATE_UNCONNECTED
		rh.sessions[sessionKey] = session
		log.Printf(" Created new SA-MP session for %s", sessionKey)
	}
	
	// Extract and store cookie
	cookie := data[1:4]
	session.Cookie = cookie
	
	cookieValue := binary.BigEndian.Uint32(append([]byte{0}, cookie...))
	rh.cookieTable[cookieKey(addr)] = cookieValue
	log.Printf(" Stored cookie for %s: 0x%08X", sessionKey, cookieValue)
	
	// Update session state
	session.State = protocol.STATE_HANDSHAKE_SENT
	session.LastReceiveTime = time.Now()
	
	// Unlock before I/O operation (sending packet)
	rh.mu.Unlock()
	
	// FIX #7: Encode 0x1A with CLIENT PORT using XOR formula
	// Formula discovered from Wireshark analysis:
	//   clientPort 52935 = 0xCEC7
	//   0xCE XOR 0x82 = 0x4C (official byte[1])
	//   0xC7 XOR 0x93 = 0x54 (official byte[2])
	// 
	// The encoding uses CLIENT port (from addr), not server port!
	clientPort := uint16(addr.Port)
	hi := byte(clientPort >> 8)   // High byte
	lo := byte(clientPort & 0xFF)  // Low byte
	
	// Apply XOR encoding with SA-MP keys
	encoded0 := hi ^ 0x82
	encoded1 := lo ^ 0x93
	
	cookieResponse := []byte{0x1A, encoded0, encoded1}
	
	n, err := rh.conn.WriteToUDP(cookieResponse, addr)
	if err != nil {
		log.Printf("Failed to send cookie response: %v", err)
		return
	}
	
	log.Printf(" Sent 0x1A cookie response: %d bytes", n)
	log.Printf("   Response hex: %s", hex.EncodeToString(cookieResponse))
	log.Printf("   Client port: %d (0x%04X)  hi=0x%02X lo=0x%02X", clientPort, clientPort, hi, lo)
	log.Printf("   Encoded: [0x%02X, 0x%02X] (hi^0x82, lo^0x93)", encoded0, encoded1)
	log.Printf("   Cookie stored: %02X (will expect in 0x00 response)", cookie)
	
	log.Printf("Session %s: Sent 0x1A, waiting for 0x00 OpenConnectionRequest2", sessionKey)
}

func (rh *RakNetHandler) handleOpenConnectionRequest1(data []byte, addr *net.UDPAddr) {
	log.Printf("Received Open Connection Request 1 (0x05): %d bytes from %s", len(data), addr.String())
	
	if len(data) < 18 {
		log.Printf(" Packet too short for OpenConnectionRequest1")
		return
	}
	
	bs := protocol.NewBitStream(data)
	bs.ReadByte() // Packet ID (0x05)
	
	magic, err := bs.ReadBytes(16)
	if err != nil || !bytesEqual(magic, protocol.OfflineMessageDataID) {
		log.Printf(" Invalid magic in Open Connection Request 1")
		return
	}
	
	protocolVersion, err := bs.ReadByte()
	if err != nil {
		log.Printf(" Failed to read protocol version")
		return
	}
	
	log.Printf("Protocol version: %d", protocolVersion)
	
	// Check protocol version
	if protocolVersion != protocol.RAKNET_PROTOCOL_VERSION {
		// Send incompatible protocol
		response := protocol.NewEmptyBitStream()
		response.WriteByte(protocol.ID_INCOMPATIBLE_PROTOCOL_VERSION)
		response.WriteByte(protocol.RAKNET_PROTOCOL_VERSION)
		response.WriteBytes(protocol.OfflineMessageDataID)
		response.WriteUint64(rh.serverGUID)
		rh.conn.WriteToUDP(response.GetData(), addr)
		log.Printf("Sent incompatible protocol version (expected %d, got %d)", protocol.RAKNET_PROTOCOL_VERSION, protocolVersion)
		return
	}
	
	// FIX #1: Calculate MTU correctly from packet length
	// Client sends packet padded to their supported MTU
	mtuSize := uint16(len(data)) + 28 // 28 = IP(20) + UDP(8)
	
	// Clamp to valid range
	if mtuSize > protocol.MAX_MTU_SIZE {
		mtuSize = protocol.MAX_MTU_SIZE
	}
	if mtuSize < 576 {
		mtuSize = 576
	}
	
	log.Printf("Calculated MTU: %d (from packet length %d)", mtuSize, len(data))
	
	// FIX #1: Build proper RakNet OpenConnectionReply1 (0x06)
	// Format: [ID][Magic][ServerGUID][HasSecurity][MTU]
	response := protocol.NewEmptyBitStream()
	response.WriteByte(protocol.ID_OPEN_CONNECTION_REPLY_1) // 0x06
	response.WriteBytes(protocol.OfflineMessageDataID)      // 16 bytes magic
	response.WriteUint64(rh.serverGUID)                     // 8 bytes server GUID
	response.WriteByte(0)                                   // 1 byte: HasSecurity = false
	response.WriteUint16(mtuSize)                           // 2 bytes: MTU (big-endian)
	
	n, err := rh.conn.WriteToUDP(response.GetData(), addr)
	if err != nil {
		log.Printf(" Failed to send Open Connection Reply 1: %v", err)
		return
	}
	
	log.Printf(" Sent 0x06 OpenConnectionReply1: %d bytes, MTU=%d to %s", n, mtuSize, addr.String())
}

func (rh *RakNetHandler) handleOpenConnectionRequest2(data []byte, addr *net.UDPAddr) {
	log.Printf("Received Open Connection Request 2: %d bytes from %s", len(data), addr.String())
	log.Printf("Packet hex: %s", hex.EncodeToString(data))
	
	bs := protocol.NewBitStream(data)
	bs.ReadByte() // Packet ID (0x07)
	
	magic, err := bs.ReadBytes(16)
	if err != nil || !bytesEqual(magic, protocol.OfflineMessageDataID) {
		log.Printf("Invalid magic in Open Connection Request 2")
		return
	}
	
	// Read server address (what client thinks server address is)
	serverAddr, err := bs.ReadAddress()
	if err != nil {
		log.Printf("Failed to read server address: %v", err)
		return
	}
	
	mtuSize, err := bs.ReadUint16()
	if err != nil {
		log.Printf("Failed to read MTU size: %v", err)
		return
	}
	
	// Validate MTU size - must be between 400 and 1500
	if mtuSize < 400 || mtuSize > 1500 {
		log.Printf(" Invalid MTU size %d, using default %d", mtuSize, protocol.DEFAULT_MTU_SIZE)
		mtuSize = protocol.DEFAULT_MTU_SIZE
	}
	
	clientGUID, err := bs.ReadUint64()
	if err != nil {
		log.Printf("Failed to read client GUID: %v", err)
		return
	}
	
	log.Printf("Server Address: %s, MTU: %d, Client GUID: %d", serverAddr.String(), mtuSize, clientGUID)
	
	// Create session
	rh.mu.Lock()
	session, exists := rh.sessions[addr.String()]
	if !exists {
		session = protocol.NewSession(addr, mtuSize)
		session.State = protocol.STATE_CONNECTING
		rh.sessions[addr.String()] = session
		log.Printf("Created new session for %s", addr.String())
	} else {
		session.MTU = mtuSize
		session.State = protocol.STATE_CONNECTING
		log.Printf("Updated existing session for %s", addr.String())
	}
	rh.mu.Unlock()
	
	// Send reply
	response := protocol.NewEmptyBitStream()
	response.WriteByte(protocol.ID_OPEN_CONNECTION_REPLY_2)
	response.WriteBytes(protocol.OfflineMessageDataID)
	response.WriteUint64(rh.serverGUID)
	response.WriteAddress(addr) // Client address
	response.WriteUint16(mtuSize)
	response.WriteByte(0) // ServerHasSecurity = false
	
	n, err := rh.conn.WriteToUDP(response.GetData(), addr)
	if err != nil {
		log.Printf("Failed to send Open Connection Reply 2: %v", err)
		return
	}
	
	log.Printf("Sent Open Connection Reply 2: %d bytes to %s", n, addr.String())
}

func (rh *RakNetHandler) handleDataPacket(data []byte, addr *net.UDPAddr) {
	// CRITICAL FIX: SA-MP uses IP+Port as session key
	sessionKey := addr.String()
	
	rh.mu.RLock()
	session, exists := rh.sessions[sessionKey]
	rh.mu.RUnlock()
	
	if !exists {
		log.Printf(" Data packet from unknown session: %s", addr.String())
		log.Printf("Available sessions:")
		rh.mu.RLock()
		for sessAddr := range rh.sessions {
			log.Printf("  - %s", sessAddr)
		}
		rh.mu.RUnlock()
		return
	}
	
	log.Printf(" Processing data packet 0x%02X from %s (session exists)", data[0], addr.String())
	log.Printf("Packet hex: %s", hex.EncodeToString(data))
	
	// CRITICAL FIX: Detect SA-MP auth packet (0x88)
	// Multiple types based on length and session state:
	// 1. 6 bytes + !HandshakeSent = First auth signal after 0x19  trigger full handshake
	// 2. 6 bytes + HandshakeSent + !StreamingDone = Keepalive during streaming  ACK only
	// 3. 84 bytes + GameEntrySent = JOIN REQUEST! Decode payload and process as 0x28
	// 4. 13 bytes + StreamingDone = Streaming complete signal  trigger post-streaming (NOT USED - we trigger automatically)
	if data[0] == 0x88 {
		// Read sequence number (3 bytes LITTLE-endian)
		seqNum := protocol.ReadUint24LE(data[1:4])
		
		if len(data) == 84 {
			session.Mu.Lock()
			session.ACKQueue[seqNum] = struct{}{} // Dedup set
			session.LastReceiveTime = time.Now()
			gameEntrySent := session.GameEntrySent
			session.Mu.Unlock()
			
			// Send ACK immediately
			session.Update(rh.conn)
			
			// CRITICAL FIX: 0x88 84 bytes after streaming IS the join request!
			if gameEntrySent {
				log.Printf(" Received JOIN REQUEST (0x88, 84 bytes) - decoding payload...")
				
				// Decode RakNet datagram to extract encapsulated payload
				dp, err := protocol.DecodeDataPacket(data)
				if err != nil {
					log.Printf(" Failed to decode 0x88 datagram: %v", err)
					return
				}
				
				if len(dp.Packets) > 0 {
					// Extract first encapsulated packet payload
					payload := dp.Packets[0].Payload
					log.Printf(" Decoded join request payload: %d bytes", len(payload))
					log.Printf("   Payload hex (first 32 bytes): %02X", payload[:min(32, len(payload))])
					
					// Check if this is 0x8A (SA-MP auth key)
					if len(payload) > 0 && payload[0] == 0x8A {
						log.Printf(" Detected 0x8A auth key in join request - processing...")
						
						// Process as internal packet
						packet := &protocol.RakNetPacket{
							PacketID: payload[0],
							Payload:  payload[1:],
						}
						rh.handleInternalPacket(session, packet)
						
						// CRITICAL: After processing 0x8A, send join response sequence
						log.Printf(" Join request processed - sending join response sequence")
						rh.sendJoinResponseSequence(addr)
					} else {
						log.Printf(" Unknown payload type in 0x88: 0x%02X", payload[0])
					}
				} else {
					log.Printf(" 0x88 84 bytes has no encapsulated packets")
				}
			} else {
				log.Printf(" 0x88 84 bytes ACKed - waiting for streaming to complete")
			}
			return
		}
		
		if len(data) == 6 && !session.GetHandshakeSent() {
			// FIX #3: First 0x88 after 0x19 - send E3:00 immediately WITHOUT ACK
			log.Printf(" Detected first 0x88 auth (6 bytes) - sending E3:00 challenge")
			
			session.Mu.Lock()
			if session.AuthHandled {
				log.Printf(" 0x88 RETRY detected! E3:00 was already sent but client is retrying")
				log.Printf("   This means client rejected E3:00 - likely wrong length (26 instead of 25)")
				session.Mu.Unlock()
				return
			}
			session.AuthHandled = true
			session.SetHandshakeSent(true)
			
			// Queue ACK but DON'T send it yet - let it be sent later with other packets
			session.ACKQueue[seqNum] = struct{}{} // Dedup set
			session.LastReceiveTime = time.Now()
			session.Mu.Unlock()
			
			// FIX #3: Send E3:00 IMMEDIATELY without ACK (matches official behavior)
			// Official server: 0x88  E3:00 (no ACK in between)
			rh.sendFullHandshakeSequence(addr)
			return
		}
		
		if len(data) == 6 && session.GetHandshakeSent() && !session.GetStreamingDone() {
			// State 2: Keepalive during streaming - just ACK
			log.Printf(" 0x88 keepalive (6 bytes) during streaming from %s", addr)
			
			session.Mu.Lock()
			session.ACKQueue[seqNum] = struct{}{} // Dedup set
			session.LastReceiveTime = time.Now()
			session.Mu.Unlock()
			return
		}
		
		// NOTE: 0x88 13 bytes handler removed - we trigger post-streaming automatically
		// after streaming completes, not waiting for client signal
		
		// Fallback: just ACK any other 0x88
		log.Printf(" 0x88 (%d bytes) - ACK only", len(data))
		
		session.Mu.Lock()
		session.ACKQueue[seqNum] = struct{}{} // Dedup set
		session.LastReceiveTime = time.Now()
		session.Mu.Unlock()
		return
	}
	
	// CRITICAL FIX: Detect SA-MP join request (0x22 with 48 bytes)
	// From Wireshark: Client sends 0x22, server responds with 3 exact packets
	if data[0] == 0x22 && len(data) == 48 {
		log.Printf(" Received 0x22 auth data from %s", addr)
		
		session.LastReceiveTime = time.Now()
		
		// 1. Short e3
		rh.conn.WriteToUDP([]byte{0xe3, 0x01, 0x00}, addr)
		log.Printf(" Sent short e3 (3 bytes)")
		
		// 2. 0x00 internal address packet dengan client IP:port
		clientIP := addr.IP.To4()
		if clientIP == nil {
			clientIP = []byte{127, 0, 0, 1}
		}
		port := uint16(addr.Port)
		pkt00 := []byte{
			0x00, 0x80, 0x42, 0x68, 0x22,
			clientIP[0], clientIP[1], clientIP[2], clientIP[3],
			byte(port), byte(port >> 8), // little-endian
			0x00, 0x00, 0x27, 0x4c, 0x00, 0x00,
		}
		rh.conn.WriteToUDP(pkt00, addr)
		log.Printf(" Sent 0x00 internal address packet (17 bytes)")
		
		// 3. MTU e5
		rh.conn.WriteToUDP([]byte{0xe5, 0x02, 0x00, 0x02, 0x00, 0x02, 0x80, 0x00}, addr)
		log.Printf(" Sent MTU e5 (8 bytes)")
		
		// FIX 1: Upgrade ke CONNECTED setelah 0x22 (bukan di keepalive)
		if session.State == protocol.STATE_CONNECTING {
			session.State = protocol.STATE_CONNECTED
			session.PlayerID = 0
			log.Printf(" Session upgraded to CONNECTED after 0x22")
		}
		
		session.State = protocol.STATE_READY
		
		return
	}
	
	// Check if 0x02 - ignore unconnected ping from connected session
	if data[0] == 0x02 {
		return
	}
	
	// Check if 0x80 with 6 bytes - keepalive, ACK only
	if data[0] == 0x80 && len(data) == 6 {
		// Read sequence number (3 bytes LITTLE-endian)
		seq := protocol.ReadUint24LE(data[1:4])
		session.Mu.Lock()
		session.ACKQueue[seq] = struct{}{} // Dedup set
		session.Mu.Unlock()
		log.Printf(" 0x80 keepalive (6 bytes), added seq=%d to ACK queue", seq)
		return
	}
	
	// Check if 0x8A with > 6 bytes is join/auth request (not keepalive!)
	if data[0] == 0x8A && len(data) > 6 {
		log.Printf(" Detected 0x8A join/auth request (%d bytes) from %s", len(data), addr)
		
		// CRITICAL FIX: Find the REAL session used for handshake by IP
		// The session at addr.String() might be a NEW session created for port change
		// We need to find the session that has non-zero counters (the handshake session)
		clientIP := addr.IP.String()
		var realSession *protocol.Session
		var realSessionKey string
		
		rh.mu.RLock()
		for key, sess := range rh.sessions {
			if sess.Addr.IP.String() == clientIP {
				sess.Mu.RLock()
				seq := sess.SequenceNumber
				msg := sess.MessageIndex
				sess.Mu.RUnlock()
				
				// Find session with non-zero counters (the one used for handshake)
				if seq > 0 || msg > 0 {
					realSession = sess
					realSessionKey = key
					log.Printf(" Found handshake session: %s (seq=%d msg=%d)", key, seq, msg)
					break
				}
			}
		}
		rh.mu.RUnlock()
		
		// If no session with counters found, use current session
		if realSession == nil {
			realSession = session
			realSessionKey = addr.String()
			log.Printf(" No handshake session found, using current session: %s", realSessionKey)
		}
		
		// If port changed, rebind the real session to new port
		if realSessionKey != addr.String() {
			log.Printf(" Port changed from %s to %s - rebinding session", realSessionKey, addr.String())
			
			realSession.Mu.Lock()
			realSession.Addr = addr
			realSession.Mu.Unlock()
			
			// Update session map
			rh.mu.Lock()
			rh.sessions[addr.String()] = realSession
			// Don't delete old key yet - might still receive packets
			rh.mu.Unlock()
			
			// Update local session variable to use real session
			session = realSession
		}
		
		// Log session pointer and counters
		log.Printf(" Session pointer: %p", session)
		
		// CRITICAL: Log session counters IMMEDIATELY when 0x8A is received
		session.Mu.RLock()
		currentSeq := session.SequenceNumber
		currentMsg := session.MessageIndex
		currentOrder := session.ChannelOrderIndex[0]
		currentState := session.State
		gameEntrySent := session.GameEntrySent
		session.Mu.RUnlock()
		
		log.Printf(" [0x8A RECEIVED] Session counters  seq=%d msg=%d order[ch0]=%d state=%d gameEntrySent=%v", 
			currentSeq, currentMsg, currentOrder, currentState, gameEntrySent)
		
		if currentSeq == 0 && currentMsg == 0 && currentOrder == 0 {
			log.Printf(" CRITICAL BUG: Session counters are at 0! This session was just created or reset!")
			log.Printf(" This means handshake packets were sent to a DIFFERENT session!")
			log.Printf(" Session key: %s", addr.String())
		}
		
		// CRITICAL: Check if already in game - don't reprocess
		if currentState >= protocol.STATE_IN_GAME || gameEntrySent {
			log.Printf(" [0x8A] Already in game (state=%d, gameEntrySent=%v) - ignoring", currentState, gameEntrySent)
			// Still ACK it
			seq := protocol.ReadUint24LE(data[1:4])
			session.Mu.Lock()
			session.ACKQueue[seq] = struct{}{}
			session.LastReceiveTime = time.Now()
			session.Mu.Unlock()
			session.Update(rh.conn)
			return
		}
		
		// Update last receive time
		session.Mu.Lock()
		session.LastReceiveTime = time.Now()
		session.Mu.Unlock()
		
		// ACK dulu
		seq := protocol.ReadUint24LE(data[1:4])
		session.Mu.Lock()
		session.ACKQueue[seq] = struct{}{}
		session.Mu.Unlock()
		session.Update(rh.conn)
		
		// Gunakan satu Lock  eliminasi race condition sepenuhnya
		session.Mu.Lock()
		if session.GameEntrySent {
			session.Mu.Unlock()
			log.Printf(" [0x8A] Game entry already sent, ignoring from %s", addr)
			return
		}
		session.GameEntrySent = true
		session.State = protocol.STATE_IN_GAME
		session.Mu.Unlock()
		
		log.Printf(" [0x8A] Sending FULL game entry sequence immediately!")
		
		// CRITICAL: Log counters again BEFORE spawn to confirm they haven't changed
		session.Mu.RLock()
		seqBeforeSpawn := session.SequenceNumber
		msgBeforeSpawn := session.MessageIndex
		orderBeforeSpawn := session.ChannelOrderIndex[0]
		session.Mu.RUnlock()
		
		log.Printf(" RakNet counters before spawn  seq=%d msg=%d order[ch0]=%d", 
			seqBeforeSpawn, msgBeforeSpawn, orderBeforeSpawn)
		log.Printf(" Session pointer before spawn: %p", session)
		
		if seqBeforeSpawn == 0 && msgBeforeSpawn == 0 && orderBeforeSpawn == 0 {
			log.Printf(" FATAL: Counters still at 0 before spawn! Session was never used for handshake!")
			log.Printf(" Checking all sessions to find the real handshake session...")
			
			rh.mu.RLock()
			for key, sess := range rh.sessions {
				sess.Mu.RLock()
				log.Printf("   Session %s: seq=%d msg=%d order[ch0]=%d state=%d pointer=%p", 
					key, sess.SequenceNumber, sess.MessageIndex, sess.ChannelOrderIndex[0], sess.State, sess)
				sess.Mu.RUnlock()
			}
			rh.mu.RUnlock()
		}
		
		// Kirim Phase 1 (streaming) + Phase 2 (E3:09  E3:21)
		rh.sendFullGameEntrySequence(addr)
		return
	}
	
	// ============================================================
	// BYPASS DECODER - Direct SA-MP packet detection
	// ============================================================
	
	// ACK the packet first
	if len(data) >= 4 {
		seq := uint32(data[1]) | uint32(data[2])<<8 | uint32(data[3])<<16
		session.Mu.Lock()
		session.ACKQueue[seq] = struct{}{}
		session.LastReceiveTime = time.Now()
		session.Mu.Unlock()
		log.Printf(" ACKed data packet seq=%d", seq)
	}
	
	// Scan entire payload for known SA-MP packet IDs
	// Inner packet can be at offset 4 to 14
	for offset := 4; offset < len(data)-1 && offset <= 14; offset++ {
		id := data[offset]
		switch id {
		case 0x2A, 0xAA: // Auth response  send E5
			session.Mu.RLock()
			sentE5 := session.SentNWBitStream
			session.Mu.RUnlock()
			
			if !sentE5 {
				log.Printf("[Inner 0x%02X at offset %d]  sending E5 to %s", id, offset, addr)
				session.Mu.Lock()
				session.SentNWBitStream = true
				session.Mu.Unlock()
				rh.sendE5PlayerSync(session)
			}
			return
		case 0x22: // Login data (can come wrapped)
			session.Mu.RLock()
			sentE3Phase1 := session.SentE3Phase1
			session.Mu.RUnlock()
			
			if !sentE3Phase1 {
				log.Printf("[Inner 0x22 at offset %d]  sending E3:01", offset)
				rh.handleLoginData(data[offset:], addr, session)
			}
			return
		}
	}
	
	// Fallback: large packet after E3:01 sent = auth response
	session.Mu.RLock()
	sentE3Phase1 := session.SentE3Phase1
	sentE5 := session.SentNWBitStream
	session.Mu.RUnlock()
	
	if len(data) > 50 && sentE3Phase1 && !sentE5 {
		log.Printf("[Heuristic] %dB packet after E3:01  sending E5 to %s", len(data), addr)
		session.Mu.Lock()
		session.SentNWBitStream = true
		session.Mu.Unlock()
		rh.sendE5PlayerSync(session)
		return
	}
	
	// CRITICAL: Trigger 0x04 streaming data on first keepalive after handshake
	session.Mu.RLock()
	state := session.State
	gameEntrySent := session.GameEntrySent
	session.Mu.RUnlock()
	
	if state == protocol.STATE_READY && !gameEntrySent {
		log.Printf(" First keepalive after handshake - triggering 0x04 streaming data!")
		
		// Set to IN_GAME state before streaming
		session.Mu.Lock()
		session.State = protocol.STATE_IN_GAME
		session.Mu.Unlock()
		
		// All packets now sent in sendPostStreamingSequence
		// rh.sendStreamingData(addr) - REMOVED
		rh.sendPostStreamingSequence(addr)
		
		log.Printf(" Sent 0x04 streaming data, now waiting for 0x28 join request")
	} else {
		log.Printf(" Client sending keepalive (state=%d, gameEntrySent=%v)", state, gameEntrySent)
	}
}

func (rh *RakNetHandler) handleInternalPacket(session *protocol.Session, packet *protocol.RakNetPacket) {
	switch packet.PacketID {
	case protocol.ID_CONNECTION_REQUEST:
		rh.handleConnectionRequest(session, packet)
	case protocol.ID_NEW_INCOMING_CONNECTION:
		rh.handleNewIncomingConnection(session, packet)
	case protocol.ID_DISCONNECTION_NOTIFICATION:
		rh.handleDisconnection(session)
	case protocol.ID_CONNECTED_PING:
		rh.handleConnectedPingInternal(session, packet)
	case 0x06:
		// SA-MP Join Request
		if len(packet.Payload) < 2 {
			log.Printf(" Invalid SA-MP join request: too short")
			return
		}
		nameLen := packet.Payload[1]
		if len(packet.Payload) < int(2+nameLen) {
			log.Printf(" Invalid SA-MP join request: name length mismatch")
			return
		}
		nickname := string(packet.Payload[2 : 2+nameLen])
		log.Printf(" Player joining: nickname=%s", nickname)
		session.Nickname = nickname
		rh.sendConnectionAccepted(session)
	case 0x2A:
		// SA-MP Auth Response - send 0xE5 player sync
		log.Printf(" Received 0x2A auth response (%d bytes) from %s", len(packet.Payload), session.Addr)
		rh.handle0x2AAuthResponse(nil, session.Addr, session)
	case 0x88:
		// SA-MP Auth/Join packet - handle based on payload length
		payloadLen := len(packet.Payload)
		log.Printf(" Received encapsulated 0x88 packet (payload: %d bytes)", payloadLen)
		
		if payloadLen >= 80 {
			// 84 bytes total (including packet ID) = 83 bytes payload
			// This is a join request with credentials - just ACK, wait for 0x28
			log.Printf(" 0x88 join request detected - ACKed, waiting for 0x28")
		} else if payloadLen >= 10 {
			// 13 bytes total = 12 bytes payload
			// Streaming complete signal (NOT USED - we don't send streaming automatically)
			log.Printf(" 0x88 streaming complete signal - ignored (waiting for 0x28)")
		} else if payloadLen >= 3 {
			// 6 bytes total = 5 bytes payload
			// First auth or keepalive
			if !session.GetHandshakeSent() {
				log.Printf(" 0x88 first auth - triggering full handshake")
				session.SetHandshakeSent(true)
				rh.sendFullHandshakeSequence(session.Addr)
			} else {
				log.Printf(" 0x88 keepalive during streaming")
			}
		}
	case 0x22:
		// SA-MP auth data (48 bytes including packet ID = 47 bytes payload)
		if len(packet.Payload) >= 45 {
			log.Printf(" Received encapsulated 0x22 auth data")
			
			// Send response packets (raw UDP, not encapsulated)
			rh.conn.WriteToUDP([]byte{0xe3, 0x01, 0x00}, session.Addr)
			
			clientIP := session.Addr.IP.To4()
			if clientIP == nil {
				clientIP = []byte{127, 0, 0, 1}
			}
			port := uint16(session.Addr.Port)
			pkt00 := []byte{
				0x00, 0x80, 0x42, 0x68, 0x22,
				clientIP[0], clientIP[1], clientIP[2], clientIP[3],
				byte(port), byte(port >> 8),
				0x00, 0x00, 0x27, 0x4c, 0x00, 0x00,
			}
			rh.conn.WriteToUDP(pkt00, session.Addr)
			rh.conn.WriteToUDP([]byte{0xe5, 0x02, 0x00, 0x02, 0x00, 0x02, 0x80, 0x00}, session.Addr)
			
			if session.State == protocol.STATE_CONNECTING {
				session.State = protocol.STATE_CONNECTED
				session.PlayerID = 0
			}
			session.State = protocol.STATE_READY
		}
	case 0x8A:
		// SA-MP join/auth request
		if len(packet.Payload) > 5 {
			log.Printf(" Received encapsulated 0x8A join/auth request (%d bytes payload)")
			
			// FIXED: Don't send game entry here - wait for 0x28
			log.Printf("    0x8A processed, waiting for 0x28 join request from client...")
		}
	case 0x77:
		// SA-MP Request Class
		log.Printf(" Received SA-MP 0x77 Request Class from player %d", session.PlayerID)
		rh.sendRequestClassResponse(session)
	case 0x7B:
		// SA-MP Spawn Request
		log.Printf(" Received SA-MP 0x7B Spawn Request from player %d", session.PlayerID)
		rh.sendPlayerSpawn(session)
		session.State = protocol.STATE_READY
		log.Printf(" Player %d spawned and ready!", session.PlayerID)
	default:
		// Log SA-MP packets for debugging
		if packet.PacketID >= 0x01 && packet.PacketID <= 0xFF {
			log.Printf(" Received SA-MP packet 0x%02X (%d bytes) from player %d", 
				packet.PacketID, len(packet.Payload), session.PlayerID)
		}
		
		// Forward to game packet handler
		if rh.onPacket != nil {
			rh.onPacket(session, packet)
		}
	}
}

func (rh *RakNetHandler) handleConnectionRequest(session *protocol.Session, packet *protocol.RakNetPacket) {
	log.Printf(" Received ID_CONNECTION_REQUEST (0x09) from %s", session.Addr.String())
	
	bs := protocol.NewBitStream(packet.Payload)
	clientGUID, _ := bs.ReadUint64()
	requestTime, err := bs.ReadUint64()
	if err != nil {
		log.Printf("Failed to read request time: %v", err)
		requestTime = uint64(time.Now().UnixMilli())
	}
	
	log.Printf("   Client GUID: %d, Request Time: %d", clientGUID, requestTime)
	
	// CRITICAL: Check for session migration (same GUID, different port)
	rh.mu.Lock()
	if existingSession, exists := rh.sessionsByGUID[clientGUID]; exists {
		oldAddr := existingSession.Addr.String()
		newAddr := session.Addr.String()
		
		if oldAddr != newAddr {
			// SESSION MIGRATION: Client changed port!
			log.Printf(" SESSION MIGRATION detected!")
			log.Printf("   GUID: %d", clientGUID)
			log.Printf("   Old address: %s", oldAddr)
			log.Printf("   New address: %s", newAddr)
			
			// Remove old session from maps
			delete(rh.sessions, oldAddr)
			log.Printf("    Removed old session from sessions map")
			
			// Update existing session with new address
			existingSession.Mu.Lock()
			existingSession.Addr = session.Addr
			existingSession.LastReceiveTime = time.Now()
			existingSession.Mu.Unlock()
			
			// Add to new address in sessions map
			rh.sessions[newAddr] = existingSession
			
			// Update sessionsByIP (use IP only)
			ipOnly := session.Addr.IP.String()
			rh.sessionsByIP[ipOnly] = existingSession
			
			log.Printf("    Migrated session to new address: %s", newAddr)
			log.Printf("   State preserved: MsgIdx=%d, OrderIdx=%d, SeqNum=%d, State=%d",
				existingSession.MessageIndex, existingSession.OrderIndex, 
				existingSession.SequenceNumber, existingSession.State)
			
			rh.mu.Unlock()
			
			// Send response to NEW address
			rh.sendConnectionRequestAcceptedProper(existingSession, requestTime)
			return
		}
		
		log.Printf("    Same GUID, same address - continuing existing session")
	} else {
		// New GUID - store in sessionsByGUID
		session.Mu.Lock()
		session.GUID = clientGUID
		session.Mu.Unlock()
		
		rh.sessionsByGUID[clientGUID] = session
		log.Printf("    Stored new session with GUID: %d", clientGUID)
	}
	rh.mu.Unlock()
	
	// Send proper ID_CONNECTION_REQUEST_ACCEPTED (0x10)
	rh.sendConnectionRequestAcceptedProper(session, requestTime)
}

func (rh *RakNetHandler) sendConnectionRequestAcceptedProper(session *protocol.Session, clientTime uint64) {
	log.Printf("=== Sending ID_CONNECTION_REQUEST_ACCEPTED (0x10) ===")
	
	response := protocol.NewEmptyBitStream()
	response.WriteByte(protocol.ID_CONNECTION_REQUEST_ACCEPTED)
	
	// Client external address
	response.WriteAddress(session.Addr)
	
	// Client index (2 bytes)
	response.WriteUint16(0)
	
	// Server internal address (use server's address)
	serverAddr := &net.UDPAddr{
		IP:   net.IPv4(127, 0, 0, 1),
		Port: 7777,
	}
	response.WriteAddress(serverAddr)
	
	// Timestamp (8 bytes, big-endian) - echo client time
	response.WriteUint64(clientTime)
	
	// Server timestamp (8 bytes, big-endian)
	response.WriteUint64(uint64(time.Now().UnixMilli()))
	
	// Encapsulate in RELIABLE_ORDERED frame
	encap := &protocol.EncapsulatedPacket{
		Reliability: protocol.RELIABLE_ORDERED,
		Payload:     response.GetData(),
	}
	session.AddToQueue(encap)
	
	log.Printf(" Queued ID_CONNECTION_REQUEST_ACCEPTED to %s", session.Addr.String())
}

func (rh *RakNetHandler) sendConnectionRequestAccepted(session *protocol.Session) {
	log.Printf("=== Sending 0x10 ID_CONNECTION_REQUEST_ACCEPTED (RAW UDP) ===")
	
	// Build 0x10 payload - RAW UDP, tidak wrapped RakNet
	payload := []byte{0x10} // ID_CONNECTION_REQUEST_ACCEPTED
	
	// Client address (6 bytes: 4 IP + 2 port big-endian)
	clientIP := session.Addr.IP.To4()
	if clientIP == nil {
		clientIP = []byte{127, 0, 0, 1}
	}
	payload = append(payload, clientIP...)
	clientPort := uint16(session.Addr.Port)
	payload = append(payload, byte(clientPort>>8), byte(clientPort))
	
	// System index (2 bytes)
	payload = append(payload, 0x00, 0x00)
	
	// Server address (6 bytes)
	serverIP := []byte{127, 0, 0, 1}
	payload = append(payload, serverIP...)
	serverPort := uint16(7777)
	payload = append(payload, byte(serverPort>>8), byte(serverPort))
	
	// Timestamp (8 bytes big-endian)
	timestamp := uint64(time.Now().UnixMilli())
	for i := 7; i >= 0; i-- {
		payload = append(payload, byte(timestamp>>(uint(i)*8)))
	}
	
	// Send RAW UDP
	rh.conn.WriteToUDP(payload, session.Addr)
	log.Printf(" Sent raw 0x10 (%d bytes) to %s", len(payload), session.Addr)
	log.Printf("   Payload hex: %x", payload)
}

// ============================================================
// SA-MP Packet Definitions moved to protocol/samp_packets.go
// All packet variables and game entry sequence functions are now in the protocol package

// splitPayload - Split large payload into smaller chunks that fit within MTU
func splitPayload(payload []byte, maxChunkSize int) [][]byte {
	if len(payload) <= maxChunkSize {
		return [][]byte{payload}
	}
	
	var chunks [][]byte
	for i := 0; i < len(payload); i += maxChunkSize {
		end := i + maxChunkSize
		if end > len(payload) {
			end = len(payload)
		}
		// Create a copy of the chunk
		chunk := make([]byte, end-i)
		copy(chunk, payload[i:end])
		chunks = append(chunks, chunk)
	}
	
	return chunks
}

// copyBytes - Helper function to copy bytes safely
func copyBytes(src []byte) []byte {
	dst := make([]byte, len(src))
	copy(dst, src)
	return dst
}

// sendRakNetDatagram - Send raw data wrapped in RakNet datagram with proper sequence
// sendRakNetDatagram - Send payload wrapped in RakNet datagram with RELIABLE_ORDERED on channel 0
func (rh *RakNetHandler) sendRakNetDatagram(session *protocol.Session, payload []byte) {
	channel := uint8(0) // Use channel 0 for streaming packets
	
	// VALIDATION 1: Payload tidak boleh kosong
	if len(payload) == 0 {
		log.Printf(" ERROR: Payload kosong tidak boleh dikirim")
		return
	}
	
	// Get MTU for validation
	session.Mu.Lock()
	mtu := session.MTU
	session.Mu.Unlock()
	
	// Calculate safe payload size for RELIABLE_ORDERED (no split header yet)
	// Datagram header: 4 bytes
	// Encapsulation header (no split): 11 bytes
	headerSizeNoSplit := 4 + 11
	maxSafePayloadNoSplit := int(mtu) - protocol.MTU_SAFETY_MARGIN - headerSizeNoSplit
	
	// Check if payload needs to be split
	if len(payload) > maxSafePayloadNoSplit {
		log.Printf(" Payload size %d exceeds safe limit %d, using SPLIT PACKET mechanism", 
			len(payload), maxSafePayloadNoSplit)
		rh.sendRakNetDatagramSplit(session, payload, channel)
		return
	}
	
	// Payload fits without split, send normally
	rh.sendRakNetDatagramSingle(session, payload, channel, false, nil, nil)
}

// sendRakNetDatagramSingle - Send single datagram (with or without split info)
// If orderIndexPtr is provided, use it instead of incrementing (for split packets)
func (rh *RakNetHandler) sendRakNetDatagramSingle(session *protocol.Session, payload []byte, channel uint8, isSplit bool, splitInfo *SplitInfo, orderIndexPtr *uint32) {
	session.Mu.RLock()
	mtu := session.MTU
	session.Mu.RUnlock()
	rh.sendRakNetDatagramSingleWithMTU(session, payload, channel, isSplit, splitInfo, mtu, orderIndexPtr)
}

// sendRakNetDatagramSingleWithMTU - Send single datagram with explicit MTU (for split packet consistency)
// If orderIndexPtr is provided, use it instead of incrementing (for split packets)
func (rh *RakNetHandler) sendRakNetDatagramSingleWithMTU(session *protocol.Session, payload []byte, channel uint8, isSplit bool, splitInfo *SplitInfo, mtu uint16, orderIndexPtr *uint32) {
	// VALIDATION 1: Payload tidak boleh kosong
	if len(payload) == 0 {
		log.Printf(" ERROR: Payload kosong tidak boleh dikirim")
		return
	}
	
	// Calculate header size
	headerSize := 4 + 11 // Datagram + Encapsulation (no split)
	if isSplit {
		headerSize += 8 // Add split header: 2 (count) + 2 (ID) + 4 (index) = 8 bytes
	}
	
	totalSize := headerSize + len(payload)
	
	// VALIDATION 2: Check safe MTU limit
	maxSafeSize := int(mtu) - protocol.MTU_SAFETY_MARGIN
	if totalSize > maxSafeSize {
		log.Printf(" ERROR: Fragment size %d exceeds safe MTU limit %d", totalSize, maxSafeSize)
		return
	}
	
	// Get and increment sequence numbers atomically
	session.Mu.Lock()
	datagramSeq := session.SequenceNumber
	session.SequenceNumber++
	messageIndex := session.MessageIndex
	session.MessageIndex++
	
	// Get ordering index - either use provided one (for split) or increment new one
	var orderIndex uint32
	if orderIndexPtr != nil {
		// Split packet - use shared orderIndex
		orderIndex = *orderIndexPtr
	} else {
		// Normal packet - get and increment ordering index for THIS channel
		if session.ChannelOrderIndex == nil {
			session.ChannelOrderIndex = make(map[uint8]uint32)
		}
		orderIndex = session.ChannelOrderIndex[channel]
		session.ChannelOrderIndex[channel]++
		
		// DEBUG: Log orderIndex increment for channel 0
		if channel == 0 {
			log.Printf("   ORDER DEBUG  sending ordered packet on ch=%d with orderIndex=%d (next will be %d)", 
				channel, orderIndex, session.ChannelOrderIndex[channel])
		}
	}
	session.Mu.Unlock()
	
	// Build RELIABLE_ORDERED encapsulated packet
	buf := new(bytes.Buffer)
	
	// 1. Datagram header: 0x84 + sequence (3 bytes little-endian)
	buf.WriteByte(0x84)
	buf.WriteByte(byte(datagramSeq))
	buf.WriteByte(byte(datagramSeq >> 8))
	buf.WriteByte(byte(datagramSeq >> 16))
	
	// 2. Encapsulated packet header
	// Flags: RELIABLE_ORDERED = 0x60, SPLIT = 0x10 if split
	flags := byte(0x60) // RELIABLE_ORDERED (3 << 5)
	if isSplit {
		flags |= 0x10 // Set split flag (bit 4)
	}
	buf.WriteByte(flags)
	
	// Length in bits (2 bytes big-endian) - CRITICAL: Must be exact!
	lengthBits := uint16(len(payload) * 8)
	buf.WriteByte(byte(lengthBits >> 8))
	buf.WriteByte(byte(lengthBits))
	
	// Message index (3 bytes little-endian)
	buf.WriteByte(byte(messageIndex))
	buf.WriteByte(byte(messageIndex >> 8))
	buf.WriteByte(byte(messageIndex >> 16))
	
	// Ordering index (3 bytes little-endian) - SAME for all fragments in split packet!
	buf.WriteByte(byte(orderIndex))
	buf.WriteByte(byte(orderIndex >> 8))
	buf.WriteByte(byte(orderIndex >> 16))
	
	// Ordering channel (1 byte) - MUST be 0 for SA-MP
	buf.WriteByte(channel)
	
	// 3. Split header (if split)
	if isSplit && splitInfo != nil {
		// Split count (2 bytes big-endian) - FIXED: was 4 bytes!
		buf.WriteByte(byte(splitInfo.SplitCount >> 8))
		buf.WriteByte(byte(splitInfo.SplitCount))
		
		// Split ID (2 bytes big-endian)
		buf.WriteByte(byte(splitInfo.SplitID >> 8))
		buf.WriteByte(byte(splitInfo.SplitID))
		
		// Split index (4 bytes big-endian)
		buf.WriteByte(byte(splitInfo.SplitIndex >> 24))
		buf.WriteByte(byte(splitInfo.SplitIndex >> 16))
		buf.WriteByte(byte(splitInfo.SplitIndex >> 8))
		buf.WriteByte(byte(splitInfo.SplitIndex))
	}
	
	// 4. Payload
	buf.Write(payload)
	
	packet := buf.Bytes()
	
	// VALIDATION 3: Verify encapsulated packet structure
	if err := validateEncapsulatedPacket(packet, len(payload), flags, channel, isSplit); err != nil {
		log.Printf(" ENCAPSULATION VALIDATION FAILED: %v", err)
		log.Printf("   Datagram seq=%d, msg=%d, order=%d, ch=%d", datagramSeq, messageIndex, orderIndex, channel)
		return
	}
	
	// Store for retransmission
	session.StorePendingACK(datagramSeq, copyBytes(packet))
	
	// Send packet
	rh.conn.WriteToUDP(packet, session.Addr)
	
	if isSplit && splitInfo != nil {
		log.Printf(" Sent SPLIT fragment seq=%d msg=%d order=%d ch=%d splitID=%d idx=%d/%d payloadLen=%d totalSize=%d MTU=%d", 
			datagramSeq, messageIndex, orderIndex, channel, 
			splitInfo.SplitID, splitInfo.SplitIndex, splitInfo.SplitCount-1, 
			len(payload), len(packet), mtu)
		log.Printf("   Fragment hex (first 64 bytes): %02X", packet[:min(64, len(packet))])
	} else {
		log.Printf(" Sent datagram seq=%d msg=%d order=%d ch=%d payload[0]=0x%02X payloadLen=%d totalSize=%d MTU=%d", 
			datagramSeq, messageIndex, orderIndex, channel, payload[0], len(payload), len(packet), mtu)
		log.Printf("   Packet hex (first 64 bytes): %02X", packet[:min(64, len(packet))])
	}
}

// validateEncapsulatedPacket - Validate encapsulated packet structure
func validateEncapsulatedPacket(packet []byte, expectedPayloadLen int, expectedFlags byte, expectedChannel uint8, hasSplit bool) error {
	minSize := 4 + 11 // Datagram + Encapsulation
	if hasSplit {
		minSize += 8 // Split header: 2 + 2 + 4 = 8 bytes
	}
	
	if len(packet) < minSize {
		return fmt.Errorf("packet too small: %d bytes (expected >= %d)", len(packet), minSize)
	}
	
	// Validate datagram header
	if (packet[0] & 0x80) == 0 {
		return fmt.Errorf("invalid datagram flag: 0x%02X (expected 0x84)", packet[0])
	}
	
	// Validate encapsulation flags
	actualFlags := packet[4]
	reliability := (actualFlags >> 5) & 0x07
	splitFlag := (actualFlags & 0x10) != 0
	
	if reliability != 3 {
		return fmt.Errorf("invalid reliability: %d (expected 3 for RELIABLE_ORDERED)", reliability)
	}
	
	if hasSplit && !splitFlag {
		return fmt.Errorf("split expected but flag not set")
	}
	
	if !hasSplit && splitFlag {
		return fmt.Errorf("split flag set but no split info provided")
	}
	
	// Validate length field
	lengthBits := uint16(packet[5])<<8 | uint16(packet[6])
	lengthBytes := lengthBits / 8
	if int(lengthBytes) != expectedPayloadLen {
		return fmt.Errorf("length mismatch: encoded=%d bytes, expected=%d bytes", lengthBytes, expectedPayloadLen)
	}
	
	// Validate ordering channel
	actualChannel := packet[13]
	if actualChannel != expectedChannel {
		return fmt.Errorf("channel mismatch: actual=%d, expected=%d", actualChannel, expectedChannel)
	}
	
	return nil
}

// SplitInfo - Information for split packets
type SplitInfo struct {
	SplitCount uint32 // Total number of fragments
	SplitID    uint16 // Unique ID for this split message
	SplitIndex uint32 // Index of this fragment (0-based)
}

// sendRakNetDatagramSplit - Send large payload as multiple split fragments
func (rh *RakNetHandler) sendRakNetDatagramSplit(session *protocol.Session, payload []byte, channel uint8) {
	// CRITICAL: Lock MTU at the start - don't allow changes during split
	session.Mu.Lock()
	mtu := session.MTU
	session.SplitInProgress = true // Lock MTU updates
	
	// Get and increment orderIndex ONCE for the entire split message
	if session.ChannelOrderIndex == nil {
		session.ChannelOrderIndex = make(map[uint8]uint32)
	}
	sharedOrderIndex := session.ChannelOrderIndex[channel]
	session.ChannelOrderIndex[channel]++
	session.Mu.Unlock()
	
	log.Printf(" MTU locked at %d for split packet transmission, orderIndex=%d (shared)", mtu, sharedOrderIndex)
	
	// Calculate max chunk size
	// Datagram header: 4 bytes
	// Encapsulation header with split: 11 + 8 = 19 bytes (FIXED: was 21!)
	headerSize := 4 + 19
	maxChunkSize := int(mtu) - protocol.MTU_SAFETY_MARGIN - headerSize
	
	if maxChunkSize <= 0 {
		log.Printf(" ERROR: MTU %d too small for split packets", mtu)
		session.Mu.Lock()
		session.SplitInProgress = false
		session.Mu.Unlock()
		return
	}
	
	// Split payload into chunks
	chunks := splitPayload(payload, maxChunkSize)
	
	// Get unique split ID
	session.Mu.Lock()
	splitID := session.SplitID
	session.SplitID++
	session.Mu.Unlock()
	
	log.Printf(" Splitting payload %d bytes into %d fragments (splitID=%d, chunkSize=%d, MTU=%d, orderIndex=%d)", 
		len(payload), len(chunks), splitID, maxChunkSize, mtu, sharedOrderIndex)
	
	// Send each fragment with LOCKED MTU and SHARED orderIndex
	for i, chunk := range chunks {
		splitInfo := &SplitInfo{
			SplitCount: uint32(len(chunks)),
			SplitID:    splitID,
			SplitIndex: uint32(i),
		}
		
		// Pass locked MTU and shared orderIndex to ensure consistency
		rh.sendRakNetDatagramSingleWithMTU(session, chunk, channel, true, splitInfo, mtu, &sharedOrderIndex)
		
		// Small delay between fragments to avoid overwhelming client
		time.Sleep(2 * time.Millisecond)
	}
	
	// Unlock MTU after all fragments sent
	session.Mu.Lock()
	session.SplitInProgress = false
	session.Mu.Unlock()
	
	log.Printf(" Sent all %d fragments for splitID=%d with consistent MTU=%d orderIndex=%d (unlocked)", len(chunks), splitID, mtu, sharedOrderIndex)
}

// sendRakNetReliable - Send payload wrapped in RakNet datagram with RELIABLE reliability
func (rh *RakNetHandler) sendRakNetReliable(session *protocol.Session, payload []byte) {
	// VALIDATION 1: Payload tidak boleh kosong
	if len(payload) == 0 {
		log.Printf(" ERROR: Payload kosong tidak boleh dikirim (RELIABLE)")
		return
	}
	
	// Get MTU for validation
	session.Mu.Lock()
	mtu := session.MTU
	session.Mu.Unlock()
	
	// VALIDATION 2: Calculate total packet size
	// Datagram header: 4 bytes (0x84 + 3 byte seq)
	// Encapsulation header: 7 bytes (flags + length + message index) - NO ordering for RELIABLE
	headerSize := 4 + 7
	totalSize := headerSize + len(payload)
	
	// VALIDATION 3: Packet tidak boleh melebihi safe MTU limit
	maxSafeSize := int(mtu) - protocol.MTU_SAFETY_MARGIN
	if totalSize > maxSafeSize {
		log.Printf(" ERROR: RELIABLE packet size %d exceeds safe MTU limit %d (MTU=%d - margin=%d)", 
			totalSize, maxSafeSize, mtu, protocol.MTU_SAFETY_MARGIN)
		return
	}
	
	// Log warning jika mendekati batas
	warningThreshold := (maxSafeSize * 9) / 10
	if totalSize > warningThreshold {
		log.Printf(" WARNING: RELIABLE packet size %d is close to safe limit %d", totalSize, maxSafeSize)
	}
	
	// Get sequence numbers (atomic operation via session mutex)
	session.Mu.Lock()
	seq := session.SequenceNumber
	session.SequenceNumber++
	reliableSeq := session.MessageIndex
	session.MessageIndex++
	session.Mu.Unlock()
	
	lengthBits := uint16(len(payload) * 8)
	
	buf := new(bytes.Buffer)
	
	// RakNet datagram header
	buf.WriteByte(0x84) // flags (valid + ACK)
	// Datagram sequence (3 bytes little-endian)
	buf.WriteByte(byte(seq))
	buf.WriteByte(byte(seq >> 8))
	buf.WriteByte(byte(seq >> 16))
	
	// Encapsulated packet header
	buf.WriteByte(0x40) // reliability = RELIABLE (2 << 5 = 0x40)
	// Length in bits (2 bytes big-endian)
	binary.Write(buf, binary.BigEndian, lengthBits)
	// Reliable message sequence (3 bytes little-endian)
	buf.WriteByte(byte(reliableSeq))
	buf.WriteByte(byte(reliableSeq >> 8))
	buf.WriteByte(byte(reliableSeq >> 16))
	
	// Payload
	buf.Write(payload)
	
	packetBytes := buf.Bytes()
	
	// VALIDATION 4: Verify packet structure
	if len(packetBytes) < 5 {
		log.Printf(" ERROR: RELIABLE packet terlalu kecil (%d bytes)", len(packetBytes))
		return
	}
	
	// VALIDATION 5: Verify length field
	encodedLengthBits := uint16(packetBytes[5])<<8 | uint16(packetBytes[6])
	encodedLengthBytes := encodedLengthBits / 8
	if encodedLengthBytes != uint16(len(payload)) {
		log.Printf(" ERROR: RELIABLE length mismatch! Encoded: %d, Actual: %d", encodedLengthBytes, len(payload))
		return
	}
	
	log.Printf(" VALID RELIABLE seq=%d msg=%d payload[0]=0x%02X size=%d MTU=%d", 
		seq, reliableSeq, payload[0], len(packetBytes), mtu)
	
	// CRITICAL: Store a COPY of the packet for retransmission BEFORE sending
	session.StorePendingACK(seq, copyBytes(packetBytes))
	
	// Send packet
	rh.conn.WriteToUDP(packetBytes, session.Addr)
}

func (rh *RakNetHandler) handleNewIncomingConnection(session *protocol.Session, packet *protocol.RakNetPacket) {
	session.State = protocol.STATE_CONNECTED
	log.Printf("Client connected: %s", session.Addr.String())
}

func (rh *RakNetHandler) handleDisconnection(session *protocol.Session) {
	log.Printf("Client disconnected: %s", session.Addr.String())
	
	rh.mu.Lock()
	delete(rh.sessions, session.Addr.String())
	rh.mu.Unlock()
}

func (rh *RakNetHandler) handleConnectedPingInternal(session *protocol.Session, packet *protocol.RakNetPacket) {
	bs := protocol.NewBitStream(packet.Payload)
	pingTime, _ := bs.ReadUint64()
	
	// Send pong
	response := protocol.NewEmptyBitStream()
	response.WriteByte(protocol.ID_CONNECTED_PONG)
	response.WriteUint64(pingTime)
	response.WriteUint64(uint64(time.Now().UnixNano() / int64(time.Millisecond)))
	
	encap := &protocol.EncapsulatedPacket{
		Reliability: protocol.UNRELIABLE,
		Payload:     response.GetData(),
	}
	session.AddToQueue(encap)
}

func (rh *RakNetHandler) handleACK(data []byte, addr *net.UDPAddr) {
	if len(data) < 4 {
		return
	}
	
	sessionKey := addr.String()
	
	rh.mu.RLock()
	session, exists := rh.sessions[sessionKey]
	rh.mu.RUnlock()
	
	if !exists {
		return
	}
	
	// Parse ACK packet format
	count := binary.BigEndian.Uint16(data[1:3])
	offset := 3
	
	for i := 0; i < int(count); i++ {
		if offset+6 > len(data) {
			break
		}
		
		// Read sequence numbers (3 bytes LITTLE-endian each)
		minSeq := uint32(data[offset]) | uint32(data[offset+1])<<8 | uint32(data[offset+2])<<16
		maxSeq := uint32(data[offset+3]) | uint32(data[offset+4])<<8 | uint32(data[offset+5])<<16
		
		for seq := minSeq; seq <= maxSeq; seq++ {
			session.DeletePendingACK(seq)
		}
		
		offset += 6
	}
	
	// No response needed for ACK
}

func (rh *RakNetHandler) handleNACK(data []byte, addr *net.UDPAddr) {
	if len(data) < 3 {
		return
	}
	
	sessionKey := addr.String()
	
	rh.mu.RLock()
	session, exists := rh.sessions[sessionKey]
	rh.mu.RUnlock()
	
	if !exists {
		log.Printf(" NACK from unknown session: %s", addr)
		return
	}
	
	// Parse NACK packet format (CORRECT FORMAT)
	// Format: 0xA0 + count(2 bytes LITTLE-endian) + records
	// Each record: minSeq(3 bytes LE) + maxSeq(3 bytes LE) = 6 bytes
	count := binary.LittleEndian.Uint16(data[1:3])
	
	// CRITICAL: Validate count
	if count == 0 || count > 512 {
		log.Printf(" NACK count invalid: %d (expected 1-512), ignoring packet", count)
		return
	}
	
	offset := 3
	expectedLen := 3 + (int(count) * 6)
	
	if len(data) < expectedLen {
		log.Printf(" NACK packet too short: %d bytes (expected %d for count=%d)", len(data), expectedLen, count)
		return
	}
	
	log.Printf(" Received NACK from %s, count: %d", addr, count)
	
	retransmitCount := 0
	
	for i := 0; i < int(count); i++ {
		if offset+6 > len(data) {
			log.Printf("    NACK packet truncated at entry %d", i)
			break
		}
		
		// Read min and max sequence (each 3 bytes LITTLE-endian)
		minSeq := uint32(data[offset]) | uint32(data[offset+1])<<8 | uint32(data[offset+2])<<16
		maxSeq := uint32(data[offset+3]) | uint32(data[offset+4])<<8 | uint32(data[offset+5])<<16
		
		log.Printf("    NACK range: %d-%d", minSeq, maxSeq)
		
		// Retransmit all packets in range
		for seq := minSeq; seq <= maxSeq && seq < minSeq+100; seq++ {
			if packetData, exists := session.GetPendingACK(seq); exists {
				rh.conn.WriteToUDP(packetData, addr)
				retransmitCount++
				log.Printf("    Retransmitted packet seq=%d (%d bytes)", seq, len(packetData))
			} else {
				log.Printf("    Cannot retransmit seq=%d (not in PendingACK map)", seq)
			}
		}
		
		offset += 6
	}
	
	log.Printf(" Retransmitted %d packets in response to NACK", retransmitCount)
}

func (rh *RakNetHandler) SendPacket(session *protocol.Session, packet *protocol.RakNetPacket, reliability byte) {
	encap := &protocol.EncapsulatedPacket{
		Reliability: reliability,
		Payload:     packet.Serialize(),
	}
	session.AddToQueue(encap)
}

func (rh *RakNetHandler) Update() {
	rh.mu.RLock()
	sessions := make([]*protocol.Session, 0, len(rh.sessions))
	for _, session := range rh.sessions {
		sessions = append(sessions, session)
	}
	rh.mu.RUnlock()
	
	// Just update sessions, don't check timeout here
	// Timeout checking is done by CleanupStaleSessions() called every 5 seconds
	for _, session := range sessions {
		session.Update(rh.conn)
	}
}
// CleanupStaleSessions - Remove sessions that have timed out (REAL timeout only)
// This is called periodically by the server's cleanup loop
// CRITICAL: Only delete sessions on REAL timeout (>30s no traffic), NOT on packet anomalies
func (rh *RakNetHandler) CleanupStaleSessions() {
	rh.mu.RLock()
	sessions := make(map[string]*protocol.Session)
	for addr, session := range rh.sessions {
		sessions[addr] = session
	}
	rh.mu.RUnlock()

	now := time.Now()

	for addr, session := range sessions {
		idleTime := now.Sub(session.LastReceiveTime)

		// Timeout berbeda berdasarkan state
		timeout := 30 * time.Second
		session.Mu.RLock()
		gameEntrySent := session.GameEntrySent
		session.Mu.RUnlock()
		
		if gameEntrySent {
			// Player sudah spawn  beri waktu lebih lama
			timeout = 300 * time.Second
		}

		// Only delete if REAL timeout occurred
		if idleTime > timeout {
			stateName := "UNKNOWN"
			switch session.State {
			case protocol.STATE_UNCONNECTED:
				stateName = "UNCONNECTED"
			case protocol.STATE_HANDSHAKE_SENT:
				stateName = "HANDSHAKE_SENT"
			case protocol.STATE_CONNECTING:
				stateName = "CONNECTING"
			case protocol.STATE_CONNECTED:
				stateName = "CONNECTED"
			case protocol.STATE_READY:
				stateName = "READY"
			}

			log.Printf(" Cleaning up stale session: %s (state: %s/%d, idle: %.1fs, timeout: %.1fs)",
				addr, stateName, session.State, idleTime.Seconds(), timeout.Seconds())

			// Send disconnection notification if connected
			if session.State >= protocol.STATE_CONNECTED {
				log.Printf("   Sending ID_DISCONNECTION_NOTIFICATION to %s", session.Addr.String())

				disconnectPacket := protocol.NewEmptyBitStream()
				disconnectPacket.WriteByte(protocol.ID_DISCONNECTION_NOTIFICATION)

				encap := &protocol.EncapsulatedPacket{
					Reliability: protocol.RELIABLE_ORDERED,
					Payload:     disconnectPacket.GetData(),
				}
				session.AddToQueue(encap)
				session.Update(rh.conn)
			}

			// Remove from all maps
			rh.mu.Lock()

			// Remove from sessions map (by IP:Port)
			delete(rh.sessions, addr)

			// Remove from sessionsByIP map (by IP only)
			if session.Addr != nil {
				ipKey := session.Addr.IP.String()
				delete(rh.sessionsByIP, ipKey)
			}

			// Remove from sessionsByGUID map (by GUID)
			if session.GUID != 0 {
				delete(rh.sessionsByGUID, session.GUID)
			}

			rh.mu.Unlock()

			log.Printf("    Session %s removed from all maps (IP, GUID, sessions)", addr)
		}
	}
}


func (rh *RakNetHandler) GetSessions() []*protocol.Session {
	rh.mu.RLock()
	defer rh.mu.RUnlock()
	
	sessions := make([]*protocol.Session, 0, len(rh.sessions))
	for _, session := range rh.sessions {
		sessions = append(sessions, session)
	}
	return sessions
}

func bytesEqual(a, b []byte) bool {
	if len(a) != len(b) {
		return false
	}
	for i := range a {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}

// Helper function to encode address for RakNet packets
func encodeAddressV2(addr *net.UDPAddr) []byte {
	ip := addr.IP.To4()
	if ip == nil {
		ip = []byte{127, 0, 0, 1}
	}
	port := uint16(addr.Port)
	lo := byte(port & 0xFF)
	hi := byte((port >> 8) & 0xFF)
	log.Printf("encodeAddressV2: port=%d lo=%02x hi=%02x", addr.Port, lo, hi)
	return []byte{4, ip[0], ip[1], ip[2], ip[3], lo, hi}
}


// handleOpenConnectionRequest2Proper - Handle Open Connection Request (0x0A or 0x08 in SA-MP)
func (rh *RakNetHandler) handleOpenConnectionRequest2Proper(data []byte, addr *net.UDPAddr) {
	packetID := data[0]
	log.Printf(" Received Open Connection Request 0x%02X (%d bytes) from %s", packetID, len(data), addr)
	
	// Parse MTU using BitStream for correct endianness
	mtu := uint16(protocol.DEFAULT_MTU_SIZE)
	if len(data) >= 26 {
		bs := protocol.NewBitStream(data)
		bs.ReadByte() // Packet ID (0x0A)
		bs.ReadBytes(16) // Magic
		bs.ReadAddress() // Server address (7 bytes)
		
		// Read MTU (big-endian uint16)
		parsedMTU, err := bs.ReadUint16()
		if err == nil {
			// Sanitize MTU using helper function
			mtu = sanitizeMTU(parsedMTU)
		} else {
			log.Printf(" Failed to parse MTU, using default %d", mtu)
		}
	}
	
	// CRITICAL FIX: Don't send 0x03/0x04 here - wait for keepalive to trigger streaming
	// The proper flow is:
	// 1. Receive 0x0A  send 0x0B reply and create/update session
	// 2. Client sends keepalive (empty data packet)
	// 3. Server triggers sendGameEntrySequence (sends 0x03, 0x04, streaming packets)
	
	// Send 0x0B Open Connection Reply 2
	response := protocol.NewEmptyBitStream()
	response.WriteByte(0x0B) // ID_OPEN_CONNECTION_REPLY_2 in SA-MP context
	response.WriteBytes(protocol.OfflineMessageDataID)
	response.WriteUint64(serverGUID)
	response.WriteAddress(addr) // Client address
	response.WriteUint16(mtu)
	response.WriteByte(0) // ServerHasSecurity = false
	
	n, err := rh.conn.WriteToUDP(response.GetData(), addr)
	if err != nil {
		log.Printf(" Failed to send 0x0B reply: %v", err)
	} else {
		log.Printf(" Sent 0x0B Open Connection Reply 2 (%d bytes) - MTU=%d", n, mtu)
	}
	
	// FIX #9: Send E3:07 join response after 0x0A (if not already sent)
	sessionKey := addr.String()
	rh.mu.RLock()
	session, sessionExists := rh.sessions[sessionKey]
	rh.mu.RUnlock()
	
	if sessionExists {
		session.Mu.Lock()
		if !session.SentE3Phase7 && len(data) >= 84 {
			// This is a full connection request (84 bytes) - send E3:07
			session.SentE3Phase7 = true
			session.Mu.Unlock()
			
			rh.conn.WriteToUDP(protocol.PacketE3_07, addr)
			log.Printf(" Sent E3:07 join response to %s", addr)
		} else {
			session.Mu.Unlock()
		}
	}
	
	// CRITICAL FIX: Check session state before resetting
	// Only reset if session doesn't exist OR is in UNCONNECTED state
	// DO NOT reset if session is active (CONNECTING, CONNECTED, READY)
	rh.mu.Lock()
	
	session, exists := rh.sessions[sessionKey]
	
	if exists {
		// Session already exists - check state
		session.Mu.RLock()
		currentState := session.State
		splitInProgress := session.SplitInProgress
		gameEntrySent := session.GameEntrySent
		session.Mu.RUnlock()
		
		// CRITICAL: Don't reset if session is active OR has sent streaming data
		if currentState >= protocol.STATE_CONNECTING || gameEntrySent {
			// Session is ACTIVE - DO NOT RESET!
			// Just update MTU if needed and refresh timestamp
			session.Mu.Lock()
			
			// CRITICAL: Don't update MTU during split packet transmission
			if splitInProgress {
				log.Printf(" MTU update deferred for %s - split packet in progress (current=%d, requested=%d)", 
					sessionKey, session.MTU, mtu)
			} else if session.MTU != mtu {
				log.Printf(" Active session for %s, updating MTU %d  %d (state preserved, gameEntrySent=%v)", 
					sessionKey, session.MTU, mtu, gameEntrySent)
				session.MTU = mtu
			} else {
				log.Printf(" Active session for %s exists (state=%d, gameEntrySent=%v), preserving state", 
					sessionKey, currentState, gameEntrySent)
			}
			session.LastReceiveTime = time.Now()
			session.Mu.Unlock()
			rh.mu.Unlock()
			return
		}
		
		// Session exists but in UNCONNECTED state - safe to reset
		log.Printf(" RESETTING stale session for %s (state=%d)", sessionKey, currentState)
		log.Printf("   Old state: MTU=%d, MsgIdx=%d, OrderIdx=%d, SeqNum=%d", 
			session.MTU, session.MessageIndex, session.OrderIndex, session.SequenceNumber)
		delete(rh.sessions, sessionKey)
		log.Printf("    Stale session deleted")
	}
	
	// Create fresh session with validated MTU
	session = protocol.NewSession(addr, mtu)
	rh.sessions[sessionKey] = session
	session.State = protocol.STATE_CONNECTING
	session.LastReceiveTime = time.Now()
	
	log.Printf(" Created NEW session for %s with MTU %d (all indices start from 0)", sessionKey, mtu)
	log.Printf("   Fresh state: MsgIdx=0, OrderIdx=0, SeqNum=0, SplitID=0")
	
	rh.mu.Unlock()
}

// handleOpenConnectionRequest1Short - Handle 22-byte variant as Request 1
func (rh *RakNetHandler) handleOpenConnectionRequest1Short(data []byte, addr *net.UDPAddr) {
	log.Printf("Handling as Open Connection Request 1")
	
	mtu := uint16(1492) // Default MTU
	
	// Build 0x06 Open Connection Reply 1
	reply := make([]byte, 0, 32)
	reply = append(reply, 0x06)
	reply = append(reply, protocol.OfflineMessageDataID[:]...)
	
	// Server GUID (8 bytes, big-endian)
	guidBytes := make([]byte, 8)
	binary.BigEndian.PutUint64(guidBytes, serverGUID)
	reply = append(reply, guidBytes...)
	
	// Security byte
	reply = append(reply, 0x00)
	
	// MTU (2 bytes, big-endian)
	reply = append(reply, byte(mtu>>8), byte(mtu))
	
	n, err := rh.conn.WriteToUDP(reply, addr)
	if err != nil {
		log.Printf(" Failed to send 0x06: %v", err)
		return
	}
	
	log.Printf(" Sent 0x06 Open Connection Reply 1: %d bytes", n)
}


// handleConnectedPing - Handle 0x20 Connected Ping
func (rh *RakNetHandler) handleConnectedPing(data []byte, addr *net.UDPAddr) {
	if len(data) < 9 {
		return
	}
	
	// Parse ping time (8 bytes, big-endian)
	pingTime := binary.BigEndian.Uint64(data[1:9])
	
	log.Printf("Received Connected Ping from %s, time: %d", addr, pingTime)
	
	// Build 0x03 Connected Pong response
	reply := make([]byte, 17)
	reply[0] = 0x03 // Connected Pong
	binary.BigEndian.PutUint64(reply[1:9], pingTime)
	binary.BigEndian.PutUint64(reply[9:17], uint64(time.Now().UnixMilli()))
	
	rh.conn.WriteToUDP(reply, addr)
	log.Printf(" Sent Connected Pong to %s", addr)
}


// cookieKey - Generate cookie key based on IP only (not IP:port)
// This allows client to retry from different ports
func cookieKey(addr *net.UDPAddr) string {
	return addr.IP.String()
}

// extractSequence - Extract 3-byte sequence number from RakNet packet
func extractSequence(data []byte) uint32 {
	if len(data) < 3 {
		return 0
	}
	return uint32(data[0])<<16 | uint32(data[1])<<8 | uint32(data[2])
}

// sendACK - Send ACK for a specific sequence number
func sendACK(conn *net.UDPConn, addr *net.UDPAddr, seq uint32) {
	ack := protocol.NewACK()
	ack.Packets = []uint32{seq}
	ackData := ack.Encode()
	conn.WriteToUDP(ackData, addr)
	log.Printf(" Sent ACK for seq=%d to %s", seq, addr)
}

// findSessionByIP - Find session by IP address (ignoring port)
// This allows handling port changes during connection
func (rh *RakNetHandler) findSessionByIP(ip string) *protocol.Session {
	rh.mu.RLock()
	defer rh.mu.RUnlock()
	
	for sessionKey, session := range rh.sessions {
		// Extract IP from "IP:Port" key
		if len(sessionKey) > 0 {
			colonIdx := -1
			for i := len(sessionKey) - 1; i >= 0; i-- {
				if sessionKey[i] == ':' {
					colonIdx = i
					break
				}
			}
			if colonIdx > 0 {
				sessionIP := sessionKey[:colonIdx]
				if sessionIP == ip {
					return session
				}
			}
		}
	}
	return nil
}

// sendSAMPAuthKey - Send SA-MP 0x02 Auth Key packet after connection established
func (rh *RakNetHandler) sendSAMPAuthKey(session *protocol.Session) {
	log.Printf("=== Sending SA-MP 0x02 Auth Key ===")
	
	// SA-MP 0x02 = PACKET_AUTH_KEY
	// Format: packetID(1) + keyLen(1) + key(keyLen)
	key := "SAMP_AUTH_KEY_12" // 16 byte auth key
	
	buf := new(bytes.Buffer)
	buf.WriteByte(0x02) // SA-MP packet ID: PACKET_AUTH_KEY
	buf.WriteByte(byte(len(key)))
	buf.WriteString(key)
	
	// Encapsulate in RELIABLE_ORDERED frame
	encap := &protocol.EncapsulatedPacket{
		Reliability: protocol.RELIABLE_ORDERED,
		Payload:     buf.Bytes(),
	}
	session.AddToQueue(encap)
	
	log.Printf(" Queued SA-MP 0x02 auth key")
}

// sendConnectionAccepted - Send SA-MP 0x14 Connection Accepted
func (rh *RakNetHandler) sendConnectionAccepted(session *protocol.Session) {
	log.Printf("=== Sending SA-MP 0x14 Connection Accepted ===")
	
	buf := new(bytes.Buffer)
	buf.WriteByte(0x14) // SA-MP packet ID: PACKET_CONNECTION_ACCEPTED
	binary.Write(buf, binary.LittleEndian, session.PlayerID) // player ID
	buf.WriteByte(0) // is NPC = false
	
	// Encapsulate in RELIABLE_ORDERED frame
	encap := &protocol.EncapsulatedPacket{
		Reliability: protocol.RELIABLE_ORDERED,
		Payload:     buf.Bytes(),
	}
	session.AddToQueue(encap)
	
	log.Printf(" Queued SA-MP 0x14 connection accepted, playerID=%d nickname=%s", 
		session.PlayerID, session.Nickname)
}

// sendRequestClassResponse - Send SA-MP 0x43 Request Class Response
func (rh *RakNetHandler) sendRequestClassResponse(session *protocol.Session) {
	log.Printf("=== Sending SA-MP 0x43 Request Class Response ===")
	
	buf := new(bytes.Buffer)
	buf.WriteByte(0x43) // SA-MP packet ID: REQUEST_CLASS
	buf.WriteByte(1)    // request accepted
	buf.WriteByte(0)    // team
	binary.Write(buf, binary.LittleEndian, uint32(0)) // skin ID
	buf.WriteByte(0) // unk
	
	// Spawn position
	binary.Write(buf, binary.LittleEndian, float32(0.0))  // x
	binary.Write(buf, binary.LittleEndian, float32(0.0))  // y
	binary.Write(buf, binary.LittleEndian, float32(3.0))  // z
	binary.Write(buf, binary.LittleEndian, float32(0.0))  // angle
	
	// Weapons (12 slots, each 2 bytes)
	for i := 0; i < 12; i++ {
		buf.WriteByte(0) // weapon
		buf.WriteByte(0) // ammo
	}
	
	// Encapsulate in RELIABLE_ORDERED frame
	encap := &protocol.EncapsulatedPacket{
		Reliability: protocol.RELIABLE_ORDERED,
		Payload:     buf.Bytes(),
	}
	session.AddToQueue(encap)
	
	log.Printf(" Queued SA-MP 0x43 request class response")
}

// sendPlayerSpawn - Send SA-MP 0x04 Player Spawn
func (rh *RakNetHandler) sendPlayerSpawn(session *protocol.Session) {
	log.Printf("=== Sending SA-MP 0x04 Player Spawn ===")
	
	buf := new(bytes.Buffer)
	buf.WriteByte(0x04) // SA-MP packet ID: PLAYER_SPAWN
	
	// Encapsulate in RELIABLE_ORDERED frame
	encap := &protocol.EncapsulatedPacket{
		Reliability: protocol.RELIABLE_ORDERED,
		Payload:     buf.Bytes(),
	}
	session.AddToQueue(encap)
	
	log.Printf(" Queued SA-MP 0x04 player spawn")
}

// getOrMigrateSession - Get session by addr, or migrate if port changed
func (rh *RakNetHandler) getOrMigrateSession(addr *net.UDPAddr) (*protocol.Session, bool) {
	key := addr.String()
	ip := addr.IP.String()
	
	rh.mu.Lock()
	defer rh.mu.Unlock()
	
	// Check exact match first
	if sess, ok := rh.sessions[key]; ok {
		return sess, false // false = not migrated
	}
	
	// Check by IP - port migration
	if sess, ok := rh.sessionsByIP[ip]; ok {
		oldKey := sess.Addr.String()
		
		// Remove old entry
		delete(rh.sessions, oldKey)
		
		// Update port
		sess.Addr = addr
		
		// Register new port
		rh.sessions[key] = sess
		
		log.Printf(" Port migrated: %s  %s", oldKey, key)
		return sess, true // true = migrated
	}
	
	return nil, false
}

// createSession - Create new session and register by both IP:Port and IP
func (rh *RakNetHandler) createSession(addr *net.UDPAddr, mtu uint16) *protocol.Session {
	rh.mu.Lock()
	defer rh.mu.Unlock()
	
	sess := protocol.NewSession(addr, mtu)
	key := addr.String()
	ip := addr.IP.String()
	
	rh.sessions[key] = sess
	rh.sessionsByIP[ip] = sess
	
	log.Printf(" Created session: %s", key)
	return sess
}

// sendFullHandshakeSequence - Send full handshake sequence after first 0x88
func (rh *RakNetHandler) sendFullHandshakeSequence(addr *net.UDPAddr) {
	sessionKey := addr.String()
	rh.mu.RLock()
	session, exists := rh.sessions[sessionKey]
	rh.mu.RUnlock()
	
	if !exists {
		log.Printf(" No session found for %s, cannot send handshake", addr)
		return
	}
	
	// FIX #5: Check if E3:00 already sent
	session.Mu.Lock()
	if session.SentE3Phase0 {
		log.Printf(" E3:00 already sent to %s, skipping handshake", addr)
		session.Mu.Unlock()
		return
	}
	session.SentE3Phase0 = true
	session.Mu.Unlock()
	
	log.Printf(" Sending full handshake sequence to %s", addr)
	
	d := 5 * time.Millisecond
	
	// Step 1: e3:00 auth response (raw UDP) - sent IMMEDIATELY without ACK
	log.Printf(" E3:00 packet length: %d bytes (should be 25)", len(packetE3_00))
	log.Printf("   E3:00 hex: %s", hex.EncodeToString(packetE3_00))
	
	n, err := rh.conn.WriteToUDP(packetE3_00, addr)
	if err != nil {
		log.Printf(" Failed to send E3:00: %v", err)
		return
	}
	
	log.Printf(" Sent E3:00 challenge: %d bytes (no ACK before this)", n)
	time.Sleep(d)
	
	// Step 2: e3:01 (raw UDP) - only if not already sent
	session.Mu.Lock()
	if !session.SentE3Phase1 {
		session.SentE3Phase1 = true
		session.Mu.Unlock()
		rh.conn.WriteToUDP(packetE3_01, addr)
		log.Printf(" Sent E3:01")
	} else {
		session.Mu.Unlock()
		log.Printf(" E3:01 already sent, skipping")
	}
	time.Sleep(d)
	
	// Step 3: 0x00 init packet (raw UDP) - DEPRECATED, not used in new flow
	// rh.conn.WriteToUDP(packet00_init, addr)
	log.Printf(" Skipping 0x00 init packet (deprecated)")
	time.Sleep(d)
	
	// Step 4: 0xE5 NWBitStream packet (raw UDP) - FIX #4: was 0xE7
	session.Mu.Lock()
	if !session.SentNWBitStream {
		session.SentNWBitStream = true
		session.Mu.Unlock()
		rh.conn.WriteToUDP(protocol.PacketE5, addr)
		log.Printf(" Sent 0xE5 NWBitStream (8 bytes)")
	} else {
		session.Mu.Unlock()
		log.Printf(" 0xE5 already sent, skipping")
	}
	time.Sleep(d)
	
	// Step 5: 0x01 timing packet (wrapped in RakNet datagram) - DEPRECATED
	// rh.sendRakNetDatagram(session, packet01_timing)
	log.Printf(" Skipping 0x01 timing packet (deprecated)")
	
	// CRITICAL: Set state to READY after handshake complete
	session.Mu.Lock()
	session.State = protocol.STATE_READY
	session.HandshakeSent = true
	session.Mu.Unlock()
	
	log.Printf(" Full handshake sequence complete - state=READY, waiting for client keepalive to trigger 0x04")
}

// sendPostStreamingSequence - Send post-streaming sequence and wait for 0x28
func (rh *RakNetHandler) sendPostStreamingSequence(addr *net.UDPAddr) {
	sessionKey := addr.String()
	rh.mu.RLock()
	session, exists := rh.sessions[sessionKey]
	rh.mu.RUnlock()
	
	if !exists {
		log.Printf(" No session found for %s, cannot send post-streaming", addr)
		return
	}
	
	// Log state
	session.Mu.RLock()
	state := session.State
	gameEntrySent := session.GameEntrySent
	session.Mu.RUnlock()
	log.Printf(" [sendPostStreamingSequence] sessionKey='%s', state=%d, gameEntrySent=%v", sessionKey, state, gameEntrySent)
	
	log.Printf(" Sending spawn sequence to %s", addr)
	
	// ============================================================
	// CRITICAL: Send E3:21  InitGame  Spawn ONLY
	// World streaming will be sent LATER after client sync
	// ============================================================
	
	// Step 1: E3:21  MUST be sent FIRST
	rh.conn.WriteToUDP(protocol.PacketE3_21, addr)
	log.Printf(" E3:21 SENT  now sending InitGame and spawn RPCs!")
	
	// Step 2: Send spawn RPC sequence (InitGame  SetSpawnInfo  SpawnPlayer  TogglePlayerControllable)
	// This MUST happen BEFORE world streaming packets
	rh.sendSpawnSequence(session)
	
	// Get final orderIndex after spawn
	session.Mu.RLock()
	finalOrderIndex := session.ChannelOrderIndex[0]
	session.Mu.RUnlock()
	
	log.Printf(" RakNet counters after spawn  seq=%d msg=%d order[ch0]=%d", 
		session.SequenceNumber, session.MessageIndex, finalOrderIndex)
	log.Printf(" Spawn sequence complete! Waiting for client sync (0x28) before world streaming...")
	log.Printf(" Client should now exit 'Welcome to Grand Larceny' and prepare to spawn...")
}

// sendWorldStreamingPackets - Send world streaming packets AFTER client sync
// This should be called AFTER receiving 0x28 confirmation from client
func (rh *RakNetHandler) sendWorldStreamingPackets(session *protocol.Session) {
	session.Mu.RLock()
	addr := session.Addr
	session.Mu.RUnlock()
	
	log.Printf(" [sendWorldStreamingPackets] Starting for %s", addr)
	
	// Step 1: E3:09 streaming start
	rh.conn.WriteToUDP(protocol.PacketE3_09, addr)
	log.Printf(" Sent e3:09 (3 bytes)")
	
	// Small delay between batches to avoid overwhelming client
	time.Sleep(50 * time.Millisecond)
	
	// Step 2: 0x3F zone info
	rh.sendRakNetDatagram(session, protocol.Packet3F)
	log.Printf(" Sent 0x3F zone info (41 bytes)")
	
	// Step 3: E3:17
	rh.conn.WriteToUDP(protocol.PacketE3_17, addr)
	log.Printf(" Sent E3:17 (3 bytes)")
	
	// Step 4: 0x40
	rh.sendRakNetDatagram(session, protocol.Packet40)
	log.Printf(" Sent 0x40 (153 bytes)")
	
	time.Sleep(50 * time.Millisecond)
	
	// Step 5: E3:18
	rh.conn.WriteToUDP(protocol.PacketE3_18, addr)
	log.Printf(" Sent E3:18 (3 bytes)")
	
	// Step 6: 0x43
	rh.sendRakNetDatagram(session, protocol.Packet43)
	log.Printf(" Sent 0x43 (153 bytes)")
	
	// Step 7: E3:19
	rh.conn.WriteToUDP(protocol.PacketE3_19, addr)
	log.Printf(" Sent E3:19 (3 bytes)")
	
	// Step 8: 0x46
	rh.sendRakNetDatagram(session, protocol.Packet46)
	log.Printf(" Sent 0x46 (153 bytes)")
	
	time.Sleep(50 * time.Millisecond)
	
	// Step 9: E3:1A
	rh.conn.WriteToUDP(protocol.PacketE3_1A, addr)
	log.Printf(" Sent E3:1A (3 bytes)")
	
	// Step 10: 0x49 spawn point
	rh.sendRakNetDatagram(session, protocol.Packet49)
	log.Printf(" Sent 0x49 spawn point (8 bytes)")
	
	// Step 11: E5:1B
	rh.conn.WriteToUDP(protocol.PacketE5_1B, addr)
	log.Printf(" Sent E5:1B (6 bytes)")
	
	// Step 12: 0x4A world objects
	rh.sendRakNetDatagram(session, protocol.Packet4A)
	log.Printf(" Sent 0x4A world objects (465 bytes)")
	
	time.Sleep(50 * time.Millisecond)
	
	// Step 13: Spawn packets 0x51-0x7B
	rh.sendRakNetDatagram(session, protocol.Packet51)
	log.Printf(" Sent 0x51 (530 bytes)")
	rh.sendRakNetDatagram(session, protocol.Packet58)
	log.Printf(" Sent 0x58 (534 bytes)")
	
	time.Sleep(50 * time.Millisecond)
	
	rh.sendRakNetDatagram(session, protocol.Packet5E)
	log.Printf(" Sent 0x5E (547 bytes)")
	rh.sendRakNetDatagram(session, protocol.Packet65)
	log.Printf(" Sent 0x65 (532 bytes)")
	
	time.Sleep(50 * time.Millisecond)
	
	rh.sendRakNetDatagram(session, protocol.Packet68)
	log.Printf(" Sent 0x68 (532 bytes)")
	rh.sendRakNetDatagram(session, protocol.Packet6C)
	log.Printf(" Sent 0x6C (532 bytes)")
	
	time.Sleep(50 * time.Millisecond)
	
	rh.sendRakNetDatagram(session, protocol.Packet6F)
	log.Printf(" Sent 0x6F (532 bytes)")
	rh.sendRakNetDatagram(session, protocol.Packet73)
	log.Printf(" Sent 0x73 (536 bytes)")
	rh.sendRakNetDatagram(session, protocol.Packet7B)
	log.Printf(" Sent 0x7B (153 bytes)")
	
	log.Printf(" World streaming complete! Player should see world objects now.")
}

// sendSpawnSequence - Send spawn RPC sequence after E3:21
func (rh *RakNetHandler) sendSpawnSequence(session *protocol.Session) {
	log.Printf(" [sendSpawnSequence] Starting spawn RPC sequence...")
	
	// Get current orderIndex for channel 0 BEFORE sending
	session.Mu.RLock()
	if session.ChannelOrderIndex == nil {
		session.ChannelOrderIndex = make(map[uint8]uint32)
	}
	currentOrderIndex := session.ChannelOrderIndex[0]
	session.Mu.RUnlock()
	
	log.Printf(" RakNet counters at spawn start  seq=%d msg=%d order[ch0]=%d", 
		session.SequenceNumber, session.MessageIndex, currentOrderIndex)
	log.Printf(" ORDER DEBUG  orderIndex BEFORE spawn RPCs = %d", currentOrderIndex)
	
	// ============================================================
	// CRITICAL SA-MP 0.3.7 SPAWN SEQUENCE:
	// 1. InitGame (0x2B) - World configuration
	// 2. SetGameModeText (0x3E) - Gamemode name
	// 3. SetWorldTime (0x29) - Time of day
	// 4. SetWeather (0x0B) - Weather
	// 5. SetSpawnInfo (0x2C) - Spawn location
	// 6. SpawnPlayer (0x34) - Trigger spawn
	// 7. TogglePlayerControllable (0x15) - Enable controls
	// ============================================================
	
	// 0 InitGame RPC (0x2B) - CRITICAL: Must be sent FIRST
	rpcPayload0 := protocol.BuildInitGameRPC(
		true,                    // zoneNames - enable zone names
		false,                   // useCJWalk - use CJ walk style
		true,                    // allowWeapons - allow weapons
		false,                   // limitGlobalChatRadius - no chat radius limit
		0.0,                     // globalChatRadius - unlimited
		true,                    // stuntBonus - enable stunt bonus
		70.0,                    // nameTagDrawDistance - 70 meters
		false,                   // disableEnterExits - allow interior entry
		true,                    // nameTagLOS - name tags require line of sight
		false,                   // manualVehicleEngineAndLights - automatic
		1,                       // spawnsAvailable - number of spawn classes
		0,                       // playerID - will be set by server
		true,                    // showNameTags - show player name tags
		1,                       // showPlayerMarkers - show on radar (1=always)
		uint8(rh.server.WorldTime), // worldTimeHour - from config
		uint8(rh.server.Weather),   // weather - from config
		0.008,                   // gravity - default SA-MP gravity
		true,                    // lanMode - LAN mode enabled
		0,                       // deathDropMoney - no money drop on death
		false,                   // instagib - normal damage
		40,                      // onFootRate - sync rate
		40,                      // inCarRate - sync rate
		40,                      // weaponRate - sync rate
		1000,                    // multiplier - lag comp multiplier
		1,                       // lagCompensation - enabled
		rh.server.ServerName,    // hostname - from config (SA-MP 0.3.7-R2)
		false,                   // vehicleFriendlyFire - disabled
		false,                   // usePlayerPedAnims - use default anims
		-20000.0,                // worldBoundsMinX
		-20000.0,                // worldBoundsMinY
		20000.0,                 // worldBoundsMaxX
		20000.0,                 // worldBoundsMaxY
		rh.server.GameMode,      // gamemodeText - from config
		rh.server.MapName,       // mapName - from config
	)
	
	packet0 := protocol.EncodeRPCPacket(rpcPayload0)
	log.Printf("    InitGame (0x2B): packet[0]=0x%02X packet[1]=0x%02X size=%d bytes", 
		packet0[0], packet0[1], len(packet0))
	log.Printf("    InitGame payload size (without 0x7C wrapper): %d bytes", len(rpcPayload0))
	log.Printf("    InitGame TOTAL packet size (with 0x7C wrapper): %d bytes", len(packet0))
	if len(packet0) < 90 {
		log.Printf("    CRITICAL: InitGame packet TOO SMALL! Expected >90 bytes, got %d bytes", len(packet0))
		log.Printf("    InitGame full hex: %02X", packet0)
	} else {
		log.Printf("    InitGame packet size OK: %d bytes", len(packet0))
		log.Printf("    InitGame hex (first 64 bytes): %02X", packet0[:64])
	}
	rh.sendRakNetDatagram(session, packet0)
	
	session.Mu.RLock()
	orderAfter0 := session.ChannelOrderIndex[0]
	session.Mu.RUnlock()
	log.Printf(" Sent RPC InitGame (0x2B) - %d bytes [order[ch0]=%d]", len(packet0), orderAfter0-1)
	log.Printf("    InitGame config: weather=%d worldtime=%d:00 gravity=0.008", rh.server.Weather, rh.server.WorldTime)
	
	// 1 SetGameModeText RPC (0x3E) - MUST match config gamemode
	rpcPayload1 := protocol.BuildSetGameModeTextRPC(rh.server.GameMode)
	packet1 := protocol.EncodeRPCPacket(rpcPayload1)
	log.Printf("    SetGameModeText (0x3E): packet[0]=0x%02X packet[1]=0x%02X size=%d bytes", 
		packet1[0], packet1[1], len(packet1))
	rh.sendRakNetDatagram(session, packet1)
	
	session.Mu.RLock()
	orderAfter1 := session.ChannelOrderIndex[0]
	session.Mu.RUnlock()
	log.Printf(" Sent RPC SetGameModeText (0x3E) = '%s' - %d bytes [order[ch0]=%d]", 
		rh.server.GameMode, len(packet1), orderAfter1-1)
	
	// 2 SetWorldTime RPC (0x29) - MUST match config worldtime
	rpcPayload2 := protocol.BuildSetWorldTimeRPC(uint8(rh.server.WorldTime))
	packet2 := protocol.EncodeRPCPacket(rpcPayload2)
	log.Printf("    SetWorldTime (0x29): packet[0]=0x%02X packet[1]=0x%02X size=%d bytes", 
		packet2[0], packet2[1], len(packet2))
	rh.sendRakNetDatagram(session, packet2)
	
	session.Mu.RLock()
	orderAfter2 := session.ChannelOrderIndex[0]
	session.Mu.RUnlock()
	log.Printf(" Sent RPC SetWorldTime (0x29) = %d:00 - %d bytes [order[ch0]=%d]", 
		rh.server.WorldTime, len(packet2), orderAfter2-1)
	
	// 3 SetWeather RPC (0x0B) - MUST match config weather AND rules query
	rpcPayload3 := protocol.BuildSetWeatherRPC(uint8(rh.server.Weather))
	packet3 := protocol.EncodeRPCPacket(rpcPayload3)
	log.Printf("    SetWeather (0x0B): packet[0]=0x%02X packet[1]=0x%02X size=%d bytes", 
		packet3[0], packet3[1], len(packet3))
	rh.sendRakNetDatagram(session, packet3)
	
	session.Mu.RLock()
	orderAfter3 := session.ChannelOrderIndex[0]
	session.Mu.RUnlock()
	log.Printf(" Sent RPC SetWeather (0x0B) = %d - %d bytes [order[ch0]=%d]", 
		rh.server.Weather, len(packet3), orderAfter3-1)
	log.Printf("    CRITICAL  Weather MUST match: InitGame=%d Rules=%d SetWeather=%d", 
		rh.server.Weather, rh.server.Weather, rh.server.Weather)
	
	// 4 SetSpawnInfo RPC (0x2C) - Spawn location and weapons
	rpcPayload4 := protocol.BuildSetSpawnInfoRPC(
		0,        // team
		0,        // skin (CJ)
		1958.0,   // X
		1343.0,   // Y
		15.0,     // Z
		270.0,    // rotation
		24, 200,  // weapon 1: Desert Eagle + 200 ammo
		31, 300,  // weapon 2: M4 + 300 ammo
		34, 50,   // weapon 3: Sniper Rifle + 50 ammo
	)
	
	packet4 := protocol.EncodeRPCPacket(rpcPayload4)
	log.Printf("    SetSpawnInfo (0x2C): packet[0]=0x%02X packet[1]=0x%02X size=%d bytes", 
		packet4[0], packet4[1], len(packet4))
	rh.sendRakNetDatagram(session, packet4)
	
	session.Mu.RLock()
	orderAfter4 := session.ChannelOrderIndex[0]
	session.Mu.RUnlock()
	log.Printf(" Sent RPC SetSpawnInfo (0x2C) - %d bytes [order[ch0]=%d]", 
		len(packet4), orderAfter4-1)
	
	// 5 SpawnPlayer RPC (0x34) - Trigger spawn
	rpcPayload5 := protocol.BuildSpawnPlayerRPC()
	packet5 := protocol.EncodeRPCPacket(rpcPayload5)
	log.Printf("    SpawnPlayer (0x34): packet[0]=0x%02X packet[1]=0x%02X size=%d bytes", 
		packet5[0], packet5[1], len(packet5))
	rh.sendRakNetDatagram(session, packet5)
	
	session.Mu.RLock()
	orderAfter5 := session.ChannelOrderIndex[0]
	session.Mu.RUnlock()
	log.Printf(" Sent RPC SpawnPlayer (0x34) - %d bytes [order[ch0]=%d]", 
		len(packet5), orderAfter5-1)
	
	// 6 TogglePlayerControllable RPC (0x15) - Enable controls
	rpcPayload6 := protocol.BuildTogglePlayerControllableRPC(true)
	packet6 := protocol.EncodeRPCPacket(rpcPayload6)
	log.Printf("    TogglePlayerControllable (0x15): packet[0]=0x%02X packet[1]=0x%02X size=%d bytes", 
		packet6[0], packet6[1], len(packet6))
	rh.sendRakNetDatagram(session, packet6)
	
	session.Mu.RLock()
	orderAfter6 := session.ChannelOrderIndex[0]
	session.Mu.RUnlock()
	log.Printf(" Sent RPC TogglePlayerControllable (0x15) = true - %d bytes [order[ch0]=%d]", 
		len(packet6), orderAfter6-1)
	
	// Final validation: Ensure orderIndex increased monotonically
	session.Mu.RLock()
	finalOrderIndex := session.ChannelOrderIndex[0]
	session.Mu.RUnlock()
	
	if finalOrderIndex <= currentOrderIndex {
		log.Printf(" CRITICAL ERROR: orderIndex DID NOT INCREASE! Before=%d After=%d", currentOrderIndex, finalOrderIndex)
		log.Printf(" This will cause client to reject spawn RPCs!")
	} else {
		log.Printf(" ORDER VALIDATION PASSED: orderIndex increased from %d to %d (increment=%d)", 
			currentOrderIndex, finalOrderIndex, finalOrderIndex-currentOrderIndex)
	}
	
	log.Printf(" [sendSpawnSequence] Complete! Sent 7 RPCs in correct order.")
	log.Printf(" Client should now exit 'Welcome to Grand Larceny' and spawn at position (1958, 1343, 15)!")
}

// sendFullGameEntrySequence: Kirim LENGKAP semua packet game entry.
// Phase 1: Streaming raw packets (sebelum E3:09)
// Phase 2: E3:09  Packet3F  E3:17  ...  E3:21
// Dipanggil dari handler 0x8A. Setelah E3:21, client kirim 0x28 dari port baru.
func (rh *RakNetHandler) sendFullGameEntrySequence(addr *net.UDPAddr) {
	sessionKey := addr.String()
	rh.mu.RLock()
	_, exists := rh.sessions[sessionKey]
	rh.mu.RUnlock()
	
	if !exists {
		log.Printf(" [sendFullGameEntrySequence] No session for %s", addr)
		return
	}
	
	log.Printf(" [sendFullGameEntrySequence] Starting for %s", addr)
	
	// Phase 1: Raw streaming packets (pkt39pkt94)
	for i, pkt := range [][]byte{
		streamingPacket0x04,
		streamingPacket54,
		streamingPacket55,
		streamingPacket56,
		streamingPacket57,
		streamingPacket58,
		streamingPacket59,
		streamingPacket60,
		streamingPacket61,
		streamingPacket63,
		streamingPacket65,
		streamingPacket67,
		streamingPacket69,
		streamingPacket71,
		streamingPacket73,
		streamingPacket75,
		streamingPacket77,
		streamingPacket79,
		streamingPacket81,
		streamingPacket83,
		streamingPacket85,
		streamingPacket87,
		streamingPacket89,
		streamingPacket91,
		streamingPacket93,
	} {
		if _, err := rh.conn.WriteToUDP(pkt, addr); err != nil {
			log.Printf(" Error sending streaming pkt[%d]: %v", i, err)
		}
	}
	log.Printf(" [sendFullGameEntrySequence] Phase 1 done")
	
	// Phase 2: E3:09  zone  spawn  E3:21
	rh.sendPostStreamingSequence(addr)
	
	log.Printf(" [sendFullGameEntrySequence] Done  waiting for 0x28 from client new port")
}

// sendJoinResponseSequence - DEPRECATED: Use sendPostStreamingSequence instead
// This function is kept for reference but should not be called
func (rh *RakNetHandler) sendJoinResponseSequence(addr *net.UDPAddr) {
	log.Printf(" sendJoinResponseSequence is deprecated, use sendPostStreamingSequence instead")
	rh.sendPostStreamingSequence(addr)
}

// min - Helper function to return minimum of two integers
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

// sanitizeMTU - Validate and sanitize MTU value to safe range
func sanitizeMTU(mtu uint16) uint16 {
	const (
		MIN_MTU     = 400
		MAX_MTU     = 1500
		DEFAULT_MTU = 1492
	)
	
	if mtu < MIN_MTU {
		log.Printf(" MTU %d too small (min %d), using default %d", mtu, MIN_MTU, DEFAULT_MTU)
		return DEFAULT_MTU
	}
	
	if mtu > MAX_MTU {
		log.Printf(" MTU %d too large (max %d), using default %d", mtu, MAX_MTU, DEFAULT_MTU)
		return DEFAULT_MTU
	}
	
	log.Printf(" Client MTU: %d (valid)", mtu)
	return mtu
}

// ============================================================
// SIMPLIFIED PACKET HANDLERS (v5 - Complete Refactor)
// ============================================================

// handleCookieRequest handles 0x08 cookie request
func (rh *RakNetHandler) handleCookieRequest(data []byte, addr *net.UDPAddr, session *protocol.Session) {
	// Duplicate guard
	if session != nil && session.State >= protocol.STATE_HANDSHAKE_SENT {
		// Already sent 0x1A, resend it
		rh.send0x1A(addr, session)
		return
	}

	rh.mu.Lock()
	if session == nil {
		session = protocol.NewSession(addr, 576)
		rh.sessions[addr.String()] = session
	}
	rh.mu.Unlock()

	// Save cookie
	cookie := []byte{data[1], data[2], data[3]}
	session.Mu.Lock()
	session.Cookie = cookie
	session.State = protocol.STATE_HANDSHAKE_SENT
	session.Mu.Unlock()

	rh.send0x1A(addr, session)
}

// send0x1A sends cookie response with XOR-encoded client port
func (rh *RakNetHandler) send0x1A(addr *net.UDPAddr, session *protocol.Session) {
	clientPort := uint16(addr.Port)
	hi := byte(clientPort >> 8)
	lo := byte(clientPort & 0xFF)
	packet := []byte{0x1A, hi ^ 0x82, lo ^ 0x93}
	rh.conn.WriteToUDP(packet, addr)
	log.Printf("[0x1A] Sent to %s port=%d encoded=[%02X,%02X]",
		addr, clientPort, hi^0x82, lo^0x93)
}

// sendOpenConnectionReply2 sends 0x19 reply
func (rh *RakNetHandler) sendOpenConnectionReply2(session *protocol.Session) {
	session.Mu.Lock()
	if session.State >= protocol.STATE_CONNECTING {
		session.Mu.Unlock()
		return // Already sent, don't duplicate
	}
	session.State = protocol.STATE_CONNECTING
	session.Mu.Unlock()

	packet := []byte{0x19, 0x00}
	rh.conn.WriteToUDP(packet, session.Addr)
	log.Printf("[0x19] Sent to %s", session.Addr)
}

// handleAuth handles 0x88 auth packet and sends E3:00 challenge
func (rh *RakNetHandler) handleAuthPacket(data []byte, addr *net.UDPAddr, session *protocol.Session) {
	if session == nil {
		log.Printf("[0x88] No session for %s, ignored", addr)
		return
	}
	
	session.Mu.Lock()
	if session.SentE3Phase0 {
		session.Mu.Unlock()
		log.Printf("[0x88] E3:00 already sent to %s, ignored retry", addr)
		return
	}
	session.SentE3Phase0 = true
	session.Mu.Unlock()

	//  DO NOT send 0xC0 ACK here
	rh.sendE3Challenge(session)
}

// sendE3Challenge sends E3:00 challenge packet (MUST be exactly 25 bytes)
func (rh *RakNetHandler) sendE3Challenge(session *protocol.Session) {
	seq := session.NextSeq() // Dynamic sequence, starts from 1

	challenge := "44D33F34EFE4EF5" // 15 chars, fixed

	packet := []byte{0xE3}
	packet = append(packet, seq...)                     // [1-3] dynamic seq
	packet = append(packet, 0x00)                       // [4]
	packet = append(packet, 0x85)                       // [5]
	packet = append(packet, 0x20)                       // [6]
	packet = append(packet, 0x0C)                       // [7]
	packet = append(packet, byte(len(challenge)+1))     // [8] = 0x10
	packet = append(packet, []byte(challenge)...)       // [9-23]
	packet = append(packet, 0x00)                       // [24] null terminator

	// CRITICAL: Must be exactly 25 bytes
	if len(packet) != 25 {
		log.Printf("  E3:00 length ERROR: %d bytes (want 25)", len(packet))
		log.Printf("   E3:00 hex: %s", hex.EncodeToString(packet))
		return
	}

	rh.conn.WriteToUDP(packet, session.Addr)
	log.Printf(" E3:00 packet length: %d", len(packet))
	log.Printf("   E3:00 hex: %s", hex.EncodeToString(packet))
	log.Printf("[E3:00] Sent seq=%d (%d bytes) to %s", session.SendSeq, len(packet), session.Addr)
}

// handleLoginData handles 0x22 login data and sends E3:01 + 0x00 connection info
func (rh *RakNetHandler) handleLoginData(data []byte, addr *net.UDPAddr, session *protocol.Session) {
	if session == nil {
		return
	}
	
	session.Mu.Lock()
	if session.SentE3Phase1 {
		session.Mu.Unlock()
		return
	}
	session.SentE3Phase1 = true
	session.Mu.Unlock()

	log.Printf("[0x22] Login data (%d bytes) from %s", len(data), addr)

	// Send E3:01
	rh.sendE3Phase1(session)

	// Send 0x00 connection info (17 bytes) - format from official
	rh.sendConnectionInfo(session)
}

// sendE3Phase1 sends E3:01 packet
func (rh *RakNetHandler) sendE3Phase1(session *protocol.Session) {
	seq := session.NextSeq()
	packet := []byte{0xE3}
	packet = append(packet, seq...)
	packet = append(packet, 0x01, 0x00)
	rh.conn.WriteToUDP(packet, session.Addr)
	log.Printf("[E3:01] Sent seq=%d to %s", session.SendSeq, session.Addr)
}

// sendConnectionInfo sends 0x00 connection info packet (17 bytes)
func (rh *RakNetHandler) sendConnectionInfo(session *protocol.Session) {
	// Format from official: 00:80:42:68:22:7f:00:00:01:c7:ce:00:00:27:4c:00:00
	// byte[1-4] = server IP (127.0.0.1 = 7f:00:00:01)
	// byte[5-6] = server port LE (7777 = 0x1E61  61:1e)
	// byte[7-8] = ?
	// byte[9-10] = client port LE
	// byte[11-16] = ?
	clientPort := uint16(session.Addr.Port)
	serverPort := uint16(7777)

	packet := []byte{
		0x00,
		0x80,                                   // flags
		0x42, 0x68,                             // ??
		0x22,                                   // ??
		0x7F, 0x00, 0x00, 0x01,                 // server IP 127.0.0.1
		byte(serverPort), byte(serverPort >> 8), // server port LE
		0x00, 0x00,
		byte(clientPort), byte(clientPort >> 8), // client port LE
		0x00, 0x00,
	}
	rh.conn.WriteToUDP(packet, session.Addr)
	log.Printf("[0x00] Connection info sent to %s", session.Addr)
}

// handle0x2A handles auth response and sends 0xE5 player sync
func (rh *RakNetHandler) handle0x2AAuthResponse(data []byte, addr *net.UDPAddr, session *protocol.Session) {
	if session == nil {
		return
	}
	
	session.Mu.Lock()
	if session.SentNWBitStream {
		session.Mu.Unlock()
		return
	}
	session.SentNWBitStream = true
	session.Mu.Unlock()
	
	rh.sendE5PlayerSync(session)
}

// sendE5PlayerSync sends 0xE5 player sync packet wrapped in RakNet datagram
func (rh *RakNetHandler) sendE5PlayerSync(session *protocol.Session) {
	// Use predefined E5 packet
	rh.sendRakNetDatagram(session, protocol.PacketE5)
	log.Printf("[E5] Player sync sent (wrapped in RakNet datagram) to %s", session.Addr)
	
	// Langsung kirim E3:07 spawn list setelah E5
	// E3:07 will use msgIndex+1 and orderIndex+1 automatically
	rh.sendE3SpawnList(session)
}

// sendE3SpawnList sends E3:07 spawn list packet wrapped in RakNet datagram
func (rh *RakNetHandler) sendE3SpawnList(session *protocol.Session) {
	// Check if already sent
	session.Mu.Lock()
	if session.SentE3Phase7 {
		session.Mu.Unlock()
		return
	}
	session.SentE3Phase7 = true
	session.Mu.Unlock()
	
	// Use predefined E3:07 packet
	rh.sendRakNetDatagram(session, protocol.PacketE3_07)
	log.Printf("[E3:07] Spawn list sent (wrapped in RakNet datagram) to %s", session.Addr)
}

// handleFullConnectionRequest handles 0x0A full connection request (84 bytes)
// E3:07 is now sent after E5, so this function just logs
func (rh *RakNetHandler) handleFullConnectionRequest(data []byte, addr *net.UDPAddr, session *protocol.Session) {
	if session == nil {
		return
	}
	
	log.Printf("[0x0A] Full connection request received from %s (E3:07 will be sent after E5)", session.Addr)
}
